{"filter":false,"title":"board-trebon.c","tooltip":"/arch/arm/mach-msm/board-trebon.c","undoManager":{"mark":3,"position":3,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":4444,"column":0},"action":"remove","lines":["/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved."," *"," * This program is free software; you can redistribute it and/or modify"," * it under the terms of the GNU General Public License version 2 and"," * only version 2 as published by the Free Software Foundation."," *"," * This program is distributed in the hope that it will be useful,"," * but WITHOUT ANY WARRANTY; without even the implied warranty of"," * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"," * GNU General Public License for more details."," *"," */","#include <linux/kernel.h>","#include <linux/init.h>","#include <linux/gpio_event.h>","#include <linux/i2c-gpio.h>","#include <asm/mach-types.h>","#include <asm/mach/arch.h>","#include <mach/board.h>","#include <mach/msm_iomap.h>","#include <mach/msm_hsusb.h>","#include <mach/rpc_hsusb.h>","#include <mach/rpc_pmapp.h>","#include <mach/usbdiag.h>","#include <mach/usb_gadget_fserial.h>","#include <mach/msm_memtypes.h>","#include <mach/msm_serial_hs.h>","#include <linux/usb/android.h>","#include <linux/platform_device.h>","#include <linux/io.h>","#include <mach/gpio_trebon.h>","#include <mach/pmic.h>","#include <mach/socinfo.h>","#include <linux/mtd/nand.h>","#include <linux/mtd/partitions.h>","#include <asm/mach/mmc.h>","#include <linux/i2c.h>","#include <linux/i2c/sx150x.h>","#include <linux/gpio.h>","#include <linux/android_pmem.h>","#include <linux/bootmem.h>","#include <linux/mfd/marimba.h>","#include <mach/vreg.h>","#include <linux/power_supply.h>","#include <linux/regulator/consumer.h>","#include <mach/rpc_pmapp.h>","#include <mach/msm_battery.h>","#include <linux/smsc911x.h>","#include <linux/ion.h>","#include \"devices.h\"","#include \"timer.h\"","#include \"board-msm7x27a-regulator.h\"","#include \"devices-msm7x2xa.h\"","#include \"pm.h\"","#ifdef CONFIG_SAMSUNG_JACK","#include <linux/sec_jack.h>","#endif","#include <mach/rpc_server_handset.h>","#include <mach/socinfo.h>","#include <linux/fsaxxxx_usbsw.h>","#include \"proc_comm.h\"","#include \"pm-boot.h\"","#ifdef CONFIG_PROXIMITY_SENSOR","#include <linux/gp2a.h>","#endif","#ifdef CONFIG_FORCE_FAST_CHARGE","#include <linux/fastchg.h>","#endif","","#ifndef CONFIG_MSM_CAMERA","#define CONFIG_MSM_CAMERA","#endif","","#ifdef CONFIG_FORCE_FAST_CHARGE","#include <linux/fastchg.h>","#endif","","#define _CONFIG_MACH_JENA // Temporary flag","#define _CONFIG_MACH_TREBON // Temporary flag","#define ADSP_RPC_PROG           0x3000000a","","#define PMEM_KERNEL_EBI1_SIZE\t0x3A000","#define MSM_PMEM_AUDIO_SIZE\t0x1F4000 //0x5B000","#define BAHAMA_SLAVE_ID_FM_ADDR         0x2A","#define BAHAMA_SLAVE_ID_QMEMBIST_ADDR   0x7B","#define BAHAMA_SLAVE_ID_FM_REG 0x02","#define FM_GPIO\t83","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","#define GPIO_BLUETOOTH_LDO 82","#endif","","#ifdef CONFIG_BQ27425_FUEL_GAUGE","#define FUEL_I2C_SCL 78","#define FUEL_I2C_SDA 79","#endif","","int charging_boot;","EXPORT_SYMBOL(charging_boot);","int\tfota_boot;","EXPORT_SYMBOL(fota_boot);","","#define WLAN_33V_CONTROL_FOR_BT_ANTENNA","","#define WLAN_OK (0)","#define WLAN_ERROR (-1)","","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","#define WLAN_33V_WIFI_FLAG (0x01)","#define WLAN_33V_BT_FLAG (0x02)","","int wlan_33v_flag;","","static int wlan_setup_ldo_33v(int input_flag, int on);","#endif","","#ifdef CONFIG_SAMSUNG_JACK","","#define GPIO_JACK_S_35\t48","#define GPIO_SEND_END\t92","","static struct sec_jack_zone jack_zones[] = {","\t[0] = {","\t\t.adc_high\t= 3,","\t\t.delay_ms\t= 10,","\t\t.check_count\t= 5,","\t\t.jack_type\t= SEC_HEADSET_3POLE,","\t},","\t[1] = {","\t\t.adc_high\t= 99,","\t\t.delay_ms\t= 10,","\t\t.check_count\t= 10,","\t\t.jack_type\t= SEC_HEADSET_3POLE,","\t},","\t[2] = {","\t\t.adc_high\t= 9999,","\t\t.delay_ms\t= 10,","\t\t.check_count\t= 5,","\t\t.jack_type\t= SEC_HEADSET_4POLE,","\t},","};","","int get_msm7x27a_det_jack_state(void)","{","\t/* Active Low */","\treturn(gpio_get_value(GPIO_JACK_S_35)) ^ 1;","}","EXPORT_SYMBOL(get_msm7x27a_det_jack_state);","","static int get_msm7x27a_send_key_state(void)","{","\treturn 0;","}","","#define SMEM_PROC_COMM_MICBIAS_ONOFF\t\tPCOM_OEM_MICBIAS_ONOFF","#define SMEM_PROC_COMM_MICBIAS_ONOFF_REG5\tPCOM_OEM_MICBIAS_ONOFF_REG5","#define SMEM_PROC_COMM_GET_ADC\t\t\t\tPCOM_OEM_SAMSUNG_GET_ADC","","enum {","\tSMEM_PROC_COMM_GET_ADC_BATTERY = 0x0,","\tSMEM_PROC_COMM_GET_ADC_TEMP,","\tSMEM_PROC_COMM_GET_ADC_VF,","\tSMEM_PROC_COMM_GET_ADC_ALL, // data1 : VF(MSB 2 bytes) vbatt_adc(LSB 2bytes), data2 : temp_adc","\tSMEM_PROC_COMM_GET_ADC_EAR_ADC,\t\t// 3PI_ADC","\tSMEM_PROC_COMM_GET_ADC_MAX,","};","","enum {","\tSMEM_PROC_COMM_MICBIAS_CONTROL_OFF = 0x0,","\tSMEM_PROC_COMM_MICBIAS_CONTROL_ON,","\tSMEM_PROC_COMM_MICBIAS_CONTROL_MAX","};","","static void set_msm7x27a_micbias_state_reg5(bool state) {}","static bool cur_state = false;","static bool proximity_init;","","static void set_msm7x27a_micbias_state(bool state)","{","\tif(cur_state == state)","\t{","\t\tpr_info(\"sec_jack : earmic_bias same as cur_state\\n\");","\t\treturn;","\t}","\tif(state)","\t{","\t\tpmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_ALWAYS);","\t\tmsleep(130);","\t\tcur_state = true;","\t}","\telse","\t{","\t\tpmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_OFF);","\t\tcur_state = false;","\t}","","\treport_headset_status(state);","\tpr_info(\"sec_jack : earmic_bias %s\\n\", state?\"on\":\"off\");","}","","static int sec_jack_get_adc_value(void)","{","\treturn current_jack_type;","}","","void sec_jack_gpio_init(void)","{","\tgpio_tlmm_config(GPIO_CFG(GPIO_JACK_S_35, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tif(gpio_request(GPIO_JACK_S_35, \"h2w_detect\")<0)","\t\tpr_err(\"sec_jack:gpio_request fail\\n\");","\tif(gpio_direction_input(GPIO_JACK_S_35)<0)","\t\tpr_err(\"sec_jack:gpio_direction fail\\n\");","}","","static struct sec_jack_platform_data sec_jack_data = {","\t.get_det_jack_state\t= get_msm7x27a_det_jack_state,","\t.get_send_key_state\t= get_msm7x27a_send_key_state,","\t.set_micbias_state\t= set_msm7x27a_micbias_state,","\t.set_micbias_state_reg5\t= set_msm7x27a_micbias_state_reg5,","\t.get_adc_value\t= sec_jack_get_adc_value,","\t.zones\t\t= jack_zones,","\t.num_zones\t= ARRAY_SIZE(jack_zones),","\t.det_int\t= MSM_GPIO_TO_INT(GPIO_JACK_S_35),","\t.send_int\t= MSM_GPIO_TO_INT(GPIO_SEND_END),","};","","static struct platform_device sec_device_jack = {","\t.name           = \"sec_jack\",","\t.id             = -1,","\t.dev            = {","\t\t.platform_data  = &sec_jack_data,","\t},","};","#endif","","enum {","\tGPIO_EXPANDER_IRQ_BASE\t= NR_MSM_IRQS + NR_GPIO_IRQS,","\tGPIO_EXPANDER_GPIO_BASE\t= NR_MSM_GPIOS,","\t/* SURF expander */","\tGPIO_CORE_EXPANDER_BASE\t= GPIO_EXPANDER_GPIO_BASE,","\tGPIO_BT_SYS_REST_EN\t= GPIO_CORE_EXPANDER_BASE,","\tGPIO_WLAN_EXT_POR_N,","\tGPIO_DISPLAY_PWR_EN,","\tGPIO_BACKLIGHT_EN,","\tGPIO_PRESSURE_XCLR,","\tGPIO_VREG_S3_EXP,","\tGPIO_UBM2M_PWRDWN,","\tGPIO_ETM_MODE_CS_N,","\tGPIO_HOST_VBUS_EN,","\txGPIO_SPI_MOSI,","\txGPIO_SPI_MISO,","\txGPIO_SPI_CLK,","\txGPIO_SPI_CS0_N,","\tGPIO_CORE_EXPANDER_IO13,","\tGPIO_CORE_EXPANDER_IO14,","\tGPIO_CORE_EXPANDER_IO15,","\t/* Camera expander */","\tGPIO_CAM_EXPANDER_BASE\t= GPIO_CORE_EXPANDER_BASE + 16,","\tGPIO_CAM_GP_STROBE_READY\t= GPIO_CAM_EXPANDER_BASE,","\tGPIO_CAM_GP_AFBUSY,","\tGPIO_CAM_GP_CAM_PWDN,","\tGPIO_CAM_GP_CAM1MP_XCLR,","\tGPIO_CAM_GP_CAMIF_RESET_N,","\tGPIO_CAM_GP_STROBE_CE,","\tGPIO_CAM_GP_LED_EN1,","\tGPIO_CAM_GP_LED_EN2,","};","","#if defined(CONFIG_GPIO_SX150X)","enum {","\tSX150X_CORE,","\tSX150X_CAM,","};","","static struct sx150x_platform_data sx150x_data[] __initdata = {","\t[SX150X_CORE]\t= {","\t\t.gpio_base\t\t= GPIO_CORE_EXPANDER_BASE,","\t\t.oscio_is_gpo\t\t= false,","\t\t.io_pullup_ena\t\t= 0,","\t\t.io_pulldn_ena\t\t= 0,","\t\t.io_open_drain_ena\t= 0,","\t\t.irq_summary\t\t= -1,","\t},","\t[SX150X_CAM]\t= {","\t\t.gpio_base\t\t= GPIO_CAM_EXPANDER_BASE,","\t\t.oscio_is_gpo\t\t= false,","\t\t.io_pullup_ena\t\t= 0,","\t\t.io_pulldn_ena\t\t= 0,","\t\t.io_open_drain_ena\t= 0,","\t\t.irq_summary\t\t= -1,","\t},","};","#endif","","extern unsigned int board_hw_revision;","extern unsigned int kernel_uart_flag;","","/* FM Platform power and shutdown routines */","#define FPGA_MSM_CNTRL_REG2 0x90008010","","static void config_pcm_i2s_mode(int mode)","{","\tvoid __iomem *cfg_ptr;","\tu8 reg2;","","\tcfg_ptr = ioremap_nocache(FPGA_MSM_CNTRL_REG2, sizeof(char));","","\tif (!cfg_ptr)","\t\treturn;","\tif (mode) {","\t\t/*enable the pcm mode in FPGA*/","\t\treg2 = readb_relaxed(cfg_ptr);","\t\tif (reg2 == 0) {","\t\t\treg2 = 1;","\t\t\twriteb_relaxed(reg2, cfg_ptr);","\t\t}","\t} else {","\t\t/*enable i2s mode in FPGA*/","\t\treg2 = readb_relaxed(cfg_ptr);","\t\tif (reg2 == 1) {","\t\t\treg2 = 0;","\t\t\twriteb_relaxed(reg2, cfg_ptr);","\t\t}","\t}","\tiounmap(cfg_ptr);","}","","static unsigned fm_i2s_config_power_on[] = {","\t/*FM_I2S_SD*/","\tGPIO_CFG(68, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*FM_I2S_WS*/","\tGPIO_CFG(70, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*FM_I2S_SCK*/","\tGPIO_CFG(71, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","","static unsigned fm_i2s_config_power_off[] = {","\t/*FM_I2S_SD*/","\tGPIO_CFG(68, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*FM_I2S_WS*/","\tGPIO_CFG(70, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*FM_I2S_SCK*/","\tGPIO_CFG(71, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","};","","static unsigned bt_config_power_on[] = {","\t/*RFR*/","\tGPIO_CFG(43, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*CTS*/","\tGPIO_CFG(44, 2, GPIO_CFG_INPUT,  GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*RX*/","\tGPIO_CFG(45, 2, GPIO_CFG_INPUT,  GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*TX*/","\tGPIO_CFG(46, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","static unsigned bt_config_pcm_on[] = {","\t/*PCM_DOUT*/","\tGPIO_CFG(68, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*PCM_DIN*/","\tGPIO_CFG(69, 1, GPIO_CFG_INPUT,  GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*PCM_SYNC*/","\tGPIO_CFG(70, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*PCM_CLK*/","\tGPIO_CFG(71, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","static unsigned bt_config_power_off[] = {","\t/*RFR*/","\tGPIO_CFG(43, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t/*CTS*/","\tGPIO_CFG(44, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t/*RX*/","\tGPIO_CFG(45, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t/*TX*/","\tGPIO_CFG(46, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","};","static unsigned bt_config_pcm_off[] = {","\t/*PCM_DOUT*/","\tGPIO_CFG(68, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*PCM_DIN*/","\tGPIO_CFG(69, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*PCM_SYNC*/","\tGPIO_CFG(70, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*PCM_CLK*/","\tGPIO_CFG(71, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","};","","","static int config_i2s(int mode)","{","\tint pin, rc = 0;","","\tif (mode == FM_I2S_ON) {","\t\tif (machine_is_msm7x27a_surf())","\t\t\tconfig_pcm_i2s_mode(0);","\t\tpr_err(\"%s mode = FM_I2S_ON\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(fm_i2s_config_power_on);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(","\t\t\t\t\tfm_i2s_config_power_on[pin],","\t\t\t\t\tGPIO_CFG_ENABLE","\t\t\t\t\t);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","\t} else if (mode == FM_I2S_OFF) {","\t\tpr_err(\"%s mode = FM_I2S_OFF\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(fm_i2s_config_power_off);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(","\t\t\t\t\tfm_i2s_config_power_off[pin],","\t\t\t\t\tGPIO_CFG_ENABLE","\t\t\t\t\t);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","\t}","\treturn rc;","}","static int config_pcm(int mode)","{","\tint pin, rc = 0;","","\tif (mode == BT_PCM_ON) {","\t\tif (machine_is_msm7x27a_surf())","\t\t\tconfig_pcm_i2s_mode(1);","\t\tpr_err(\"%s mode =BT_PCM_ON\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_pcm_on);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(bt_config_pcm_on[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","\t} else if (mode == BT_PCM_OFF) {","\t\tpr_err(\"%s mode =BT_PCM_OFF\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_pcm_off);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(bt_config_pcm_off[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","","\t}","","\treturn rc;","}","","static int msm_bahama_setup_pcm_i2s(int mode)","{","\tint fm_state = 0, bt_state = 0;","\tint rc = 0;","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","","\tfm_state = marimba_get_fm_status(&config);","\tbt_state = marimba_get_bt_status(&config);","","\tswitch (mode) {","\tcase BT_PCM_ON:","\tcase BT_PCM_OFF:","\t\tif (!fm_state)","\t\t\trc = config_pcm(mode);","\t\tbreak;","\tcase FM_I2S_ON:","\t\trc = config_i2s(mode);","\t\tbreak;","\tcase FM_I2S_OFF:","\t\tif (bt_state)","\t\t\trc = config_pcm(BT_PCM_ON);","\t\telse","\t\t\trc = config_i2s(mode);","\t\tbreak;","\tdefault:","\t\trc = -EIO;","\t\tpr_err(\"%s:Unsupported mode\", __func__);","\t}","\treturn rc;","}","","static int bt_set_gpio(int on)","{","\tint rc = 0;","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","","\tif (on) {","\t\trc = gpio_direction_output(GPIO_BT_PWR, 1);","\t\tmsleep(100);","\t} else {","\t\tif (!marimba_get_fm_status(&config) &&","\t\t\t\t!marimba_get_bt_status(&config)) {","\t\t\tgpio_set_value_cansleep(GPIO_BT_PWR, 0);","\t\t\trc = gpio_direction_input(GPIO_BT_PWR);","\t\t\tmsleep(100);","\t\t}","\t}","\tif (rc)","\t\tpr_err(\"%s: BT sys_reset_en GPIO : Error\", __func__);","","\treturn rc;","}","static struct regulator *fm_regulator;","static int fm_radio_setup(struct marimba_fm_platform_data *pdata)","{","\tint rc = 0;","\tconst char *id = \"FMPW\";","\tuint32_t irqcfg;","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","\tu8 value;","","\t/* Voting for 1.8V Regulator */","\tfm_regulator = regulator_get(NULL , \"vreg_msme\");","\tif (IS_ERR(fm_regulator)) {","\t\tpr_err(\"%s: regulator get failed with : (%ld)\\n\",","\t\t\t__func__, PTR_ERR(fm_regulator));","\t\treturn -EINVAL;","\t}","","\t/* Set the voltage level to 1.8V */","\trc = regulator_set_voltage(fm_regulator, 1800000, 1800000);","\tif (rc < 0) {","\t\tpr_err(\"%s: set regulator level failed with :(%d)\\n\",","\t\t\t__func__, rc);","\t\tgoto fm_regulator_fail;","\t}","","\t/* Enabling the 1.8V regulator */","\trc = regulator_enable(fm_regulator);","\tif (rc) {","\t\tpr_err(\"%s: enable regulator failed with :(%d)\\n\",","\t\t\t__func__, rc);","\t\tgoto fm_regulator_fail;","\t}","","\t/* Voting for 19.2MHz clock */","\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\tPMAPP_CLOCK_VOTE_ON);","\tif (rc < 0) {","\t\tpr_err(\"%s: clock vote failed with :(%d)\\n\",","\t\t\t __func__, rc);","\t\tgoto fm_clock_vote_fail;","\t}","","\trc = bt_set_gpio(1);","\tif (rc) {","\t\tpr_err(\"%s: bt_set_gpio = %d\", __func__, rc);","\t\tgoto fm_gpio_config_fail;","\t}","\t/*re-write FM Slave Id, after reset*/","\tvalue = BAHAMA_SLAVE_ID_FM_ADDR;","\trc = marimba_write_bit_mask(&config,","\t\t\tBAHAMA_SLAVE_ID_FM_REG, &value, 1, 0xFF);","\tif (rc < 0) {","\t\tpr_err(\"%s: FM Slave ID rewrite Failed = %d\", __func__, rc);","\t\tgoto fm_gpio_config_fail;","\t}","\t/* Configuring the FM GPIO */","\tirqcfg = GPIO_CFG(FM_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL,","\t\t\tGPIO_CFG_2MA);","","\trc = gpio_tlmm_config(irqcfg, GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t __func__, irqcfg, rc);","\t\tgoto fm_gpio_config_fail;","\t}","\treturn 0;","","fm_gpio_config_fail:","\tpmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\tPMAPP_CLOCK_VOTE_OFF);","\tbt_set_gpio(0);","fm_clock_vote_fail:","\tregulator_disable(fm_regulator);","","fm_regulator_fail:","\tregulator_put(fm_regulator);","","\treturn rc;","};","","static void fm_radio_shutdown(struct marimba_fm_platform_data *pdata)","{","\tint rc;","\tconst char *id = \"FMPW\";","","\t/* Releasing the GPIO line used by FM */","\tuint32_t irqcfg = GPIO_CFG(FM_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP,","\t\tGPIO_CFG_2MA);","","\trc = gpio_tlmm_config(irqcfg, GPIO_CFG_ENABLE);","\tif (rc)","\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t __func__, irqcfg, rc);","","\t/* Releasing the 1.8V Regulator */","\tif (fm_regulator != NULL) {","\t\trc = regulator_disable(fm_regulator);","","\t\tif (rc)","\t\t\tpr_err(\"%s: disable regulator failed:(%d)\\n\",","\t\t\t\t__func__, rc);","\t\tfm_regulator = NULL;","\t}","","\t/* Voting off the clock */","\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\tPMAPP_CLOCK_VOTE_OFF);","\tif (rc < 0)","\t\tpr_err(\"%s: voting off failed with :(%d)\\n\",","\t\t\t__func__, rc);","\trc = bt_set_gpio(0);","\tif (rc)","\t\tpr_err(\"%s: bt_set_gpio = %d\", __func__, rc);","}","","","#ifndef ATH_POLLING","static void (*wlan_status_notify_cb)(int card_present, void *dev_id);","void *wlan_devid;","","static int register_wlan_status_notify(void (*callback)(int card_present,","\t\t\t\t\tvoid *dev_id), void *dev_id)","{","\tprintk(KERN_INFO \"%s --enter\\n\", __func__);","","\twlan_status_notify_cb = callback;","\twlan_devid = dev_id;","\treturn 0;","}","","static unsigned int wlan_status(struct device *dev)","{","\tint rc;","","\tprintk(KERN_INFO \"%s entered\\n\", __func__);","","\trc = gpio_get_value(GPIO_WLAN_RESET_N/*gpio_wlan_reset_n*/);","","\treturn rc;","}","#endif /* ATH_POLLING */","","static struct marimba_fm_platform_data marimba_fm_pdata = {","\t.fm_setup = fm_radio_setup,","\t.fm_shutdown = fm_radio_shutdown,","\t.irq = MSM_GPIO_TO_INT(FM_GPIO),","\t.vreg_s2 = NULL,","\t.vreg_xo_out = NULL,","\t/* Configuring the FM SoC as I2S Master */","\t.is_fm_soc_i2s_master = true,","\t.config_i2s_gpio = msm_bahama_setup_pcm_i2s,","};","","static struct platform_device msm_wlan_ar6000_pm_device = {","\t.name           = \"wlan_ar6000_pm_dev\",","\t.id             = -1,","};","","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","static struct platform_device msm_bt_power_device = {","\t.name = \"bt_power\",","};","","struct bahama_config_register {","\tu8 reg;","\tu8 value;","\tu8 mask;","};","","static const char * const regulators_bahama_name[] = {","\t\"vreg_msme\",","#if (CONFIG_MACH_TREBON_HWREV != 0x0)","\t\"vbt\",","#endif","};","","static struct regulator *regulators_bahama[ARRAY_SIZE(regulators_bahama_name)];","","static int bahama_bt(int on)","{","","\tint rc = 0;","\tint i;","","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","","\tstruct bahama_variant_register {","\t\tconst size_t size;","\t\tconst struct bahama_config_register *set;","\t};","","\tconst struct bahama_config_register *p;","","\tu8 version;","","\tconst struct bahama_config_register v10_bt_on[] = {","\t\t{ 0xE9, 0x00, 0xFF },","\t\t{ 0xF4, 0x80, 0xFF },","\t\t{ 0xE4, 0x00, 0xFF },","\t\t{ 0xE5, 0x00, 0x0F },","#ifdef CONFIG_WLAN","\t\t{ 0xE6, 0x38, 0x7F },","\t\t{ 0xE7, 0x06, 0xFF },","#endif","\t\t{ 0xE9, 0x21, 0xFF },","\t\t{ 0x01, 0x0C, 0x1F },","\t\t{ 0x01, 0x08, 0x1F },","\t};","","\tconst struct bahama_config_register v20_bt_on_fm_off[] = {","\t\t{ 0x11, 0x0C, 0xFF },","\t\t{ 0x13, 0x01, 0xFF },","\t\t{ 0xF4, 0x80, 0xFF },","\t\t{ 0xF0, 0x00, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF },","#ifdef CONFIG_WLAN","\t\t{ 0x81, 0x00, 0x7F },","\t\t{ 0x82, 0x00, 0xFF },","\t\t{ 0xE6, 0x38, 0x7F },","\t\t{ 0xE7, 0x06, 0xFF },","#endif","\t\t{ 0x8E, 0x15, 0xFF },","\t\t{ 0x8F, 0x15, 0xFF },","\t\t{ 0x90, 0x15, 0xFF },","","\t\t{ 0xE9, 0x21, 0xFF },","\t};","","\tconst struct bahama_config_register v20_bt_on_fm_on[] = {","\t\t{ 0x11, 0x0C, 0xFF },","\t\t{ 0x13, 0x01, 0xFF },","\t\t{ 0xF4, 0x86, 0xFF },","\t\t{ 0xF0, 0x06, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF },","#ifdef CONFIG_WLAN","\t\t{ 0x81, 0x00, 0x7F },","\t\t{ 0x82, 0x00, 0xFF },","\t\t{ 0xE6, 0x38, 0x7F },","\t\t{ 0xE7, 0x06, 0xFF },","#endif","\t\t{ 0xE9, 0x21, 0xFF },","\t};","","\tconst struct bahama_config_register v10_bt_off[] = {","\t\t{ 0xE9, 0x00, 0xFF },","\t};","","\tconst struct bahama_config_register v20_bt_off_fm_off[] = {","\t\t{ 0xF4, 0x84, 0xFF },","\t\t{ 0xF0, 0x04, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF }","\t};","","\tconst struct bahama_config_register v20_bt_off_fm_on[] = {","\t\t{ 0xF4, 0x86, 0xFF },","\t\t{ 0xF0, 0x06, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF }","\t};","\tconst struct bahama_variant_register bt_bahama[2][3] = {","\t{","\t\t{ ARRAY_SIZE(v10_bt_off), v10_bt_off },","\t\t{ ARRAY_SIZE(v20_bt_off_fm_off), v20_bt_off_fm_off },","\t\t{ ARRAY_SIZE(v20_bt_off_fm_on), v20_bt_off_fm_on }","\t},","\t{","\t\t{ ARRAY_SIZE(v10_bt_on), v10_bt_on },","\t\t{ ARRAY_SIZE(v20_bt_on_fm_off), v20_bt_on_fm_off },","\t\t{ ARRAY_SIZE(v20_bt_on_fm_on), v20_bt_on_fm_on }","\t}","\t};","","\tu8 offset = 0; /* index into bahama configs */","\ton = on ? 1 : 0;","\tversion = marimba_read_bahama_ver(&config);","\tif ((int)version < 0 || version == BAHAMA_VER_UNSUPPORTED) {","\t\tdev_err(&msm_bt_power_device.dev, \"%s: Bahama \\","\t\t\t\tversion read Error, version = %d \\n\",","\t\t\t\t__func__, version);","\t\treturn -EIO;","\t}","","\tif (version == BAHAMA_VER_2_0) {","\t\tif (marimba_get_fm_status(&config))","\t\t\toffset = 0x01;","\t}","","\tp = bt_bahama[on][version + offset].set;","","\tdev_info(&msm_bt_power_device.dev,","\t\t\"%s: found version %d\\n\", __func__, version);","","\tfor (i = 0; i < bt_bahama[on][version + offset].size; i++) {","\t\tu8 value = (p+i)->value;","\t\trc = marimba_write_bit_mask(&config,","\t\t\t(p+i)->reg,","\t\t\t&value,","\t\t\tsizeof((p+i)->value),","\t\t\t(p+i)->mask);","\t\tif (rc < 0) {","\t\t\tdev_err(&msm_bt_power_device.dev,","\t\t\t\t\"%s: reg %x write failed: %d\\n\",","\t\t\t\t__func__, (p+i)->reg, rc);","\t\t\treturn rc;","\t\t}","\t\tdev_dbg(&msm_bt_power_device.dev,","\t\t\t\"%s: reg 0x%02x write value 0x%02x mask 0x%02x\\n\",","\t\t\t\t__func__, (p+i)->reg,","\t\t\t\tvalue, (p+i)->mask);","\t\tvalue = 0;","\t\trc = marimba_read_bit_mask(&config,","\t\t\t\t(p+i)->reg, &value,","\t\t\t\tsizeof((p+i)->value), (p+i)->mask);","\t\tif (rc < 0)","\t\t\tdev_err(&msm_bt_power_device.dev, \"%s marimba_read_bit_mask- error\",","\t\t\t\t\t__func__);","\t\tdev_dbg(&msm_bt_power_device.dev,","\t\t\t\"%s: reg 0x%02x read value 0x%02x mask 0x%02x\\n\",","\t\t\t\t__func__, (p+i)->reg,","\t\t\t\tvalue, (p+i)->mask);","\t}","\t/* Update BT Status */","\tif (on)","\t\tmarimba_set_bt_status(&config, true);","\telse","\t\tmarimba_set_bt_status(&config, false);","\treturn rc;","}","","static int bluetooth_switch_regulators(int on)","{","\tint i, rc = 0;","","\tfor (i = 0; i < ARRAY_SIZE(regulators_bahama_name); i++) {","\t\tif (!regulators_bahama[i]) {","\t\t\tpr_err(\"%s: regulator_get %s failed(%d)\\n\",","\t\t\t__func__, regulators_bahama_name[i], rc);","\t\t\tgoto regulator_fail;","\t\t}","","\t\trc = on ? regulator_set_voltage(regulators_bahama[i],","\t\t\t\t\ti ? 2900000 : 1800000,","\t\t\t\t\t\ti ? 2900000 : 1800000) : 0;","","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: regulator set level failed (%d)\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto regulator_set_voltage_fail;","\t\t}","","\t\trc = on ? regulator_enable(regulators_bahama[i]) :","\t\t\t  regulator_disable(regulators_bahama[i]);","","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: regulator %s %s failed(%d)\\n\",","\t\t\t\t__func__, regulators_bahama_name[i],","\t\t\t       on ? \"enable\" : \"disable\", rc);","\t\t\tgoto regulator_fail;","\t\t\t}","\t}","\treturn rc;","","regulator_fail:","\twhile (i) {","\t\tif (on)","\t\t\tregulator_disable(regulators_bahama[--i]);","\t\t}","regulator_set_voltage_fail:","\tregulator_put(regulators_bahama[0]);","\tregulator_put(regulators_bahama[1]);","\treturn rc;","}","","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","static int bluetooth_setup_ldo(unsigned gpio, int on)","{","\tint rc = 0;","","\tprintk(\"%s - %d : %s\\n\", __func__, gpio, on ? \"on\" : \"off\");","","\t// Request","\tif (gpio_request(gpio, \"bt_en_gpio\")) {","\t\tprintk(KERN_ERR \"%s: gpio_request for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","\tint temp = gpio_get_value(gpio);","       printk( \"%s:gpio_direction_output before(%d):: gpio_get_value=%d\\n\", __func__, on, temp);","","\trc = gpio_direction_output(gpio, on);","","        temp = gpio_get_value(gpio);","       printk( \"%s:gpio_direction_output after(%d):: gpio_get_value=%d\\n\", __func__, on, temp);","","\tgpio_free(gpio);","","\tif (rc) {","\t\tprintk(KERN_ERR \"%s: gpio_direction_output for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","\treturn 0;","}","#endif","","static unsigned int msm_bahama_setup_power(void)","{","\tprintk(\"%s -msm_bahama_setup_power\\n\", __func__);","","\tint rc = 0;","\tstruct regulator *regulator_s3 = NULL;","","\tregulator_s3 = regulator_get(NULL, \"vreg_msme\");","\tif (IS_ERR(regulator_s3)) {","\t\tpr_err(\"%s: regulator get failed (%ld)\\n\",","\t\t\t__func__, PTR_ERR(regulator_s3));","\t\treturn PTR_ERR(regulator_s3);","\t}","\trc = regulator_set_voltage(regulator_s3, 1800000, 1800000);","\tif (rc < 0) {","\t\tpr_err(\"%s: regulator set level failed (%d)\\n\",","\t\t\t\t__func__, rc);","\t\tgoto regulator_fail;","\t}","\trc = regulator_enable(regulator_s3);","\tif (rc < 0) {","\t\tpr_err(\"%s: regulator enable failed (%d)\\n\",","\t\t       __func__, rc);","\t\tgoto regulator_fail;","\t}","","\t/* Setup Bahama_sys_reset_n */","\trc = gpio_request(GPIO_BT_PWR, \"bahama sys_rst_n\");","\tif (rc < 0) {","\t\tpr_err(\"%s: gpio_request %d = %d\\n\", __func__,","\t\t\tGPIO_BT_PWR, rc);","\t\tgoto regulator_fail;","\t}","","\trc = bt_set_gpio(1);","\tif (rc < 0) {","\t\tpr_err(\"%s: bt_set_gpio %d = %d\\n\", __func__,","\t\t\tGPIO_BT_PWR, rc);","\t\tgoto gpio_fail;","\t}","\t//2011.07.06 qcomm - bt on failed","\tmsleep(100);","","\treturn rc;","","gpio_fail:","\tgpio_free(GPIO_BT_PWR);","regulator_fail:","\tregulator_put(regulator_s3);","\treturn rc;","}","","static unsigned int msm_bahama_shutdown_power(int value)","{","       printk(\"%s -msm_bahama_shutdown_power\\n\", __func__);","","\tint rc = 0;","\tstruct regulator *regulator_s3 = NULL;","","\tregulator_s3 = regulator_get(NULL, \"vreg_msme\");","\tif (IS_ERR(regulator_s3)) {","\t\tpr_err(\"%s: regulator get failed (%ld)\\n\",","\t\t\t__func__, PTR_ERR(regulator_s3));","\t\treturn PTR_ERR(regulator_s3);","\t}","\trc = regulator_disable(regulator_s3);","\tif (rc) {","\t\tpr_err(\"%s: regulator disable failed (%d)\\n\",","\t\t       __func__, rc);","\t\tregulator_put(regulator_s3);","\t\treturn rc;","\t}","","\tif (value == BAHAMA_ID) {","\t\trc = bt_set_gpio(0);","\t\tif (rc) {","\t\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t}","\t}","\treturn rc;","}","","static unsigned int msm_bahama_core_config(int type)","{","\tint rc = 0;","","\tif (type == BAHAMA_ID) {","\t\tint i;","\t\tstruct marimba config = { .mod_id = SLAVE_ID_BAHAMA };","\t\tconst struct bahama_config_register v20_init[] = {","\t\t\t/* reg, value, mask */","\t\t\t{ 0xF4, 0x84, 0xFF }, /* AREG */","\t\t\t{ 0xF0, 0x04, 0xFF } /* DREG */","\t\t};","\t\tif (marimba_read_bahama_ver(&config) == BAHAMA_VER_2_0) {","\t\t\tfor (i = 0; i < ARRAY_SIZE(v20_init); i++) {","\t\t\t\tu8 value = v20_init[i].value;","\t\t\t\trc = marimba_write_bit_mask(&config,","\t\t\t\t\tv20_init[i].reg,","\t\t\t\t\t&value,","\t\t\t\t\tsizeof(v20_init[i].value),","\t\t\t\t\tv20_init[i].mask);","\t\t\t\tif (rc < 0) {","\t\t\t\t\tpr_err(\"%s: reg %d write failed: %d\\n\",","\t\t\t\t\t\t__func__, v20_init[i].reg, rc);","\t\t\t\t\treturn rc;","\t\t\t\t}","\t\t\t\tpr_debug(\"%s: reg 0x%02x value 0x%02x\"","\t\t\t\t\t\" mask 0x%02x\\n\",","\t\t\t\t\t__func__, v20_init[i].reg,","\t\t\t\t\tv20_init[i].value, v20_init[i].mask);","\t\t\t}","\t\t}","\t}","\trc = bt_set_gpio(0);","\tif (rc) {","\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t       __func__, rc);","\t}","\tpr_debug(\"core type: %d\\n\", type);","\treturn rc;","}","","static int bluetooth_power(int on)","{","\tprintk(\"%s -bluetooth_power\\n\", __func__);","","\tint pin, rc = 0;","\tconst char *id = \"BTPW\";","\tint cid = 0;","","\tcid = adie_get_detected_connectivity_type();","\tif (cid != BAHAMA_ID) {","\t\tpr_err(\"%s: unexpected adie connectivity type: %d\\n\",","\t\t\t\t\t__func__, cid);","\t\treturn -ENODEV;","\t}","\tif (on) {","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\twlan_setup_ldo_33v(WLAN_33V_BT_FLAG, 1);","#endif","\t\t/* Setup power for BT SOC */","\t\trc = bt_set_gpio(on);","\t\tif (rc) {","\t\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto exit;","\t\t}","\t\trc = bluetooth_switch_regulators(on);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: bluetooth_switch_regulators rc = %d\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto exit;","\t\t}","","\t\t#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t\t if (bluetooth_setup_ldo(GPIO_BLUETOOTH_LDO,1))","\t\t {","\t\t\t\t\tpr_err(\"%s: GPIO_BLUETOOTH_LDO fail = %d\\n\",","\t\t\t\t\t\t\t__func__, GPIO_BLUETOOTH_LDO);","\t\t   return -ENODEV;","\t\t  }","\t\t\tmsleep(100);","\t\t#endif","\t\t/* Setup BT GPIO lines*/","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_power_on);","\t\t\tpin++) {","\t\t\trc = gpio_tlmm_config(bt_config_power_on[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t\t\t\t__func__,","\t\t\t\t\t\tbt_config_power_on[pin],","\t\t\t\t\t\trc);","\t\t\t\tgoto fail_power;","\t\t\t}","\t\t}","","\t\t/* Setup BT clocks */","\t\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\tPMAPP_CLOCK_VOTE_ON);","\t\tif (rc < 0) {","\t\t\tpr_err(\"Failed to vote for TCXO_D1 ON\\n\");","\t\t\tgoto fail_clock;","\t\t}","\t\tmsleep(20);","","\t\t/* I2C config for Bahama */","\t\trc = bahama_bt(1);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: bahama_bt rc = %d\", __func__, rc);","\t\t\tgoto fail_i2c;","\t\t}","\t\tmsleep(20);","","\t\t/* Setup BT PCM lines*/","\t\trc = msm_bahama_setup_pcm_i2s(BT_PCM_ON);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: msm_bahama_setup_pcm_i2s , rc =%d\\n\",","\t\t\t\t__func__, rc);","\t\t\t\tgoto fail_power;","\t\t\t}","\t\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\t\t  PMAPP_CLOCK_VOTE_PIN_CTRL);","\t\tif (rc < 0)","\t\t\tpr_err(\"%s:Pin Control Failed, rc = %d\",","\t\t\t\t\t__func__, rc);","","\t} else {","\t\trc = bahama_bt(0);","\t\tif (rc < 0)","\t\t\tpr_err(\"%s: bahama_bt rc = %d\", __func__, rc);","","\t\t#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t\t if (bluetooth_setup_ldo(GPIO_BLUETOOTH_LDO,0))","\t\t {","\t\t\t\t\tpr_err(\"%s: GPIO_BLUETOOTH_LDO fail = %d\\n\",","\t\t\t\t\t\t\t__func__, GPIO_BLUETOOTH_LDO);","\t\t   return -ENODEV;","\t\t  }","\t\t\tmsleep(100);","\t\t#endif","","\t\trc = bt_set_gpio(on);","\t\tif (rc) {","\t\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t}","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\twlan_setup_ldo_33v(WLAN_33V_BT_FLAG, 0);","#endif","fail_i2c:","\t\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\t\t  PMAPP_CLOCK_VOTE_OFF);","\t\tif (rc < 0)","\t\t\tpr_err(\"%s: Failed to vote Off D1\\n\", __func__);","fail_clock:","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_power_off);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(bt_config_power_off[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\t\tif (rc < 0) {","\t\t\t\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t\t\t__func__, bt_config_power_off[pin], rc);","\t\t\t\t}","\t\t\t}","\t\trc = msm_bahama_setup_pcm_i2s(BT_PCM_OFF);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: msm_bahama_setup_pcm_i2s, rc =%d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\t\t}","fail_power:","\t\trc = bluetooth_switch_regulators(0);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: switch_regulators : rc = %d\",\\","\t\t\t\t\t__func__, rc);","\t\t\tgoto exit;","\t\t}","\t}","\treturn rc;","exit:","\tpr_err(\"%s: failed with rc = %d\", __func__, rc);","\treturn rc;","}","","static int __init bt_power_init(void)","{","\tint i, rc = 0;","\tfor (i = 0; i < ARRAY_SIZE(regulators_bahama_name); i++) {","\t\t\tregulators_bahama[i] = regulator_get(NULL,","\t\t\t\t\t\tregulators_bahama_name[i]);","\t\t\tif (IS_ERR(regulators_bahama[i])) {","\t\t\t\tpr_err(\"%s: regulator get %s failed (%ld)\\n\",","\t\t\t\t       __func__, regulators_bahama_name[i],","\t\t\t\t       PTR_ERR(regulators_bahama[i]));","\t\t\t\trc = PTR_ERR(regulators_bahama[i]);","\t\t\t\tgoto regulator_get_fail;","\t\t\t}","\t\t}","","\tmsm_bt_power_device.dev.platform_data = &bluetooth_power;","","\treturn rc;","","regulator_get_fail:","\twhile (i)","\t\tregulator_put(regulators_bahama[--i]);","\treturn rc;","}","","static struct marimba_platform_data marimba_pdata = {","\t.slave_id[SLAVE_ID_BAHAMA_FM]        = BAHAMA_SLAVE_ID_FM_ADDR,","\t.slave_id[SLAVE_ID_BAHAMA_QMEMBIST]  = BAHAMA_SLAVE_ID_QMEMBIST_ADDR,","\t.bahama_setup                        = msm_bahama_setup_power,","\t.bahama_shutdown                     = msm_bahama_shutdown_power,","\t.bahama_core_config                  = msm_bahama_core_config,","\t.fm\t\t\t\t     = &marimba_fm_pdata,","};","","#endif","","#if defined(CONFIG_I2C) && defined(CONFIG_GPIO_SX150X)","static struct i2c_board_info core_exp_i2c_info[] __initdata = {","\t{","\t\tI2C_BOARD_INFO(\"sx1509q\", 0x3e),","\t\t.platform_data =  &sx150x_data[SX150X_CORE],","\t},","};","static struct i2c_board_info cam_exp_i2c_info[] __initdata = {","\t{","\t\tI2C_BOARD_INFO(\"sx1508q\", 0x22),","\t\t.platform_data\t= &sx150x_data[SX150X_CAM],","\t},","};","#endif","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","#ifdef CONFIG_PROXIMITY_SENSOR","static int gp2a_power(bool on)","{","/*","\tstruct regulator *regulator;","","\tldo15_init_data.constraints.state_mem.enabled = on;","\tldo15_init_data.constraints.state_mem.disabled = !on;","","\tif (on) {","\t\tregulator = regulator_get(NULL, \"vled\");","\t\tif (IS_ERR(regulator))","\t\t\treturn 0;","\t\tregulator_enable(regulator);","\t\tregulator_put(regulator);","\t} else {","\t\tregulator = regulator_get(NULL, \"vled\");","\t\tif (IS_ERR(regulator))","\t\t\treturn 0;","\t\tif (regulator_is_enabled(regulator))","\t\t\tregulator_force_disable(regulator);","\t\tregulator_put(regulator);","\t}","*/","","#if defined(CONFIG_MACH_TREBON)","\tint rc = 0;","\tif (board_hw_revision >= 0x06) {","\t\tif (proximity_init == false) {","\t\t\tpr_info(\"[GP2A] board hw revision %d\\n\",","\t\t\t\tboard_hw_revision);","\t\t\tstruct pm8xxx_gpio_rpc_cfg gpio_cfg = {","\t\t\t\t.gpio  = PMIC_GPIO_11,","\t\t\t\t.mode  = OUTPUT_ON,","\t\t\t\t.src_pull = PULL_UP_1_5uA,","\t\t\t\t.volt_src = PMIC_GPIO_VIN2,","\t\t\t\t.buf_config = CONFIG_CMOS,","\t\t\t};","","\t\t\trc = pmic_gpio_config(&gpio_cfg);","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"%s pmic gpio config failed %d \",","\t\t\t\t\t__func__,","\t\t\t\t\trc);","\t\t\t}","\t\t\tpmic_gpio_direction_output(PMIC_GPIO_11);","\t\t\tproximity_init = true;","\t\t\tgpio_tlmm_config(","\t\t\t\tGPIO_CFG(29, 0,","\t\t\t\t\tGPIO_CFG_INPUT,","\t\t\t\t\tGPIO_CFG_PULL_UP,","\t\t\t\t\tGPIO_CFG_2MA),","\t\t\t\tGPIO_CFG_ENABLE);","\t\t}","","\t\tif (on) {","\t\t\tpr_err(\"%s pmic gpio set to 1 \",","\t\t\t\t__func__);","\t\t\trc = pmic_gpio_set_value(PMIC_GPIO_11, 1);","\t\t\tif (rc < 0)","\t\t\t\tpr_err(\"%s pmic gpio set 1 error \",","\t\t\t\t\t__func__);","\t\t} else {","\t\t\tpr_err(\"%s pmic gpio set to 0 \",","\t\t\t\t__func__);","\t\t\trc = pmic_gpio_set_value(PMIC_GPIO_11, 0);","\t\t\tif (rc < 0)","\t\t\t\tpr_err(\"%s pmic gpio set 0 error \",","\t\t\t\t\t__func__);","\t\t}","\t} else {","\t\tgpio_tlmm_config(","\t\t\tGPIO_CFG(29, 0,","\t\t\t\tGPIO_CFG_INPUT,","\t\t\t\tGPIO_CFG_PULL_UP,","\t\t\t\tGPIO_CFG_2MA),","\t\t\tGPIO_CFG_ENABLE);","\t}","#else","\tgpio_tlmm_config(","\t\tGPIO_CFG(29, 0,","\t\t\tGPIO_CFG_INPUT,","\t\t\tGPIO_CFG_PULL_UP,","\t\t\tGPIO_CFG_2MA),","\t\tGPIO_CFG_ENABLE);","#endif","","\treturn 0;","}","","static struct gp2a_platform_data gp2a_pdata = {","\t.p_out = 29,","\t.power = gp2a_power,","};","#endif","","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","static struct i2c_board_info bahama_devices[] = {","{","\tI2C_BOARD_INFO(\"marimba\", 0xc),","\t.platform_data = &marimba_pdata,","},","};","","static struct i2c_board_info sensor_devices[] = {","\t#ifdef CONFIG_SENSORS_HSCD","{","\tI2C_BOARD_INFO(\"bma222\", 0x08),","},","{","\tI2C_BOARD_INFO(\"bma222e\", 0x18),","},","{","\tI2C_BOARD_INFO(\"hscd_i2c\", 0x0d),","},","\t#endif","\t#ifdef CONFIG_PROXIMITY_SENSOR","{","\tI2C_BOARD_INFO(\"gp2a\", 0x44 ),","\t.platform_data = &gp2a_pdata,","},","\t#endif","};","","\t#if defined(CONFIG_SENSORS_HSCD) || defined(CONFIG_PROXIMITY_SENSOR)","static struct i2c_gpio_platform_data sensor_i2c_gpio_data = {","\t.sda_pin = GPIO_SENSOR_SDA,","\t.scl_pin = GPIO_SENSOR_SCL,","\t.udelay = 1,","};","","static struct platform_device sensor_i2c_gpio_device = {","\t.name =\"i2c-gpio\",","\t.id = 4,","\t.dev = {","\t\t.platform_data =&sensor_i2c_gpio_data,","\t},","};","\t#endif","#else","static struct i2c_board_info bahama_devices[] = {","{","\tI2C_BOARD_INFO(\"marimba\", 0xc),","\t.platform_data = &marimba_pdata,","},","\t#ifdef CONFIG_SENSORS_HSCD","{","\tI2C_BOARD_INFO(\"accsns_i2c\", 0x08),","},","{","\tI2C_BOARD_INFO(\"hscd_i2c\", 0x0d),","},","\t#endif","\t#ifdef CONFIG_PROXIMITY_SENSOR","{","\tI2C_BOARD_INFO(\"gp2a\", 0x44 ),","\t.platform_data = &gp2a_pdata,","},","\t#endif","};","#endif","#endif","","static struct platform_device msm_device_pmic_leds = {","\t.name\t= \"pmic-leds\",","\t.id\t\t= -1,","};","","static struct platform_device msm_vibrator_device = {","\t.name\t= \"msm_vibrator\",","\t.id\t\t= -1,","};","","static struct i2c_gpio_platform_data touch_i2c_gpio_data = {","\t.sda_pin    = GPIO_TSP_SDA,","\t.scl_pin    = GPIO_TSP_SCL,","\t.udelay\t= 1,","};","","static struct platform_device touch_i2c_gpio_device = {","\t.name       = \"i2c-gpio\",","\t.id     =  2,","\t.dev        = {","\t\t.platform_data  = &touch_i2c_gpio_data,","\t},","};","","/* I2C 2 */","static struct i2c_board_info touch_i2c_devices[] = {","\t{","\t\tI2C_BOARD_INFO(\"zinitix_isp\", 0x50),","\t},","\t{","\t\tI2C_BOARD_INFO(\"sec_touchscreen\", 0x20),","\t        .irq = MSM_GPIO_TO_INT( GPIO_TOUCH_IRQ ),","\t},","};","","struct msm_battery_callback *charger_callbacks;","static enum cable_type_t set_cable_status;","static enum acc_type_t set_acc_status;","static enum ovp_type_t set_ovp_status;","","static void msm_battery_register_callback(","\t\tstruct msm_battery_callback *ptr)","{","\tcharger_callbacks = ptr;","\tpr_info(\"[BATT] msm_battery_register_callback start\\n\");","\tif ((set_acc_status != 0) && charger_callbacks","\t\t&& charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","","\tif ((set_cable_status != 0) && charger_callbacks","\t\t&& charger_callbacks->set_cable)","\t\tcharger_callbacks->set_cable(charger_callbacks,","\t\tset_cable_status);","","\tif ((set_ovp_status != 0) && charger_callbacks","\t\t&& charger_callbacks->set_ovp_type)","\t\tcharger_callbacks->set_ovp_type(charger_callbacks,","\t\tset_ovp_status);","}","","static u32 msm_calculate_batt_capacity(u32 current_voltage);","","static struct msm_charger_data aries_charger = {","\t.register_callbacks\t= msm_battery_register_callback,","};","","static struct msm_psy_batt_pdata msm_psy_batt_data = {","\t.charger\t\t\t= &aries_charger,","\t.voltage_min_design\t\t= 2800,","\t.voltage_max_design\t= 4300,","\t.avail_chg_sources\t\t= AC_CHG | USB_CHG ,","\t.batt_technology\t\t= POWER_SUPPLY_TECHNOLOGY_LION,","};","","static struct platform_device msm_batt_device = {","\t.name\t\t= \"msm-battery\",","\t.id\t\t= -1,","\t.dev.platform_data\t= &msm_psy_batt_data,","};","","int fsa_cable_type = CABLE_TYPE_UNKNOWN;","int fsa880_get_charger_status(void);","int fsa880_get_charger_status(void)","{","\treturn fsa_cable_type;","}","","static void jena_usb_power(int onoff, char *path) { }","","void trebon_chg_connected(enum chg_type chgtype)","{","\tchar *chg_types[] = {","\t\t        \"STD DOWNSTREAM PORT\",","\t\t\t\"CARKIT\",","\t\t\t\"DEDICATED CHARGER\",","\t\t\t\"INVALID\"};","\tunsigned *data1 = NULL;","\tunsigned *data2 = NULL;","\tint ret = 0;","","\tswitch (chgtype) {","\tcase USB_CHG_TYPE__SDP:","#ifdef CONFIG_FORCE_FAST_CHARGE","    \tif (force_fast_charge == 1)","\t\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_CHARGER_CONNECTED, ","\t\t\t\tdata1, data2);","\t\telse","#endif","\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_PC_CONNECTED, ","\t\t\tdata1, data2);","\t\tbreak;","\tcase USB_CHG_TYPE__CARKIT:","\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_CHARGER_CONNECTED,","\t\t\t\tdata1, data2);","\t\tbreak;","\tcase USB_CHG_TYPE__INVALID:","\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_DISCONNECTED,","\t\t\t\tdata1, data2);","\t\tbreak;","\tdefault:","\t\tbreak;","\t}","","\tif (ret < 0)","\t\tpr_err(\"%s: connection err, ret=%d\\n\", __func__, ret);","","\tpr_info(\"\\nCharger Type: %s\\n\", chg_types[chgtype]);","}","","static void jena_usb_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] [%s] Board file [FSA880]: USB Callback\\n\", __func__);","","\tset_acc_status = attached ? ACC_TYPE_USB : ACC_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","","\tset_cable_status = attached ? CABLE_TYPE_USB : CABLE_TYPE_UNKNOWN;","\tif (charger_callbacks && charger_callbacks->set_cable)","\t\tcharger_callbacks->set_cable(charger_callbacks,","\t\tset_cable_status);","}","","static void jena_charger_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] Board file [FSA880]: Charger Callback\\n\");","","\tset_acc_status = attached ? ACC_TYPE_CHARGER : ACC_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","","\tset_cable_status = attached ? CABLE_TYPE_TA : CABLE_TYPE_UNKNOWN;","\tif (charger_callbacks && charger_callbacks->set_cable)","\t\tcharger_callbacks->set_cable(charger_callbacks,","\t\tset_cable_status);","}","","static void jena_jig_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] Board file [FSA880]: Jig Callback\\n\");","","\tset_acc_status = attached ? ACC_TYPE_JIG : ACC_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","}","","static void jena_ovp_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] Board file [FSA880]: OVP Callback\\n\");","","\tset_ovp_status = attached ? OVP_TYPE_OVP : OVP_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_ovp_type)","\t\tcharger_callbacks->set_ovp_type(charger_callbacks,","\t\tset_ovp_status);","}","","/* check charger cable type for USB phy off */","static int checkChargerType()","{","\treturn set_cable_status;","}","","static void jena_fsa880_reset_cb(void)","{","\tpr_info(\" [BATT] Board file [FSA880]: Reset Callback\\n\");","}","","/* For uUSB Switch */","static struct fsausb_platform_data jena_fsa880_pdata = {","       .intb_gpio      = MSM_GPIO_TO_INT(GPIO_MUSB_INT),","       .usb_cb         = jena_usb_cb,","       .uart_cb        = NULL,","       .charger_cb     = jena_charger_cb,","       .jig_cb         = jena_jig_cb,","\t.ovp_cb\t\t= jena_ovp_cb,","       .reset_cb       = jena_fsa880_reset_cb,","};","","/* I2C 3 */","static struct i2c_gpio_platform_data fsa880_i2c_gpio_data = {","\t.sda_pin    = GPIO_MUS_SDA,","\t.scl_pin    = GPIO_MUS_SCL,","};","","static struct platform_device fsa880_i2c_gpio_device = {","\t.name       = \"i2c-gpio\",","\t.id     =  3,","\t.dev        = {","\t\t.platform_data  = &fsa880_i2c_gpio_data,","\t},","};","","static struct i2c_board_info fsa880_i2c_devices[] = {","\t{","\t\tI2C_BOARD_INFO(\"FSA9280\", 0x4A >> 1),","\t\t.platform_data =  &jena_fsa880_pdata,","\t\t.irq = MSM_GPIO_TO_INT(GPIO_MUSB_INT),","\t},","};","","#ifdef CONFIG_BQ27425_FUEL_GAUGE","/* Fuel_gauge */","static struct i2c_gpio_platform_data fuelgauge_i2c_gpio_data = {","\t.sda_pin = FUEL_I2C_SDA,","\t.scl_pin = FUEL_I2C_SCL,","};","","static struct platform_device fuelgauge_i2c_gpio_device = {","\t.name\t= \"i2c-gpio\",","\t.id\t= 6,","\t.dev\t= {","\t.platform_data\t= &fuelgauge_i2c_gpio_data,","\t},","};","static struct i2c_board_info fg_i2c_devices[] = {","\t{","\t\tI2C_BOARD_INFO( \"bq27425\", 0xAA>>1 ),","\t},","};","#endif","","static void __init register_i2c_devices(void)","{","#if defined(CONFIG_I2C) && defined(CONFIG_GPIO_SX150X)","\ti2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,","\t\t\t\tcam_exp_i2c_info,","\t\t\t\tARRAY_SIZE(cam_exp_i2c_info));","","\tif (machine_is_msm7x27a_surf())","\t\tsx150x_data[SX150X_CORE].io_open_drain_ena = 0xe0f0;","","\tcore_exp_i2c_info[0].platform_data =","\t\t\t&sx150x_data[SX150X_CORE];","","\ti2c_register_board_info(MSM_GSBI1_QUP_I2C_BUS_ID,","\t\t\t\tcore_exp_i2c_info,","\t\t\t\tARRAY_SIZE(core_exp_i2c_info));","#endif","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","\ti2c_register_board_info(MSM_GSBI1_QUP_I2C_BUS_ID,","\t\t\t\tbahama_devices,","\t\t\t\tARRAY_SIZE(bahama_devices));","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t#if defined(CONFIG_SENSORS_HSCD) || defined(CONFIG_PROXIMITY_SENSOR)","\ti2c_register_board_info(4, sensor_devices, ARRAY_SIZE(sensor_devices));","\t#endif","#endif","#endif","}","","static struct msm_gpio qup_i2c_gpios_io[] = {","\t{ GPIO_CFG(60, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(61, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_sda\" },","\t{ GPIO_CFG(131, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(132, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\"qup_sda\" },","};","","static struct msm_gpio qup_i2c_gpios_hw[] = {","\t{ GPIO_CFG(60, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(61, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_sda\" },","\t{ GPIO_CFG(131, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(132, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_sda\" },","};","","static void gsbi_qup_i2c_gpio_config(int adap_id, int config_type)","{","\tint rc;","","\tif (adap_id < 0 || adap_id > 1)","\t\treturn;","","\t/* Each adapter gets 2 lines from the table */","\tif (config_type)","\t\trc = msm_gpios_request_enable(&qup_i2c_gpios_hw[adap_id*2], 2);","\telse","\t\trc = msm_gpios_request_enable(&qup_i2c_gpios_io[adap_id*2], 2);","\tif (rc < 0)","\t\tpr_err(\"QUP GPIO request/enable failed: %d\\n\", rc);","}","","static struct msm_i2c_platform_data msm_gsbi0_qup_i2c_pdata = {","\t.clk_freq\t\t= 100000,","\t.msm_i2c_config_gpio\t= gsbi_qup_i2c_gpio_config,","};","","static struct msm_i2c_platform_data msm_gsbi1_qup_i2c_pdata = {","\t.clk_freq\t\t= 100000,","\t.msm_i2c_config_gpio\t= gsbi_qup_i2c_gpio_config,","};","","#ifdef CONFIG_ARCH_MSM7X27A","#define MSM_PMEM_MDP_SIZE       0x1800000 //25MB default: 0x1DD1000 (29MB)","#define MSM7x25A_MSM_PMEM_MDP_SIZE       0x1500000 //22MB","","#define MSM_PMEM_ADSP_SIZE      0x900000 // ~9MB","#define MSM_ION_VIDC_SIZE       0x1200000 // 18MB","#define MSM7x25A_MSM_PMEM_ADSP_SIZE      0xB91000 //12MB","","#ifdef CONFIG_FB_MSM_TRIPLE_BUFFER","#define MSM_FB_SIZE\t\t0x1C2000","#define MSM7x25A_MSM_FB_SIZE    0x1C2000","#define MSM8x25_MSM_FB_SIZE\t0x1C2000","#else","#define MSM_FB_SIZE\t\t0x1C2000","#define MSM7x25A_MSM_FB_SIZE\t0x12C000","#define MSM8x25_MSM_FB_SIZE\t0x1C2000","#endif","#endif","","#ifdef CONFIG_ION_MSM","#define MSM_ION_HEAP_NUM        4","static struct platform_device ion_dev;","static int msm_ion_camera_size;","static int msm_ion_audio_size;","static int msm_ion_sf_size;","#endif","","","static struct android_usb_platform_data android_usb_pdata = {","\t.update_pid_and_serial_num = usb_diag_update_pid_and_serial_num,","};","","static struct platform_device android_usb_device = {","\t.name\t= \"android_usb\",","\t.id\t= -1,","\t.dev\t= {","\t\t.platform_data = &android_usb_pdata,","\t},","};","","static int __init boot_mode_boot(char *onoff)","{","\tif (strncmp(onoff, \"batt\", 5) == 0) {","\t\tcharging_boot = 1;","\t\tfota_boot = 0;","\t\tpr_info(\"%s[BATT]charging_boot: %d\\n\",","\t\t\t__func__, charging_boot);","\t} else if (strncmp(onoff, \"fota\", 5) == 0) {","\t\tfota_boot = 1;","\t\tcharging_boot = 0;","\t} else {","\t\tcharging_boot = 0;","\t\tfota_boot = 0;","\t}","\treturn 1;","}","__setup(\"androidboot.boot_pause=\", boot_mode_boot);","","","#ifdef CONFIG_USB_EHCI_MSM_72K","static void msm_hsusb_vbus_power(unsigned phy_info, int on)","{","\tint rc = 0;","\tunsigned gpio;","","\tgpio = GPIO_HOST_VBUS_EN;","","\t\trc = gpio_request(gpio, \"i2c_host_vbus_en\");","\t\tif (rc < 0) {","\t\t\tpr_err(\"failed to request %d GPIO\\n\", gpio);","\t\t\treturn;","\t\t}","\tgpio_direction_output(gpio, !!on);","\tgpio_set_value_cansleep(gpio, !!on);","\tgpio_free(gpio);","}","","static struct msm_usb_host_platform_data msm_usb_host_pdata = {","\t.phy_info       = (USB_PHY_INTEGRATED | USB_PHY_MODEL_45NM),","};","","static void __init msm7x2x_init_host(void)","{","\tmsm_add_host(0, &msm_usb_host_pdata);","}","#endif","","#ifdef CONFIG_USB_MSM_OTG_72K","static int hsusb_rpc_connect(int connect)","{","\tif (connect)","\t\treturn msm_hsusb_rpc_connect();","\telse","\t\treturn msm_hsusb_rpc_close();","}","","static struct regulator *reg_hsusb;","static int msm_hsusb_ldo_init(int init)","{","\tint rc = 0;","","\tif (init) {","\t\treg_hsusb = regulator_get(NULL, \"usb\");","\t\tif (IS_ERR(reg_hsusb)) {","\t\t\trc = PTR_ERR(reg_hsusb);","\t\t\tpr_err(\"%s: sandeep could not get regulator: %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto out;","\t\t}","","\t\trc = regulator_set_voltage(reg_hsusb, 3300000, 3300000);","\t\tif (rc) {","\t\t\tpr_err(\"%s:sandeep could not set voltage: %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto reg_free;","\t\t}","","\t\treturn 0;","\t}","\t/* else fall through */","reg_free:","\tregulator_put(reg_hsusb);","out:","\treg_hsusb = NULL;","\treturn rc;","}","","static int msm_hsusb_ldo_enable(int enable)","{","\tstatic int ldo_status;","","\tif (IS_ERR_OR_NULL(reg_hsusb))","\t\treturn reg_hsusb ? PTR_ERR(reg_hsusb) : -ENODEV;","","\tif (ldo_status == enable)","\t\treturn 0;","","\tldo_status = enable;","","\treturn enable ?","\t\tregulator_enable(reg_hsusb) :","\t\tregulator_disable(reg_hsusb);","}","","#ifndef CONFIG_USB_EHCI_MSM_72K","static int msm_hsusb_pmic_notif_init(void (*callback)(int online), int init)","{","\tint ret = 0;","","\tif (init)","\t\tret = msm_pm_app_rpc_init(callback);","\telse","\t\tmsm_pm_app_rpc_deinit(callback);","","\treturn ret;","}","#endif","","static struct msm_otg_platform_data msm_otg_pdata = {","#ifndef CONFIG_USB_EHCI_MSM_72K","\t.pmic_vbus_notif_init\t = msm_hsusb_pmic_notif_init,","#else","\t.vbus_power\t\t = msm_hsusb_vbus_power,","#endif","\t.rpc_connect\t\t = hsusb_rpc_connect,","\t.pemp_level\t\t = PRE_EMPHASIS_WITH_20_PERCENT,","\t.cdr_autoreset\t\t = CDR_AUTO_RESET_DISABLE,","\t.drv_ampl\t\t = HS_DRV_AMPLITUDE_75_PERCENT,","\t.se1_gating\t\t = SE1_GATING_DISABLE,","\t.ldo_init\t\t = msm_hsusb_ldo_init,","\t.ldo_enable\t\t = msm_hsusb_ldo_enable,","\t.chg_init\t\t = hsusb_chg_init,","\t/* check charger cable type for USB phy off */","\t.chg_connect_type = checkChargerType,","\t/*  \t\t\t\t\t\t\t\t\t\t*/","\t.chg_connected\t\t = hsusb_chg_connected,","\t.chg_vbus_draw\t\t = hsusb_chg_vbus_draw,","};","#endif","","static struct msm_hsusb_gadget_platform_data msm_gadget_pdata = {","\t.is_phy_status_timer_on = 1,","};","","static struct resource smc91x_resources[] = {","\t[0] = {","\t\t.start = 0x90000300,","\t\t.end   = 0x900003ff,","\t\t.flags = IORESOURCE_MEM,","\t},","\t[1] = {","\t\t.start = MSM_GPIO_TO_INT(4),","\t\t.end   = MSM_GPIO_TO_INT(4),","\t\t.flags = IORESOURCE_IRQ,","\t},","};","","static struct platform_device smc91x_device = {","\t.name           = \"smc91x\",","\t.id             = 0,","\t.num_resources  = ARRAY_SIZE(smc91x_resources),","\t.resource       = smc91x_resources,","};","","#define WLAN_HOST_WAKE","","","#ifdef WLAN_HOST_WAKE","struct wlansleep_info {","\tunsigned host_wake;","\tunsigned host_wake_irq;","\tstruct wake_lock wake_lock;","};","","","static struct wlansleep_info *wsi;","static struct tasklet_struct hostwake_task;","","","static void wlan_hostwake_task(unsigned long data)","{","\tprintk(KERN_INFO \"WLAN: wake lock timeout 0.5 sec...\\n\");","\twake_lock_timeout(&wsi->wake_lock, HZ / 2);","}","","","static irqreturn_t wlan_hostwake_isr(int irq, void *dev_id)","{","\t/* schedule a tasklet to handle the change in the host wake line */","\ttasklet_schedule(&hostwake_task);","\treturn IRQ_HANDLED;","}","","","static int wlan_host_wake_init(void)","{","\tint ret;","","\twsi = kzalloc(sizeof(struct wlansleep_info), GFP_KERNEL);","\tif (!wsi)","\t\treturn -ENOMEM;","","\twake_lock_init(&wsi->wake_lock, WAKE_LOCK_SUSPEND, \"bluesleep\");","\ttasklet_init(&hostwake_task, wlan_hostwake_task, 0);","","\twsi->host_wake = GPIO_WLAN_HOST_WAKE;","\twsi->host_wake_irq = MSM_GPIO_TO_INT(wsi->host_wake);","","\tret = request_irq(wsi->host_wake_irq, wlan_hostwake_isr,","\t\t\t\t\t\tIRQF_DISABLED | IRQF_TRIGGER_RISING,","\t\t\t\t\t\t\"wlan hostwake\", NULL);","\tif (ret < 0) {","\t\tprintk(KERN_ERR \"WLAN: Couldn't acquire WLAN_HOST_WAKE IRQ\");","\t\treturn -1;","\t}","","\tret = enable_irq_wake(wsi->host_wake_irq);","\tif (ret < 0) {","\t\tprintk(KERN_ERR \"WLAN: Couldn't enable WLAN_HOST_WAKE as wakeup interrupt\");","\t\tfree_irq(wsi->host_wake_irq, NULL);","\t\treturn -1;","\t}","","\treturn 0;","}","","","static void wlan_host_wake_exit(void)","{","\tif (disable_irq_wake(wsi->host_wake_irq))","\t\tprintk(KERN_ERR \"WLAN: Couldn't disable hostwake IRQ wakeup mode \\n\");","","\tfree_irq(wsi->host_wake_irq, NULL);","","\twake_lock_destroy(&wsi->wake_lock);","\tkfree(wsi);","}","#endif /* WLAN_HOST_WAKE */","","","static int wlan_set_gpio(unsigned gpio, int on)","{","\tint rc = 0;","\tint gpio_value = 0;","","\tprintk(\"%s - %d : %s\\n\", __func__, gpio, on ? \"on\" : \"off\");","","\t// Request","\tif (gpio_request(gpio, \"wlan_ar6000_pm\")) {","\t\tprintk(KERN_ERR \"%s: gpio_request for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","","\tgpio_value = gpio_get_value(gpio);","\tprintk(KERN_INFO \"%s: before (%d) :: gpio_get_value = %d\",","\t\t\t__func__, on, gpio_value);","","\t// Direction Output On/Off","\trc = gpio_direction_output(gpio, on);","\tgpio_free(gpio);","","\tgpio_value = gpio_get_value(gpio);","\tprintk(KERN_INFO \"%s: after (%d) :: gpio_get_value = %d\",","\t\t\t__func__, on, gpio_value);","","\tif (rc) {","\t\tprintk(KERN_ERR \"%s: gpio_direction_output for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","","\treturn 0;","}","","","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","int wlan_setup_ldo_33v(int input_flag, int on)","{","\tint skip = 0;","\tint temp_flag = wlan_33v_flag;","","\tprintk(KERN_INFO \"%s - set by %s : %s\\n\",","\t\t\t__func__,","\t\t\t(input_flag == WLAN_33V_WIFI_FLAG) ? \"Wifi\" : \"BT\",","\t\t\ton ? \"on\" : \"off\");","\tprintk(KERN_INFO \"%s - old wlan_33v_flag : %d\\n\",","\t\t\t__func__, temp_flag);","","\tif (on) {","\t\tif (temp_flag)  /* Already On */","\t\t\tskip = 1;","","\t\ttemp_flag |= input_flag;","\t} else {","\t\ttemp_flag &= (~input_flag);","","\t\t/* Keep GPIO_WLAN_33V_EN on if either BT or Wifi is turned on*/","\t\tif (temp_flag)","\t\t\tskip = 1;","\t}","","\tprintk(KERN_INFO \"%s - new wlan_33v_flag : %d\\n\",","\t\t\t__func__, temp_flag);","","\tif (skip) {","\t\tprintk(KERN_INFO \"%s - Skip GPIO_WLAN_33V_EN %s\\n\",","\t\t\t\t__func__, on ? \"on\" : \"off\");","\t} else {","\t\t/* GPIO_WLAN_33V_EN - On / Off */","\t\tif (wlan_set_gpio(GPIO_WLAN_33V_EN, on))","\t\t\treturn WLAN_ERROR;","\t}","","\twlan_33v_flag = temp_flag;","","\treturn WLAN_OK;","}","#endif","","void wlan_setup_power(int on, int detect)","{","\tprintk(\"%s %s --enter\\n\", __func__, on ? \"on\" : \"down\");","","\tif (on) {","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\t/* GPIO_WLAN_33V_EN - On */","\t\tif (wlan_setup_ldo_33v(WLAN_33V_WIFI_FLAG, 1))","\t\t\treturn;","#endif","\t\tudelay(120);","","\t\t// GPIO_WLAN_RESET_N - On","\t\tif (wlan_set_gpio(GPIO_WLAN_RESET_N, 1))","\t\t\treturn;","","#ifdef WLAN_HOST_WAKE","\t\twlan_host_wake_init();","#endif /* WLAN_HOST_WAKE */","\t}","\telse {","#ifdef WLAN_HOST_WAKE","\t\twlan_host_wake_exit();","#endif /* WLAN_HOST_WAKE */","","\t\t// GPIO_WLAN_RESET_N - Off","\t\tif (wlan_set_gpio(GPIO_WLAN_RESET_N, 0))","\t\t\treturn;","","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\t/* GPIO_WLAN_33V_EN - Off */","\t\tif (wlan_setup_ldo_33v(WLAN_33V_WIFI_FLAG, 0))","\t\t\treturn;","#endif","\t}","","#ifndef ATH_POLLING","\tmdelay(100);","","\tif (detect) {","\t\t/* Detect card */","\t\tif (wlan_status_notify_cb)","\t\t\twlan_status_notify_cb(on, wlan_devid);","\t\telse","\t\t\tprintk(KERN_ERR \"WLAN: No notify available\\n\");","\t}","#endif /* ATH_POLLING */","}","EXPORT_SYMBOL(wlan_setup_power);","EXPORT_SYMBOL(board_hw_revision);","","","static int wlan_power_init(void)","{","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\twlan_33v_flag = 0;","#endif","","\t/* Set config - GPIO_WLAN_33V_EN */","\tif (gpio_tlmm_config(GPIO_CFG(GPIO_WLAN_33V_EN, 0,","\t\t\tGPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP,","\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE)) {","\t\tprintk(KERN_ERR \"%s: gpio_tlmm_config for %d failed\\n\",","\t\t\t\t__func__, GPIO_WLAN_33V_EN);","\t\treturn WLAN_ERROR;","\t}","","\treturn WLAN_OK;","}","","#if (defined(CONFIG_MMC_MSM_SDC1_SUPPORT)\\","\t|| defined(CONFIG_MMC_MSM_SDC2_SUPPORT)\\","\t|| defined(CONFIG_MMC_MSM_SDC3_SUPPORT)\\","\t|| defined(CONFIG_MMC_MSM_SDC4_SUPPORT))","","static unsigned long vreg_sts, gpio_sts;","static struct vreg *vreg_mmc;","static struct vreg *vreg_emmc;","","struct sdcc_vreg {","\tstruct vreg *vreg_data;","\tunsigned level;","};","","static struct sdcc_vreg sdcc_vreg_data[4];","","struct sdcc_gpio {","\tstruct msm_gpio *cfg_data;","\tuint32_t size;","\tstruct msm_gpio *sleep_cfg_data;","};","","/**"," * Due to insufficient drive strengths for SDC GPIO lines some old versioned"," * SD/MMC cards may cause data CRC errors. Hence, set optimal values"," * for SDC slots based on timing closure and marginality. SDC1 slot"," * require higher value since it should handle bad signal quality due"," * to size of T-flash adapters."," */","static struct msm_gpio sdc1_cfg_data[] = {","\t{GPIO_CFG(51, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_3\"},","\t{GPIO_CFG(52, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_2\"},","\t{GPIO_CFG(53, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_1\"},","\t{GPIO_CFG(54, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_0\"},","\t{GPIO_CFG(55, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_cmd\"},","\t{GPIO_CFG(56, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_clk\"},","};","","static struct msm_gpio sdc2_cfg_data[] = {","\t{GPIO_CFG(62, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\t\t\t\t\t\t\"sdc2_clk\"},","\t{GPIO_CFG(63, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_cmd\"},","\t{GPIO_CFG(64, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_3\"},","\t{GPIO_CFG(65, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_2\"},","\t{GPIO_CFG(66, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_1\"},","\t{GPIO_CFG(67, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_0\"},","};","","static struct msm_gpio sdc2_sleep_cfg_data[] = {","\t{GPIO_CFG(62, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_clk\"},","\t{GPIO_CFG(63, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_cmd\"},","\t{GPIO_CFG(64, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_3\"},","\t{GPIO_CFG(65, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_2\"},","\t{GPIO_CFG(66, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_1\"},","\t{GPIO_CFG(67, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_0\"},","};","static struct msm_gpio sdc3_cfg_data[] = {","\t{GPIO_CFG(88, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\t\t\t\t\t\t\"sdc3_clk\"},","\t{GPIO_CFG(89, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_cmd\"},","\t{GPIO_CFG(90, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_3\"},","\t{GPIO_CFG(91, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_2\"},","\t{GPIO_CFG(92, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_1\"},","\t{GPIO_CFG(93, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_0\"},","#ifdef CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT","\t{GPIO_CFG(19, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_7\"},","\t{GPIO_CFG(20, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_6\"},","\t{GPIO_CFG(21, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_5\"},","\t{GPIO_CFG(108, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_4\"},","#endif","};","","static struct msm_gpio sdc4_cfg_data[] = {","\t{GPIO_CFG(19, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_3\"},","\t{GPIO_CFG(20, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_2\"},","\t{GPIO_CFG(21, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_1\"},","\t{GPIO_CFG(106, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_cmd\"},","\t{GPIO_CFG(108, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_0\"},","\t{GPIO_CFG(109, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\t\t\t\t\t\t\"sdc4_clk\"},","};","","static struct sdcc_gpio sdcc_cfg_data[] = {","\t{","\t\t.cfg_data = sdc1_cfg_data,","\t\t.size = ARRAY_SIZE(sdc1_cfg_data),","\t},","\t{","\t\t.cfg_data = sdc2_cfg_data,","\t\t.size = ARRAY_SIZE(sdc2_cfg_data),","\t\t.sleep_cfg_data = sdc2_sleep_cfg_data,","\t},","\t{","\t},","\t{","\t\t.cfg_data = sdc4_cfg_data,","\t\t.size = ARRAY_SIZE(sdc4_cfg_data),","\t},","};","","static int msm_sdcc_setup_gpio(int dev_id, unsigned int enable)","{","\tint rc = 0;","\tstruct sdcc_gpio *curr;","","\tcurr = &sdcc_cfg_data[dev_id - 1];","\tif (!(test_bit(dev_id, &gpio_sts)^enable))","\t\treturn rc;","","\tif (enable) {","\t\tset_bit(dev_id, &gpio_sts);","\t\trc = msm_gpios_request_enable(curr->cfg_data, curr->size);","\t\tif (rc)","\t\t\tpr_err(\"%s: Failed to turn on GPIOs for slot %d\\n\",","\t\t\t\t\t__func__,  dev_id);","\t} else {","\t\tclear_bit(dev_id, &gpio_sts);","\t\tif (curr->sleep_cfg_data) {","\t\t\trc = msm_gpios_enable(curr->sleep_cfg_data, curr->size);","\t\t\tmsm_gpios_free(curr->sleep_cfg_data, curr->size);","\t\t\treturn rc;","\t\t}","\t\tmsm_gpios_disable_free(curr->cfg_data, curr->size);","\t}","\treturn rc;","}","","static int msm_sdcc_setup_vreg(int dev_id, unsigned int enable)","{","\tint rc = 0;","\tstruct sdcc_vreg *curr;","","\tcurr = &sdcc_vreg_data[dev_id - 1];","\tprintk(\"%s : %d : %d : level : %d\\n\", __func__, dev_id, enable, curr->level);","","\tif (!(test_bit(dev_id, &vreg_sts)^enable))","\t\treturn rc;","","\tif (enable) {","\t\tset_bit(dev_id, &vreg_sts);","\t\trc = vreg_set_level(curr->vreg_data, curr->level);","\t\tif (rc)","\t\t\tpr_err(\"%s: vreg_set_level() = %d\\n\", __func__, rc);","","\t\trc = vreg_enable(curr->vreg_data);","\t\tif (rc)","\t\t\tpr_err(\"%s: vreg_enable() = %d\\n\", __func__, rc);","\t} else {","\t\tclear_bit(dev_id, &vreg_sts);","\t\trc = vreg_disable(curr->vreg_data);","\t\tif (rc)","\t\t\tpr_err(\"%s: vreg_disable() = %d\\n\", __func__, rc);","\t}","\treturn rc;","}","","static uint32_t msm_sdcc_setup_power(struct device *dv, unsigned int vdd)","{","\tint rc = 0;","\tstruct platform_device *pdev;","","\tpdev = container_of(dv, struct platform_device, dev);","","\trc = msm_sdcc_setup_gpio(pdev->id, !!vdd);","\tif (rc)","\t\tgoto out;","","\trc = msm_sdcc_setup_vreg(pdev->id, !!vdd);","out:","\treturn rc;","}","","#define GPIO_SDC1_HW_DET 94","","#if defined(CONFIG_MMC_MSM_SDC1_SUPPORT) \\","\t&& defined(CONFIG_MMC_MSM_CARD_HW_DETECTION)","static unsigned int msm7x2xa_sdcc_slot_status(struct device *dev)","{","\tint status;","","\tprintk(\"%s entered\\n\", __func__);","","\tstatus = gpio_tlmm_config(GPIO_CFG(GPIO_SDC1_HW_DET, 2, GPIO_CFG_INPUT,","\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_8MA), GPIO_CFG_ENABLE);","\tif (status)","\t\tpr_err(\"%s:Failed to configure tlmm for GPIO %d\\n\", __func__,","\t\t\t\tGPIO_SDC1_HW_DET);","","\tstatus = gpio_request(GPIO_SDC1_HW_DET, \"SD_HW_Detect\");","\tif (status) {","\t\tpr_err(\"%s:Failed to request GPIO %d\\n\", __func__,","\t\t\t\tGPIO_SDC1_HW_DET);","\t} else {","\t\tstatus = gpio_direction_input(GPIO_SDC1_HW_DET);","\t\tif (!status)","\t\t\tstatus = gpio_get_value(GPIO_SDC1_HW_DET);","\t\tgpio_free(GPIO_SDC1_HW_DET);","\t}","","\tstatus = status?0:1 ; //PMMC","\tprintk(\"<=PMMC=> %s : status : %d \\n\", __func__, status);","\treturn status;","}","#endif","","#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT","static struct mmc_platform_data sdc1_plat_data = {","\t.ocr_mask\t= MMC_VDD_28_29,","\t.translate_vdd  = msm_sdcc_setup_power,","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000,","#ifdef CONFIG_MMC_MSM_CARD_HW_DETECTION","\t.status      = msm7x2xa_sdcc_slot_status,","\t.status_irq  = MSM_GPIO_TO_INT(GPIO_SDC1_HW_DET),","\t.irq_flags   = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,","#endif","};","#endif","","#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT","static struct mmc_platform_data sdc2_plat_data = {","\t/*","\t * SDC2 supports only 1.8V, claim for 2.85V range is just","\t * for allowing buggy cards who advertise 2.8V even though","\t * they can operate at 1.8V supply.","\t */","\t.ocr_mask\t= MMC_VDD_28_29 | MMC_VDD_165_195,","\t.translate_vdd  = msm_sdcc_setup_power,","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","#ifndef ATH_POLLING","\t.status = wlan_status,","\t.register_status_notify = register_wlan_status_notify,","#endif /* ATH_POLLING */","#ifdef CONFIG_MMC_MSM_SDIO_SUPPORT","\t.sdiowakeup_irq = MSM_GPIO_TO_INT(66),","#endif /* CONFIG_MMC_MSM_SDIO_SUPPORT */","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000, //24576000, ///*144000,//*/","#ifdef CONFIG_MMC_MSM_SDC2_DUMMY52_REQUIRED","\t.dummy52_required = 1,","#endif","};","#endif","","#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT","static struct mmc_platform_data sdc3_plat_data = {","\t.ocr_mask\t= MMC_VDD_28_29,","\t.translate_vdd  = msm_sdcc_setup_power,","#ifdef CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT","\t.mmc_bus_width  = MMC_CAP_8_BIT_DATA,","#else","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","#endif","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000,","\t.nonremovable\t= 1,","};","#endif","","#if (defined(CONFIG_MMC_MSM_SDC4_SUPPORT)\\","\t\t&& !defined(CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT))","static struct mmc_platform_data sdc4_plat_data = {","\t.ocr_mask\t= MMC_VDD_28_29,","\t.translate_vdd  = msm_sdcc_setup_power,","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000,","};","#endif","#endif","","#ifdef CONFIG_SERIAL_MSM_HS","static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {","\t.inject_rx_on_wakeup\t= 1,","\t.rx_to_inject\t\t= 0xFD,","};","#endif","static struct msm_pm_platform_data msm7x27a_pm_data[MSM_PM_SLEEP_MODE_NR] = {","\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 1,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 16000,","\t\t\t\t\t.residency = 20000,","\t},","\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE_NO_XO_SHUTDOWN] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 1,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 12000,","\t\t\t\t\t.residency = 20000,","\t},","\t[MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 0,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 2000,","\t\t\t\t\t.residency = 0,","\t},","\t[MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 1,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 2,","\t\t\t\t\t.residency = 0,","\t},","};","","u32 msm7627a_power_collapse_latency(enum msm_pm_sleep_mode mode)","{","\tswitch (mode) {","\tcase MSM_PM_SLEEP_MODE_POWER_COLLAPSE:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE].latency;","\tcase MSM_PM_SLEEP_MODE_POWER_COLLAPSE_NO_XO_SHUTDOWN:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE_NO_XO_SHUTDOWN].latency;","\tcase MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT].latency;","\tcase MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT].latency;","\tdefault:","\t\treturn 0;","\t}","}","","static struct msm_pm_boot_platform_data msm_pm_boot_pdata __initdata = {","\t.mode = MSM_PM_BOOT_CONFIG_RESET_VECTOR_PHYS,","\t.p_addr = 0,","};","","static struct android_pmem_platform_data android_pmem_adsp_pdata = {","\t.name = \"pmem_adsp\",","\t.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,","\t.cached = 1,","\t.memory_type = MEMTYPE_EBI1,","};","","static struct platform_device android_pmem_adsp_device = {","\t.name = \"android_pmem\",","\t.id = 1,","\t.dev = { .platform_data = &android_pmem_adsp_pdata },","};","","static unsigned pmem_mdp_size = MSM_PMEM_MDP_SIZE;","static int __init pmem_mdp_size_setup(char *p)","{","\tpmem_mdp_size = memparse(p, NULL);","\treturn 0;","}","","early_param(\"pmem_mdp_size\", pmem_mdp_size_setup);","","static unsigned pmem_adsp_size = MSM_PMEM_ADSP_SIZE;","static int __init pmem_adsp_size_setup(char *p)","{","\tpmem_adsp_size = memparse(p, NULL);","\treturn 0;","}","","early_param(\"pmem_adsp_size\", pmem_adsp_size_setup);","","static unsigned fb_size = MSM_FB_SIZE;","static int __init fb_size_setup(char *p)","{","\tfb_size = memparse(p, NULL);","\treturn 0;","}","","early_param(\"fb_size\", fb_size_setup);","","static const char * const msm_fb_lcdc_vreg[] = {","\t\t\"gp2\",","\t\t\"msme1\",","};","","static const int msm_fb_lcdc_vreg_mV[] = {","\t2850,","\t1800,","};","","#define LCDC_CONFIG_PROC          21","#define LCDC_UN_CONFIG_PROC       22","#define LCDC_API_PROG             0x30000066","#define LCDC_API_VERS             0x00010001","","#define\tGPIO_SPI_CLK\t\t30","#define\tGPIO_SPI_CS\t\t26","#define\tGPIO_SPI_SDI\t\t57","#define GPIO_SPI_SDO\t23","#define\tGPIO_LCD_RESET_N\t22","#define\tGPIO_LCD_DETECT\t\t38","","struct vreg *lcdc_vreg[ARRAY_SIZE(msm_fb_lcdc_vreg)];","","static int lcdc_gpio_num[] = {","\tGPIO_SPI_CLK,","\tGPIO_SPI_CS,","\tGPIO_SPI_SDI,","\tGPIO_SPI_SDO,","\tGPIO_LCD_RESET_N,","\tGPIO_LCD_DETECT,","};","","static void lcdc_trebon_gpio_init(void)","{","\tint rc;","","\tif (gpio_request(GPIO_SPI_CLK, \"spi_clk\")) {","\t\tpr_err(\"failed to request gpio spi_clk\\n\");","\t}","\tif (gpio_request(GPIO_SPI_CS, \"spi_cs\")) {","\t\tpr_err(\"failed to request gpio spi_cs\\n\");","\t}","\tif (gpio_request(GPIO_SPI_SDI, \"spi_mosi\")) {","\t\tpr_err(\"failed to request gpio spi_sdi\\n\");","\t}","\tif (gpio_request(GPIO_LCD_RESET_N, \"gpio_lcd_reset_n\")) {","\t\tpr_err(\"failed to request gpio lcd_reset_n\\n\");","\t}","","\t/* LCD Detect Irq */","\trc = gpio_tlmm_config(GPIO_CFG(GPIO_LCD_DETECT, 0,","\t\t\t\tGPIO_CFG_INPUT, GPIO_CFG_NO_PULL,","\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"%s: gpio_tlmm_config for %d failed\\n\",","\t\t\t__func__, GPIO_LCD_DETECT);","\t\t//goto err;","\t}","","\trc = gpio_request(GPIO_LCD_DETECT, \"gpio_lcd_detect\");","\tif (rc) {","\t\tpr_err(\"%s: unable to request gpio %d\\n\",","\t\t\t__func__, GPIO_LCD_DETECT);","\t\t//goto err;","\t}","","\trc = gpio_direction_input(GPIO_LCD_DETECT);","\tif (rc < 0) {","\t\tpr_err(\"%s: unable to set the direction of gpio %d\\n\",","\t\t\t__func__, GPIO_LCD_DETECT);","\t\t//goto err;","\t}","","\treturn;","}","","static uint32_t lcdc_gpio_table[] = {","\tGPIO_CFG(GPIO_SPI_CLK, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\tGPIO_CFG(GPIO_SPI_CS, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\tGPIO_CFG(GPIO_SPI_SDI, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\tGPIO_CFG(GPIO_LCD_RESET_N,  0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","","static void config_lcdc_gpio_table(uint32_t *table, int len, unsigned enable)","{","\tint n, rc;","","\tfor (n = 0; n < len; n++) {","\t\trc = gpio_tlmm_config(table[n],","\t\t\tenable ? GPIO_CFG_ENABLE : GPIO_CFG_DISABLE);","\t\tif (rc) {","\t\t\tprintk(KERN_ERR \"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t\t__func__, table[n], rc);","\t\t\tbreak;","\t\t}","\t}","}","static int msm_fb_lcdc_power_save(int on)","{","    return 0;","}","","static struct lcdc_platform_data lcdc_pdata = {","\t.lcdc_gpio_config = NULL,","\t.lcdc_power_save   = msm_fb_lcdc_power_save,","};","","static struct resource lcdc_trebon_resources[] = {","\t{","\t\t.name = \"lcd_breakdown_det\",","\t\t.start = MSM_GPIO_TO_INT(GPIO_LCD_DETECT),","\t\t.end = MSM_GPIO_TO_INT(GPIO_LCD_DETECT),","\t\t.flags  = IORESOURCE_IRQ,","\t}","};","","static void lcdc_trebon_config_gpios(int enable)","{","\tconfig_lcdc_gpio_table(lcdc_gpio_table,","\t\tARRAY_SIZE(lcdc_gpio_table), enable);","}","","static struct msm_panel_common_pdata lcdc_trebon_panel_data = {","\t.panel_config_gpio = lcdc_trebon_config_gpios,","\t.gpio_num\t  = lcdc_gpio_num,","","};","","static struct platform_device lcdc_trebon_panel_device = {","#if defined(CONFIG_FB_MSM_LCDC_TREBON_HVGA)","\t.name   = \"lcdc_trebon_hvga\",","\t.num_resources  = ARRAY_SIZE(lcdc_trebon_resources),","\t.resource       = lcdc_trebon_resources,","#else","\t.name   = \"lcdc_s6d16a0x_hvga\",","#endif","\t.id     = 0,","\t.dev    = {","\t\t.platform_data = &lcdc_trebon_panel_data,","\t}","};","","#ifdef CONFIG_TOUCHSCREEN_ZINITIX_TREBON","static void tsp_power_on(void)","{","\tint rc = 0;","\tprintk(\"[TSP] %s start \\n\", __func__);","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\trc = gpio_request(41, \"touch_en\");","#else","\trc = gpio_request(78, \"touch_en\");","","#endif","\tif (rc < 0) {","\t\tpr_err(\"failed to request touch_en\\n\");","\t}","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\tgpio_tlmm_config(GPIO_CFG(41, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_direction_output(41, 1);","#else","\tgpio_tlmm_config(GPIO_CFG(78, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_direction_output(78, 1);","#endif","}","#endif","","struct class *sec_class;","EXPORT_SYMBOL(sec_class);","","static void samsung_sys_class_init(void)","{","\tpr_info(\"samsung sys class init.\\n\");","","\tsec_class = class_create(THIS_MODULE, \"sec\");","\tif (IS_ERR(sec_class))","\t\tpr_err(\"Failed to create class(sec) !\\n\");","","}","","static struct resource msm_fb_resources[] = {","\t{","\t\t.flags  = IORESOURCE_DMA,","\t}","};","","/*","* The function of \"update_panel_name()\" is working for support","* different lcd panel more than two. The operation of this function","* is that get the panel name from command line that is pass on from","* bootloader and update lcd id.","*/","static int __init update_panel_name(char *panel_name)","{","\tint i;","\tchar *src = panel_name;","\tchar panel[2][4] = {\"SMD\", \"AUO\"};","\tint panel_id[2] = {1, 2};","\tstatic int lcd_id = -1;","","\tif (!strncmp(src, \"GET\", 3)) {","\t\tprintk(KERN_INFO, \"%s : Lcd name is %s\\n\",","\t\t\t\t__func__, panel[lcd_id - 1]);","\t\treturn lcd_id;","\t} else {","\t\tfor (i = 0; i < sizeof(panel) / sizeof(panel[0]); i++) {","\t\t\tif (!strncmp(src, panel[i], sizeof(panel[i])))","\t\t\t\tlcd_id = panel_id[i];","\t\t}","","\t\tif (lcd_id == -1) {","\t\t\tprintk(KERN_INFO, \"%s : Fail to get lcd panel name\"","\t\t\t\t\" from bootloader\\n\", __func__);","\t\t\tlcd_id = panel_id[1];","\t\t} else {","\t\t\tprintk(KERN_INFO, \"%s : Success to get\"","\t\t\t\t\"lcd panel name(%s) from bootloader\\n\",","\t\t\t\t__func__, panel[lcd_id - 1]);","\t\t}","\t}","","\treturn 1;","}","__setup(\"panel_name=\", update_panel_name);","","/*","* The function of \"msm_fb_detect_panel()\" is working for search","* one panel among panels using the string(variable of panel).","*/","static int msm_fb_detect_panel(const char *name)","{","\tint ret = -EPERM;","\tchar panel[2][21] = {\"lcdc_trebon_smd_hvga\", \"lcdc_trebon_auo_hvga\"};","\tint lcd_id = -1;","\tlcd_id = update_panel_name(\"GET\");","\tprintk(KERN_INFO \"LCD %s selected\\n\", panel[lcd_id - 1]);","","#if defined(CONFIG_FB_MSM_LCDC_S6D16A0X_HVGA)","\t\tif (!strncmp(name, \"lcdc_s6d16a0x_hvga\"), 19)","\t\t\tret = 0;","\t\telse","\t\t\tret = -ENODEV;","#elif defined(CONFIG_FB_MSM_LCDC_TREBON_HVGA)","\t\tif (!strncmp(name, panel[lcd_id - 1],","\t\t\t\t\tsizeof(panel[lcd_id - 1])))","\t\t\tret = 0;","\t\telse","\t\t\tret = -ENODEV;","#else","#endif","\treturn ret;","}","","static struct msm_fb_platform_data msm_fb_pdata = {","\t.detect_client = msm_fb_detect_panel,","};","","static struct platform_device msm_fb_device = {","\t.name   = \"msm_fb\",","\t.id     = 0,","\t.num_resources  = ARRAY_SIZE(msm_fb_resources),","\t.resource       = msm_fb_resources,","\t.dev    = {","\t\t.platform_data = &msm_fb_pdata,","\t}","};","","#ifdef CONFIG_FB_MSM_MIPI_DSI","static int mipi_renesas_set_bl(int level)","{","\tint ret;","","\tret = pmapp_disp_backlight_set_brightness(level);","","\tif (ret)","\t\tpr_err(\"%s: can't set lcd backlight!\\n\", __func__);","","\treturn ret;","}","","static struct msm_panel_common_pdata mipi_renesas_pdata = {","\t.pmic_backlight = mipi_renesas_set_bl,","};","","","static struct platform_device mipi_dsi_renesas_panel_device = {","\t.name = \"mipi_renesas\",","\t.id = 0,","\t.dev    = {","\t\t.platform_data = &mipi_renesas_pdata,","\t}","};","#endif","","","static void __init msm7x27a_init_mmc(void)","{","        vreg_emmc = vreg_get(NULL,\"msme1\");","        if (IS_ERR(vreg_emmc)) {","                pr_err(\"%s: vreg get failed (%ld)\\n\",","                                __func__, PTR_ERR(vreg_emmc));","                return;","        }","","        vreg_mmc = vreg_get(NULL,\"mmc\");","        if (IS_ERR(vreg_mmc)) {","                pr_err(\"%s: vreg get failed (%ld)\\n\",","                                __func__, PTR_ERR(vreg_mmc));","                return;","        }","","\t/* eMMC slot */","#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT","\tsdcc_vreg_data[2].vreg_data = vreg_emmc;","\tsdcc_vreg_data[2].level = 1800;","\tmsm_add_sdcc(3, &sdc3_plat_data);","#endif","\t/* Micro-SD slot */","#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT","\tsdcc_vreg_data[0].vreg_data = vreg_mmc;","\tsdcc_vreg_data[0].level = 2850;","\tmsm_add_sdcc(1, &sdc1_plat_data);","#endif","\t/* SDIO WLAN slot */","#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT","\tsdcc_vreg_data[1].vreg_data = vreg_emmc;","\tsdcc_vreg_data[1].level = 1800; /* 2850 */","\tmsm_add_sdcc(2, &sdc2_plat_data);","#endif","\t/* Not Used */","#if (defined(CONFIG_MMC_MSM_SDC4_SUPPORT)\\","\t\t&& !defined(CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT))","\tsdcc_vreg_data[3].vreg_data = vreg_mmc;","\tsdcc_vreg_data[3].level = 2850;","\tmsm_add_sdcc(4, &sdc4_plat_data);","#endif","}","","#define SND(desc, num) { .name = #desc, .id = num }","static struct snd_endpoint snd_endpoints_list[] = {","\tSND(HANDSET, 0),","\tSND(MONO_HEADSET, 2),","\tSND(HEADSET, 3),","\tSND(SPEAKER, 6),","\tSND(TTY_HEADSET, 8),","\tSND(TTY_VCO, 9),","\tSND(TTY_HCO, 10),","\tSND(BT, 12),","\tSND(IN_S_SADC_OUT_HANDSET, 16),","\tSND(VOICE_RECOGNITION, 24),","\tSND(FM_DIGITAL_STEREO_HEADSET, 26),","\tSND(FM_DIGITAL_SPEAKER_PHONE, 27),","\tSND(FM_DIGITAL_BT_A2DP_HEADSET, 28),","\tSND(FM_STEREO_HEADSET, 29),","\tSND(FM_SPEAKER_PHONE, 30),","\tSND(STEREO_HEADSET_AND_SPEAKER, 31),","\tSND(HEADSET_AND_SPEAKER, 32),","\tSND(STEREO_HEADSET_3POLE, 34),","\tSND(MP3_SPEAKER_PHONE, 35),","\tSND(MP3_STEREO_HEADSET, 36),","\tSND(BT_NSEC_OFF, 37),","\tSND(HANDSET_VOIP, 38),","\tSND(STEREO_HEADSET_VOIP, 39),","\tSND(SPEAKER_VOIP, 40),","\tSND(BT_VOIP, 41),","\tSND(HANDSET_VOIP2, 42),","\tSND(STEREO_HEADSET_VOIP2, 43),","\tSND(SPEAKER_VOIP2, 44),","\tSND(BT_VOIP2, 45),","\tSND(VOICE_RECORDER_HPH, 46),","\tSND(VOICE_RECORDER_SPK, 47),","\tSND(FM_ANALOG_STEREO_HEADSET, 50),","\tSND(FM_ANALOG_STEREO_HEADSET_CODEC, 51),","\tSND(CURRENT, 0x7FFFFFFE),","};","#undef SND","","static struct msm_snd_endpoints msm_device_snd_endpoints = {","\t.endpoints = snd_endpoints_list,","\t.num = sizeof(snd_endpoints_list) / sizeof(struct snd_endpoint)","};","","static struct platform_device msm_device_snd = {","\t.name = \"msm_snd\",","\t.id = -1,","\t.dev    = {","\t\t.platform_data = &msm_device_snd_endpoints","\t},","};","","#define DEC0_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC1_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC2_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC3_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC4_FORMAT (1<<MSM_ADSP_CODEC_MIDI)","","static unsigned int dec_concurrency_table[] = {","\t/* Audio LP */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DMA)), 0,","\t0, 0, 0,","","\t/* Concurrency 1 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t /* Concurrency 2 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 3 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 4 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 5 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 6 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|","\t\t\t(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t0, 0, 0, 0,","","\t/* Concurrency 7 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","};","","#define DEC_INFO(name, queueid, decid, nr_codec) { .module_name = name, \\","\t.module_queueid = queueid, .module_decid = decid, \\","\t.nr_codec_support = nr_codec}","","static struct msm_adspdec_info dec_info_list[] = {","\tDEC_INFO(\"AUDPLAY0TASK\", 13, 0, 11), /* AudPlay0BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY1TASK\", 14, 1, 11),  /* AudPlay1BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY2TASK\", 15, 2, 11),  /* AudPlay2BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY3TASK\", 16, 3, 11),  /* AudPlay3BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY4TASK\", 17, 4, 1),  /* AudPlay4BitStreamCtrlQueue */","};","","static struct msm_adspdec_database msm_device_adspdec_database = {","\t.num_dec = ARRAY_SIZE(dec_info_list),","\t.num_concurrency_support = (ARRAY_SIZE(dec_concurrency_table) / \\","\t\t\t\t\tARRAY_SIZE(dec_info_list)),","\t.dec_concurrency_table = dec_concurrency_table,","\t.dec_info_list = dec_info_list,","};","","static struct platform_device msm_device_adspdec = {","\t.name = \"msm_adspdec\",","\t.id = -1,","\t.dev    = {","\t\t.platform_data = &msm_device_adspdec_database","\t},","};","","static struct android_pmem_platform_data android_pmem_audio_pdata = {","\t.name = \"pmem_audio\",","\t.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,","\t.cached = 0,","\t.memory_type = MEMTYPE_EBI1,","};","","static struct platform_device android_pmem_audio_device = {","\t.name = \"android_pmem\",","\t.id = 2,","\t.dev = { .platform_data = &android_pmem_audio_pdata },","};","","static struct android_pmem_platform_data android_pmem_pdata = {","\t.name = \"pmem\",","\t.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,","\t.cached = 1,","\t.memory_type = MEMTYPE_EBI1,","};","static struct platform_device android_pmem_device = {","\t.name = \"android_pmem\",","\t.id = 0,","\t.dev = { .platform_data = &android_pmem_pdata },","};","","static struct smsc911x_platform_config smsc911x_config = {","\t.irq_polarity\t= SMSC911X_IRQ_POLARITY_ACTIVE_HIGH,","\t.irq_type\t= SMSC911X_IRQ_TYPE_PUSH_PULL,","\t.flags\t\t= SMSC911X_USE_16BIT,","};","","static struct resource smsc911x_resources[] = {","\t[0] = {","\t\t.start\t= 0x90000000,","\t\t.end\t= 0x90007fff,","\t\t.flags\t= IORESOURCE_MEM,","\t},","\t[1] = {","\t\t.start\t= MSM_GPIO_TO_INT(48),","\t\t.end\t= MSM_GPIO_TO_INT(48),","\t\t.flags\t= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,","\t},","};","","static struct platform_device smsc911x_device = {","\t.name\t\t= \"smsc911x\",","\t.id\t\t= 0,","\t.num_resources\t= ARRAY_SIZE(smsc911x_resources),","\t.resource\t= smsc911x_resources,","\t.dev\t\t= {","\t\t.platform_data\t= &smsc911x_config,","\t},","};","","static struct msm_gpio smsc911x_gpios[] = {","\t{ GPIO_CFG(48, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_6MA),","\t\t\t\t\t\t\t \"smsc911x_irq\"  },","\t{ GPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_6MA),","\t\t\t\t\t\t\t \"eth_fifo_sel\" },","};","","#define ETH_FIFO_SEL_GPIO\t49","static void msm7x27a_cfg_smsc911x(void)","{","\tint res;","","\tres = msm_gpios_request_enable(smsc911x_gpios,","\t\t\t\t ARRAY_SIZE(smsc911x_gpios));","\tif (res) {","\t\tpr_err(\"%s: unable to enable gpios for SMSC911x\\n\", __func__);","\t\treturn;","\t}","","\t/* ETH_FIFO_SEL */","\tres = gpio_direction_output(ETH_FIFO_SEL_GPIO, 0);","\tif (res) {","\t\tpr_err(\"%s: unable to get direction for gpio %d\\n\", __func__,","\t\t\t\t\t\t\t ETH_FIFO_SEL_GPIO);","\t\tmsm_gpios_disable_free(smsc911x_gpios,","\t\t\t\t\t\t ARRAY_SIZE(smsc911x_gpios));","\t\treturn;","\t}","\tgpio_set_value(ETH_FIFO_SEL_GPIO, 0);","}","","#ifdef CONFIG_MSM_CAMERA","static uint32_t camera_off_gpio_table[] = {","\tGPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","};","","static uint32_t camera_on_gpio_table[] = {","","#ifdef CONFIG_MACH_JENA","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\tGPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(18, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(58, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(98, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(84, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(107, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","#else","\tGPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(93, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(92, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(89, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(84, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(79, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","#endif","#endif","","};","","#ifdef CONFIG_MSM_CAMERA_FLASH","static struct msm_camera_sensor_flash_src msm_flash_src = {","\t.flash_sr_type = MSM_CAMERA_FLASH_SRC_CURRENT_DRIVER,","};","#endif","","static struct vreg *vreg_gp1;","static struct vreg *vreg_gp2;","static struct vreg *vreg_gp3;","static void msm_camera_vreg_config(int vreg_en)","{","}","","static int config_gpio_table(uint32_t *table, int len)","{","\tint rc = 0, i = 0;","","\tfor (i = 0; i < len; i++) {","\t\trc = gpio_tlmm_config(table[i], GPIO_CFG_ENABLE);","\t\tif (rc) {","\t\t\tpr_err(\"%s not able to get gpio\\n\", __func__);","\t\t\tfor (i--; i >= 0; i--)","\t\t\t\tgpio_tlmm_config(camera_off_gpio_table[i],","\t\t\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\tbreak;","\t\t}","\t}","\treturn rc;","}","","static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1_data;","static struct msm_camera_sensor_info msm_camera_sensor_ov9726_data;","static int config_camera_on_gpios_rear(void)","{","\tint rc = 0;","","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(1);","","\trc = config_gpio_table(camera_on_gpio_table,","\t\t\tARRAY_SIZE(camera_on_gpio_table));","\tif (rc < 0) {","\t\tpr_err(\"%s: CAMSENSOR gpio table request\"","\t\t\"failed\\n\", __func__);","\t\treturn rc;","\t}","","\treturn rc;","}","","static void config_camera_off_gpios_rear(void)","{","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(0);","","\tconfig_gpio_table(camera_off_gpio_table,","\t\t\tARRAY_SIZE(camera_off_gpio_table));","}","","static int config_camera_on_gpios_front(void)","{","\tint rc = 0;","","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(1);","","\trc = config_gpio_table(camera_on_gpio_table,","\t\t\tARRAY_SIZE(camera_on_gpio_table));","\tif (rc < 0) {","\t\tpr_err(\"%s: CAMSENSOR gpio table request\"","\t\t\t\"failed\\n\", __func__);","\t\treturn rc;","\t}","","\treturn rc;","}","","static void config_camera_off_gpios_front(void)","{","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(0);","","\tconfig_gpio_table(camera_off_gpio_table,","\t\t\tARRAY_SIZE(camera_off_gpio_table));","}","","struct msm_camera_device_platform_data msm_camera_device_data_rear = {","\t.camera_gpio_on  = config_camera_on_gpios_rear,","\t.camera_gpio_off = config_camera_off_gpios_rear,","\t.ioext.csiphy = 0xA1000000,","\t.ioext.csisz  = 0x00100000,","\t.ioext.csiirq = INT_CSI_IRQ_1,","\t.ioclk.mclk_clk_rate = 24000000,","\t.ioclk.vfe_clk_rate  = 192000000,","\t.ioext.appphy = MSM_CLK_CTL_PHYS,","\t.ioext.appsz  = MSM_CLK_CTL_SIZE,","};","","struct msm_camera_device_platform_data msm_camera_device_data_front = {","\t.camera_gpio_on  = config_camera_on_gpios_front,","\t.camera_gpio_off = config_camera_off_gpios_front,","\t.ioext.csiphy = 0xA0F00000,","\t.ioext.csisz  = 0x00100000,","\t.ioext.csiirq = INT_CSI_IRQ_0,","\t.ioclk.mclk_clk_rate = 24000000,","\t.ioclk.vfe_clk_rate  = 192000000,","\t.ioext.appphy = MSM_CLK_CTL_PHYS,","\t.ioext.appsz  = MSM_CLK_CTL_SIZE,","};","","#ifdef CONFIG_S5K4E1","static struct msm_camera_sensor_platform_info s5k4e1_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_s5k4e1 = {","\t.flash_type             = MSM_CAMERA_FLASH_LED,","\t.flash_src              = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1_data = {","\t.sensor_name    = \"s5k4e1\",","\t.sensor_reset_enable = 1,","\t.sensor_reset   = GPIO_CAM_GP_CAMIF_RESET_N,","\t.sensor_pwd             = 85,","\t.vcm_pwd                = GPIO_CAM_GP_CAM_PWDN,","\t.vcm_enable             = 1,","\t.pdata                  = &msm_camera_device_data_rear,","\t.flash_data             = &flash_s5k4e1,","\t.sensor_platform_info   = &s5k4e1_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_s5k4e1 = {","\t.name   = \"msm_camera_s5k4e1\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_s5k4e1_data,","\t},","};","#endif","","#ifdef CONFIG_IMX072","static struct msm_camera_sensor_platform_info imx072_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_imx072 = {","\t.flash_type             = MSM_CAMERA_FLASH_LED,","\t.flash_src              = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_imx072_data = {","\t.sensor_name    = \"imx072\",","\t.sensor_reset_enable = 1,","\t.sensor_reset   = 85, /* TODO 106,*/","\t.sensor_pwd             = 123,","\t.vcm_pwd                = GPIO_CAM_GP_CAM_PWDN,","\t.vcm_enable             = 1,","\t.pdata                  = &msm_camera_device_data_rear,","\t.flash_data             = &flash_imx072,","\t.sensor_platform_info = &imx072_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_imx072 = {","\t.name   = \"msm_camera_imx072\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_imx072_data,","\t},","};","#endif","","#ifdef CONFIG_WEBCAM_OV9726","static struct msm_camera_sensor_platform_info ov9726_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_ov9726 = {","\t.flash_type             = MSM_CAMERA_FLASH_NONE,","\t.flash_src              = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_ov9726_data = {","\t.sensor_name    = \"ov9726\",","\t.sensor_reset_enable = 0,","\t.sensor_reset   = GPIO_CAM_GP_CAM1MP_XCLR,","\t.sensor_pwd             = 85,","\t.vcm_pwd                = 1,","\t.vcm_enable             = 0,","\t.pdata                  = &msm_camera_device_data_front,","\t.flash_data             = &flash_ov9726,","\t.sensor_platform_info   = &ov9726_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_ov9726 = {","\t.name   = \"msm_camera_ov9726\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_ov9726_data,","\t},","};","#endif","","#ifdef CONFIG_S5K4ECGX","static struct msm_camera_sensor_platform_info s5k4ecgx_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_s5k4ecgx = {","\t.flash_type             = MSM_CAMERA_FLASH_LED,","};","","static struct msm_camera_sensor_info msm_camera_sensor_s5k4ecgx_data = {","\t.sensor_name    = \"s5k4ecgx\",","\t.sensor_reset_enable = 0,","\t.vcm_enable             = 0,","\t.pdata                  = &msm_camera_device_data_rear,","\t.flash_data             = &flash_s5k4ecgx,","\t.sensor_platform_info   = &s5k4ecgx_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_s5k4ecgx = {","\t.name   = \"msm_camera_s5k4ecgx\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_s5k4ecgx_data,","\t},","};","#endif","","#ifdef CONFIG_MT9V113","static struct msm_camera_sensor_platform_info mt9v113_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_mt9v113 = {","\t.flash_type             = MSM_CAMERA_FLASH_NONE,","};","","static struct msm_camera_sensor_info msm_camera_sensor_mt9v113_data = {","\t.sensor_name    = \"mt9v113\",","\t.sensor_reset_enable = 0,","\t.vcm_enable             = 0,","\t.pdata                  = &msm_camera_device_data_front,","\t.flash_data             = &flash_mt9v113,","\t.sensor_platform_info   = &mt9v113_sensor_7627a_info,","\t.csi_if                 = 1 // 0: Parallel interface , 1: MIPI interface","};","","static struct platform_device msm_camera_sensor_mt9v113 = {","\t.name   = \"msm_camera_mt9v113\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_mt9v113_data,","\t},","};","#endif","#ifdef CONFIG_MT9E013","static struct msm_camera_sensor_platform_info mt9e013_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_mt9e013 = {","\t.flash_type = MSM_CAMERA_FLASH_LED,","\t.flash_src  = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_mt9e013_data = {","\t.sensor_name    = \"mt9e013\",","\t.sensor_reset   = 0,","\t.sensor_reset_enable = 1,","\t.sensor_pwd     = 85,","\t.vcm_pwd        = 1,","\t.vcm_enable     = 0,","\t.pdata          = &msm_camera_device_data_rear,","\t.flash_data     = &flash_mt9e013,","\t.sensor_platform_info   = &mt9e013_sensor_7627a_info,","\t.csi_if         = 1","};","","static struct platform_device msm_camera_sensor_mt9e013 = {","\t.name      = \"msm_camera_mt9e013\",","\t.dev       = {","\t\t.platform_data = &msm_camera_sensor_mt9e013_data,","\t},","};","#endif","","static struct i2c_board_info i2c_camera_devices[] = {","\t#ifdef CONFIG_S5K4E1","\t{","\t\tI2C_BOARD_INFO(\"s5k4e1\", 0x36),","\t},","\t{","\t\tI2C_BOARD_INFO(\"s5k4e1_af\", 0x8c >> 1),","\t},","\t#endif","\t#ifdef CONFIG_WEBCAM_OV9726","\t{","\t\tI2C_BOARD_INFO(\"ov9726\", 0x10),","\t},","\t#endif","\t#ifdef CONFIG_MT9V113","\t{","\t\tI2C_BOARD_INFO(\"mt9v113\", 0x7A >> 1),","\t},","\t#endif","    #ifdef CONFIG_S5K4ECGX","\t{","\t\tI2C_BOARD_INFO(\"s5k4ecgx\", 0xAC >> 1),","\t},","    #endif","\t#ifdef CONFIG_IMX072","\t{","\t\tI2C_BOARD_INFO(\"imx072\", 0x34),","\t},","\t#endif","\t#ifdef CONFIG_MT9E013","\t{","\t\tI2C_BOARD_INFO(\"mt9e013\", 0x6C >> 2),","\t},","\t#endif","\t{","\t\tI2C_BOARD_INFO(\"sc628a\", 0x37),","\t},","};","#endif","","#if defined(CONFIG_SERIAL_MSM_HSL_CONSOLE) \\","\t\t&& defined(CONFIG_MSM_SHARED_GPIO_FOR_UART2DM)","static struct msm_gpio uart2dm_gpios[] = {","\t{GPIO_CFG(19, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_rfr_n\" },","\t{GPIO_CFG(20, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_cts_n\" },","\t{GPIO_CFG(21, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_rx\"    },","\t{GPIO_CFG(108, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_tx\"    },","};","","static void msm7x27a_cfg_uart2dm_serial(void)","{","\tint ret;","\tret = msm_gpios_request_enable(uart2dm_gpios,","\t\t\t\t\tARRAY_SIZE(uart2dm_gpios));","\tif (ret)","\t\tpr_err(\"%s: unable to enable gpios for uart2dm\\n\", __func__);","}","#else","static void msm7x27a_cfg_uart2dm_serial(void) { }","#endif","","static struct platform_device *rumi_sim_devices[] __initdata = {","\t&msm_device_dmov,","\t&msm_device_smd,","\t&smc91x_device,","\t&msm_device_uart1,","\t&msm_device_nand,","\t&msm_device_uart_dm1,","\t&msm_gsbi0_qup_i2c_device,","\t&msm_gsbi1_qup_i2c_device","};","","static struct platform_device *surf_ffa_devices[] __initdata = {","\t&msm_device_dmov,","\t&msm_device_smd,","\t&msm_device_uart1,","\t&msm_device_uart_dm1,","\t&msm_device_nand,","\t&msm_gsbi0_qup_i2c_device,","\t&msm_gsbi1_qup_i2c_device,","\t&msm_device_otg,","\t&msm_device_gadget_peripheral,","\t&android_usb_device,","\t&android_pmem_device,","\t&android_pmem_adsp_device,","\t&android_pmem_audio_device,","\t&msm_device_snd,","\t&msm_device_adspdec,","\t&msm_fb_device,","\t&lcdc_trebon_panel_device,","\t&msm_batt_device,","\t&msm_kgsl_3d0,","#ifdef CONFIG_ANDROID_RAM_CONSOLE","\t&ram_console_device,","#endif","#ifdef CONFIG_ION_MSM","\t&ion_dev,","#endif","#ifdef CONFIG_IMX072","\t&msm_camera_sensor_imx072,","#endif","#ifdef CONFIG_WEBCAM_OV9726","\t&msm_camera_sensor_ov9726,","#endif","#ifdef CONFIG_S5K4ECGX","\t&msm_camera_sensor_s5k4ecgx,","#endif","","#ifdef CONFIG_MT9V113","\t&msm_camera_sensor_mt9v113,","#endif","#ifdef CONFIG_MT9E013","\t&msm_camera_sensor_mt9e013,","#endif","#ifdef CONFIG_FB_MSM_MIPI_DSI","\t&mipi_dsi_renesas_panel_device,","#endif","#ifdef CONFIG_BT","\t&msm_bt_power_device,","#endif","\t&touch_i2c_gpio_device,","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t&sensor_i2c_gpio_device,","#endif","#ifdef CONFIG_BQ27425_FUEL_GAUGE","\t&fuelgauge_i2c_gpio_device,","#endif","\t&fsa880_i2c_gpio_device,","\t&msm_device_pmic_leds,","\t&msm_vibrator_device,","#ifdef CONFIG_SAMSUNG_JACK","\t&sec_device_jack,","#endif","\t&asoc_msm_pcm,","\t&asoc_msm_dai0,","\t&asoc_msm_dai1,","};","","static unsigned pmem_kernel_ebi1_size = PMEM_KERNEL_EBI1_SIZE;","static int __init pmem_kernel_ebi1_size_setup(char *p)","{","\tpmem_kernel_ebi1_size = memparse(p, NULL);","\treturn 0;","}","early_param(\"pmem_kernel_ebi1_size\", pmem_kernel_ebi1_size_setup);","","static unsigned pmem_audio_size = MSM_PMEM_AUDIO_SIZE;","static int __init pmem_audio_size_setup(char *p)","{","\tpmem_audio_size = memparse(p, NULL);","\treturn 0;","}","early_param(\"pmem_audio_size\", pmem_audio_size_setup);","","static void __init msm_msm7x2x_allocate_memory_regions(void)","{","\tvoid *addr;","\tunsigned long size;","","\tsize = fb_size ? : MSM_FB_SIZE;","\taddr = alloc_bootmem_align(size, 0x1000);","\tmsm_fb_resources[0].start = __pa(addr);","\tmsm_fb_resources[0].end = msm_fb_resources[0].start + size - 1;","\tpr_info(\"allocating %lu bytes at %p (%lx physical) for fb\\n\",","\t\tsize, addr, __pa(addr));","\t\t","#ifdef CONFIG_ANDROID_RAM_CONSOLE","\t/* RAM Console can't use alloc_bootmem(), since that zeroes the","     * region */","    size = MSM_RAM_CONSOLE_SIZE;","    ram_console_resources[0].start = msm_fb_resources[0].end+1;","    ram_console_resources[0].end = ram_console_resources[0].start + size - 1;","    pr_info(\"allocating %lu bytes at (%lx physical) for ram console\\n\",","           size, (unsigned long)ram_console_resources[0].start);","    /* We still have to reserve it, though */","    reserve_bootmem(ram_console_resources[0].start,size,0);","#endif","}","","#ifdef CONFIG_ION_MSM","#ifdef CONFIG_MSM_MULTIMEDIA_USE_ION","static struct ion_co_heap_pdata co_ion_pdata = {","\t.adjacent_mem_id = INVALID_HEAP_ID,","\t.align = PAGE_SIZE,","};","#endif","","/**"," * These heaps are listed in the order they will be allocated."," * Don't swap the order unless you know what you are doing!"," */","static struct ion_platform_data ion_pdata = {","        .nr = MSM_ION_HEAP_NUM,","        .has_outer_cache = 1,","        .heaps = {","                {","                        .id        = ION_SYSTEM_HEAP_ID,","                        .type        = ION_HEAP_TYPE_SYSTEM,","                        .name        = ION_VMALLOC_HEAP_NAME,","                },","#ifdef CONFIG_MSM_MULTIMEDIA_USE_ION","                /* PMEM_ADSP = CAMERA */","                {","                        .id        = ION_CAMERA_HEAP_ID,","                        .type        = ION_HEAP_TYPE_CARVEOUT,","                        .name        = ION_CAMERA_HEAP_NAME,","                        .memory_type = ION_EBI_TYPE,","                        .extra_data = (void *)&co_ion_pdata,","                },","                /* PMEM_AUDIO */","                {","                        .id        = ION_AUDIO_HEAP_ID,","                        .type        = ION_HEAP_TYPE_CARVEOUT,","                        .name        = ION_AUDIO_HEAP_NAME,","                        .memory_type = ION_EBI_TYPE,","                        .extra_data = (void *)&co_ion_pdata,","                },","                /* PMEM_MDP = SF */","                {","                        .id        = ION_SF_HEAP_ID,","                        .type        = ION_HEAP_TYPE_CARVEOUT,","                        .name        = ION_SF_HEAP_NAME,","                        .memory_type = ION_EBI_TYPE,","                        .extra_data = (void *)&co_ion_pdata,","                },","#endif","        }","};","","static struct platform_device ion_dev = {","\t.name = \"ion-msm\",","\t.id = 1,","\t.dev = { .platform_data = &ion_pdata },","};","#endif","","static struct memtype_reserve msm7x27a_reserve_table[] __initdata = {","\t[MEMTYPE_SMI] = {","\t},","\t[MEMTYPE_EBI0] = {","\t\t.flags\t=\tMEMTYPE_FLAGS_1M_ALIGN,","\t},","\t[MEMTYPE_EBI1] = {","\t\t.flags\t=\tMEMTYPE_FLAGS_1M_ALIGN,","\t},","};","","#ifdef CONFIG_ANDROID_PMEM","#if !defined(CONFIG_MSM_MULTIMEDIA_USE_ION) || defined(CONFIG_MSM_ADSP_USE_PMEM)","static struct android_pmem_platform_data *pmem_pdata_array[] __initdata = {","#ifdef CONFIG_MSM_ADSP_USE_PMEM","\t\t&android_pmem_adsp_pdata,","#endif","#ifndef CONFIG_MSM_MULTIMEDIA_USE_ION","\t\t&android_pmem_audio_pdata,","\t\t&android_pmem_pdata,","#endif","};","#endif","#endif","","static void __init size_pmem_devices(void)","{","#ifdef CONFIG_ANDROID_PMEM","#ifdef CONFIG_MSM_ADSP_USE_PMEM","\tandroid_pmem_adsp_pdata.size = pmem_adsp_size;","#endif","#ifndef CONFIG_MSM_MULTIMEDIA_USE_ION","\tandroid_pmem_pdata.size = pmem_mdp_size;","\tandroid_pmem_audio_pdata.size = pmem_audio_size;","","#endif","#endif","}","","#ifdef CONFIG_ANDROID_PMEM","#if !defined(CONFIG_MSM_MULTIMEDIA_USE_ION) || defined(CONFIG_MSM_ADSP_USE_PMEM)","static void __init reserve_memory_for(struct android_pmem_platform_data *p)","{","\tmsm7x27a_reserve_table[p->memory_type].size += p->size;","}","#endif","#endif","","static void __init reserve_pmem_memory(void)","{","#ifdef CONFIG_ANDROID_PMEM","#if !defined(CONFIG_MSM_MULTIMEDIA_USE_ION) || defined(CONFIG_MSM_ADSP_USE_PMEM)","\tunsigned int i;","\tfor (i = 0; i < ARRAY_SIZE(pmem_pdata_array); ++i)","\t\treserve_memory_for(pmem_pdata_array[i]);","","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += pmem_kernel_ebi1_size;","#endif","#endif","}","","static void __init size_ion_devices(void)","{","#ifdef CONFIG_MSM_MULTIMEDIA_USE_ION","\tion_pdata.heaps[1].size = msm_ion_camera_size;","\tion_pdata.heaps[2].size = msm_ion_audio_size;","\tion_pdata.heaps[3].size = msm_ion_sf_size;","#endif","}","","static void __init reserve_ion_memory(void)","{","#if defined(CONFIG_ION_MSM) && defined(CONFIG_MSM_MULTIMEDIA_USE_ION)","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += msm_ion_camera_size;","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += msm_ion_audio_size;","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += msm_ion_sf_size;","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += 1;","#endif","}","","static void __init msm7x27a_calculate_reserve_sizes(void)","{","\tsize_pmem_devices();","\treserve_pmem_memory();","\tsize_ion_devices();","\treserve_ion_memory();","}","","static int msm7x27a_paddr_to_memtype(unsigned int paddr)","{","\treturn MEMTYPE_EBI1;","}","","static struct reserve_info msm7x27a_reserve_info __initdata = {","\t.memtype_reserve_table = msm7x27a_reserve_table,","\t.calculate_reserve_sizes = msm7x27a_calculate_reserve_sizes,","\t.paddr_to_memtype = msm7x27a_paddr_to_memtype,","};","","static void __init msm7x27a_reserve(void)","{","\treserve_info = &msm7x27a_reserve_info;","\tmsm_reserve();","}","","static void __init msm_device_i2c_init(void)","{","\tmsm_gsbi0_qup_i2c_device.dev.platform_data = &msm_gsbi0_qup_i2c_pdata;","\tmsm_gsbi1_qup_i2c_device.dev.platform_data = &msm_gsbi1_qup_i2c_pdata;","","\tgpio_tlmm_config(GPIO_CFG(GPIO_TSP_SDA, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_TSP_SCL, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_MUS_SDA, 0, GPIO_CFG_OUTPUT,","\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_MUS_SCL, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t#if defined(CONFIG_SENSORS_HSCD) || defined(CONFIG_PROXIMITY_SENSOR)","\tgpio_tlmm_config(GPIO_CFG(GPIO_SENSOR_SCL, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_SENSOR_SDA, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\t#endif","#endif","\tprintk(\"[TSP] %s =======gpio_request==test======ln=%d\\n\",","\t\t\t__func__, __LINE__);","}","","static struct msm_panel_common_pdata mdp_pdata = {","\t.gpio = 97,","\t.mdp_rev = MDP_REV_303,","};","","#define GPIO_LCDC_BRDG_PD\t128","#define GPIO_LCDC_BRDG_RESET_N\t129","","#define LCDC_RESET_PHYS\t\t0x90008014","","static\tvoid __iomem *lcdc_reset_ptr;","","static unsigned mipi_dsi_gpio[] = {","\tGPIO_CFG(GPIO_LCDC_BRDG_RESET_N, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,","\t\tGPIO_CFG_2MA),       /* LCDC_BRDG_RESET_N */","\tGPIO_CFG(GPIO_LCDC_BRDG_PD, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,","\t\tGPIO_CFG_2MA),       /* LCDC_BRDG_RESET_N */","};","","enum {","\tDSI_SINGLE_LANE = 1,","\tDSI_TWO_LANES,","};","","static int msm_fb_get_lane_config(void)","{","\tint rc = DSI_TWO_LANES;","","\tif (machine_is_msm7625a_surf() || machine_is_msm7625a_ffa()) {","\t\trc = DSI_SINGLE_LANE;","\t\tpr_info(\"DSI Single Lane\\n\");","\t} else {","\t\tpr_info(\"DSI Two Lanes\\n\");","\t}","\treturn rc;","}","","static int msm_fb_dsi_client_reset(void)","{","\tint rc = 0;","","\trc = gpio_request(GPIO_LCDC_BRDG_RESET_N, \"lcdc_brdg_reset_n\");","\tif (rc < 0) {","\t\tpr_err(\"failed to request lcd brdg reset_n\\n\");","\t\treturn rc;","\t}","","\trc = gpio_request(GPIO_LCDC_BRDG_PD, \"lcdc_brdg_pd\");","\tif (rc < 0) {","\t\tpr_err(\"failed to request lcd brdg pd\\n\");","\t\treturn rc;","\t}","","\trc = gpio_tlmm_config(mipi_dsi_gpio[0], GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"Failed to enable LCDC Bridge reset enable\\n\");","\t\tgoto gpio_error;","\t}","","\trc = gpio_tlmm_config(mipi_dsi_gpio[1], GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"Failed to enable LCDC Bridge pd enable\\n\");","\t\tgoto gpio_error2;","\t}","","\trc = gpio_direction_output(GPIO_LCDC_BRDG_RESET_N, 1);","\trc |= gpio_direction_output(GPIO_LCDC_BRDG_PD, 1);","\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_PD, 0);","","\tif (!rc) {","\t\tif (machine_is_msm7x27a_surf()) {","\t\t\tlcdc_reset_ptr = ioremap_nocache(LCDC_RESET_PHYS,","\t\t\t\tsizeof(uint32_t));","","\t\t\tif (!lcdc_reset_ptr)","\t\t\t\treturn 0;","\t\t}","\t\treturn rc;","\t} else {","\t\tgoto gpio_error;","\t}","","gpio_error2:","\tpr_err(\"Failed GPIO bridge pd\\n\");","\tgpio_free(GPIO_LCDC_BRDG_PD);","","gpio_error:","\tpr_err(\"Failed GPIO bridge reset\\n\");","\tgpio_free(GPIO_LCDC_BRDG_RESET_N);","\treturn rc;","}","","static const char * const msm_fb_dsi_vreg[] = {","\t\"gp2\",","\t\"msme1\",","\t\"mddi\"","};","","static const int msm_fb_dsi_vreg_mV[] = {","\t2850,","\t1800,","\t1200","};","","static struct vreg *dsi_vreg[ARRAY_SIZE(msm_fb_dsi_vreg)];","static int dsi_gpio_initialized;","","static int mipi_dsi_panel_power(int on)","{","\tint i, rc = 0;","\tuint32_t lcdc_reset_cfg;","","\tprintk(KERN_INFO \"%s: %d (on = 1, off = 0)\\n\", __func__, on);","","\t/* I2C-controlled GPIO Expander -init of the GPIOs very late */","\tif (!dsi_gpio_initialized) {","\t\tpmapp_disp_backlight_init();","","\t\trc = gpio_request(GPIO_DISPLAY_PWR_EN, \"gpio_disp_pwr\");","\t\tif (rc < 0) {","\t\t\tpr_err(\"failed to request gpio_disp_pwr\\n\");","\t\t\treturn rc;","\t\t}","","\t\trc = gpio_direction_output(GPIO_DISPLAY_PWR_EN, 1);","\t\tif (rc < 0) {","\t\t\tpr_err(\"failed to enable display pwr\\n\");","\t\t\tgoto fail_gpio1;","\t\t}","","\t\tif (machine_is_msm7x27a_surf()) {","\t\t\trc = gpio_request(GPIO_BACKLIGHT_EN, \"gpio_bkl_en\");","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"failed to request gpio_bkl_en\\n\");","\t\t\t\tgoto fail_gpio1;","\t\t\t}","","\t\t\trc = gpio_direction_output(GPIO_BACKLIGHT_EN, 1);","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"failed to enable backlight\\n\");","\t\t\t\tgoto fail_gpio2;","\t\t\t}","\t\t}","","\t\tfor (i = 0; i < ARRAY_SIZE(msm_fb_dsi_vreg); i++) {","\t\t\tdsi_vreg[i] = vreg_get(0, msm_fb_dsi_vreg[i]);","","\t\t\tif (IS_ERR(dsi_vreg[i])) {","\t\t\t\tpr_err(\"%s: vreg get failed with : (%ld)\\n\",","\t\t\t\t\t__func__, PTR_ERR(dsi_vreg[i]));","\t\t\t\tgoto fail_gpio2;","\t\t\t}","","\t\t\trc = vreg_set_level(dsi_vreg[i],","\t\t\t\tmsm_fb_dsi_vreg_mV[i]);","","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"%s: set regulator level failed \"","\t\t\t\t\t\"with :(%d)\\n\",\t__func__, rc);","\t\t\t\tgoto vreg_fail1;","\t\t\t}","\t\t}","\t\tdsi_gpio_initialized = 1;","\t}","","\t\tgpio_set_value_cansleep(GPIO_DISPLAY_PWR_EN, on);","\t\tif (machine_is_msm7x27a_surf()) {","\t\t\tgpio_set_value_cansleep(GPIO_BACKLIGHT_EN, on);","\t\t}","","\t\tif (on) {","\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_PD, 0);","","\t\t\tif (machine_is_msm7x27a_surf()) {","\t\t\t\tlcdc_reset_cfg = readl_relaxed(lcdc_reset_ptr);","\t\t\t\trmb();","\t\t\t\tlcdc_reset_cfg &= ~1;","","\t\t\t\twritel_relaxed(lcdc_reset_cfg, lcdc_reset_ptr);","\t\t\t\tmsleep(20);","\t\t\t\twmb();","\t\t\t\tlcdc_reset_cfg |= 1;","\t\t\t\twritel_relaxed(lcdc_reset_cfg, lcdc_reset_ptr);","\t\t\t} else {","\t\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_RESET_N,","\t\t\t\t\t0);","\t\t\t\tmsleep(20);","\t\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_RESET_N,","\t\t\t\t\t1);","\t\t\t}","","\t\t\tif (pmapp_disp_backlight_set_brightness(100))","\t\t\t\tpr_err(\"backlight set brightness failed\\n\");","\t\t} else {","\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_PD, 1);","","\t\t\tif (pmapp_disp_backlight_set_brightness(0))","\t\t\t\tpr_err(\"backlight set brightness failed\\n\");","\t\t}","","\t\t/* Configure vreg lines */","\t\tfor (i = 0; i < ARRAY_SIZE(msm_fb_dsi_vreg); i++) {","\t\t\tif (on) {","\t\t\t\trc = vreg_enable(dsi_vreg[i]);","","\t\t\t\tif (rc) {","\t\t\t\t\tprintk(KERN_ERR \"vreg_enable: %s vreg\"","\t\t\t\t\t\t\"operation failed\\n\",","\t\t\t\t\t\tmsm_fb_dsi_vreg[i]);","","\t\t\t\t\tgoto vreg_fail2;","\t\t\t\t}","\t\t\t} else {","\t\t\t\trc = vreg_disable(dsi_vreg[i]);","","\t\t\t\tif (rc) {","\t\t\t\t\tprintk(KERN_ERR \"vreg_disable: %s vreg \"","\t\t\t\t\t\t\"operation failed\\n\",","\t\t\t\t\t\tmsm_fb_dsi_vreg[i]);","\t\t\t\t\tgoto vreg_fail2;","\t\t\t\t}","\t\t\t}","\t\t}","","\treturn rc;","","vreg_fail2:","\tif (on) {","\t\tfor (; i > 0; i--)","\t\t\tvreg_disable(dsi_vreg[i - 1]);","\t} else {","\t\tfor (; i > 0; i--)","\t\t\tvreg_enable(dsi_vreg[i - 1]);","\t}","","\treturn rc;","","vreg_fail1:","\tfor (; i > 0; i--)","\t\tvreg_put(dsi_vreg[i - 1]);","","fail_gpio2:","\tgpio_free(GPIO_BACKLIGHT_EN);","fail_gpio1:","\tgpio_free(GPIO_DISPLAY_PWR_EN);","\tdsi_gpio_initialized = 0;","\treturn rc;","}","","#define MDP_303_VSYNC_GPIO 97","","#ifdef CONFIG_FB_MSM_MDP303","static struct mipi_dsi_platform_data mipi_dsi_pdata = {","\t.vsync_gpio = MDP_303_VSYNC_GPIO,","\t.dsi_power_save   = mipi_dsi_panel_power,","\t.dsi_client_reset = msm_fb_dsi_client_reset,","\t.get_lane_config = msm_fb_get_lane_config,","};","#endif","","static void __init msm_fb_add_devices(void)","{","\tmsm_fb_register_device(\"mdp\", &mdp_pdata);","\tmsm_fb_register_device(\"lcdc\", &lcdc_pdata);","#ifdef CONFIG_FB_MSM_MDP303","\tmsm_fb_register_device(\"mipi_dsi\", &mipi_dsi_pdata);","#endif","}","","#define MSM_EBI2_PHYS\t\t\t0xa0d00000","#define MSM_EBI2_XMEM_CS2_CFG1\t\t0xa0d10030","","static void __init msm7x27a_init_ebi2(void)","{","\tuint32_t ebi2_cfg;","\tvoid __iomem *ebi2_cfg_ptr;","","\tebi2_cfg_ptr = ioremap_nocache(MSM_EBI2_PHYS, sizeof(uint32_t));","\tif (!ebi2_cfg_ptr)","\t\treturn;","","\tebi2_cfg = readl(ebi2_cfg_ptr);","\tif (machine_is_msm7x27a_rumi3() || machine_is_msm7x27a_surf())","\t\tebi2_cfg |= (1 << 4); /* CS2 */","","\twritel(ebi2_cfg, ebi2_cfg_ptr);","\tiounmap(ebi2_cfg_ptr);","","\t/* Enable A/D MUX[bit 31] from EBI2_XMEM_CS2_CFG1 */","\tebi2_cfg_ptr = ioremap_nocache(MSM_EBI2_XMEM_CS2_CFG1,","\t\t\t\t\t\t\t sizeof(uint32_t));","\tif (!ebi2_cfg_ptr)","\t\treturn;","","\tebi2_cfg = readl(ebi2_cfg_ptr);","\tif (machine_is_msm7x27a_surf())","\t\tebi2_cfg |= (1 << 31);","","\twritel(ebi2_cfg, ebi2_cfg_ptr);","\tiounmap(ebi2_cfg_ptr);","}","","static void keypad_gpio_init(void)","{","\tint rc = 0;","\tprintk(KERN_INFO \"[KEY] %s start\\n\", __func__);","","\tgpio_tlmm_config(GPIO_CFG(36, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(37, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(39, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(31, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_set_value_cansleep(31, 0);","}","","#define KP_INDEX(row, col) ((row)*ARRAY_SIZE(kp_col_gpios) + (col))","\tstatic unsigned int kp_row_gpios[] = {36, 37, 39};","\tstatic unsigned int kp_col_gpios[] = {31};","\tstatic unsigned int kp_wakeup_gpios[] = {37};","\tstatic const unsigned short keymap[ARRAY_SIZE(kp_col_gpios) *","\t\t\t\t\t  ARRAY_SIZE(kp_row_gpios)] = {","\t\t[KP_INDEX(0, 0)] = KEY_VOLUMEDOWN,","","\t\t[KP_INDEX(1, 0)] = KEY_HOME,","","\t\t[KP_INDEX(2, 0)] = KEY_VOLUMEUP,","\t};","","/* SURF keypad platform device information */","static struct gpio_event_matrix_info kp_matrix_info = {","\t.info.func\t= gpio_event_matrix_func,","\t.keymap\t\t= keymap,","\t.output_gpios\t= kp_col_gpios,","\t.input_gpios\t= kp_row_gpios,","\t.wakeup_gpios\t= kp_wakeup_gpios,","\t.nwakeups\t= ARRAY_SIZE(kp_wakeup_gpios),","\t.noutputs\t= ARRAY_SIZE(kp_col_gpios),","\t.ninputs\t= ARRAY_SIZE(kp_row_gpios),","\t.settle_time.tv_nsec = 40 * NSEC_PER_USEC,","\t.poll_time.tv_nsec = 20 * NSEC_PER_MSEC,","\t.debounce_delay.tv_nsec = 20 * NSEC_PER_MSEC,","\t.flags\t\t= GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_DRIVE_INACTIVE |","\t\t\t  GPIOKPF_PRINT_UNMAPPED_KEYS | GPIOKPF_DEBOUNCE,","};","","static struct gpio_event_info *kp_info[] = {","\t&kp_matrix_info.info","};","","static struct gpio_event_platform_data kp_pdata = {","\t.name\t\t= \"7x27a_kp\",","\t.info\t\t= kp_info,","\t.info_count\t= ARRAY_SIZE(kp_info)","};","","static struct platform_device kp_pdev = {","\t.name\t= GPIO_EVENT_DEV_NAME,","\t.id\t= -1,","\t.dev\t= {","\t\t.platform_data\t= &kp_pdata,","\t},","};","","static struct msm_handset_platform_data hs_platform_data = {","\t.hs_name = \"sec_jack\",","\t.pwr_key_delay_ms = 500, /* 0 will disable end key */","};","","static struct platform_device hs_pdev = {","\t.name   = \"msm-handset\",","\t.id     = -1,","\t.dev    = {","\t\t.platform_data = &hs_platform_data,","\t},","};","","static struct platform_device msm_proccomm_regulator_dev = {","\t.name   = PROCCOMM_REGULATOR_DEV_NAME,","\t.id     = -1,","\t.dev    = {","\t\t.platform_data = &msm7x27a_proccomm_regulator_data","\t}","};","","static void __init msm7627a_rumi3_init(void)","{","\tmsm7x27a_init_ebi2();","\tplatform_add_devices(rumi_sim_devices,","\t\t\tARRAY_SIZE(rumi_sim_devices));","}","","#define LED_GPIO_PDM\t\t96","#define UART1DM_RX_GPIO\t\t45","","static int __init msm7x27a_init_ar6000pm(void)","{","\treturn platform_device_register(&msm_wlan_ar6000_pm_device);","}","","static void __init msm7x27a_init_regulators(void)","{","\tint rc = platform_device_register(&msm_proccomm_regulator_dev);","\tif (rc)","\t\tpr_err(\"%s: could not register regulator device: %d\\n\",","\t\t\t\t__func__, rc);","}","","static struct msm7x27a_regulators {","  const char *id;","  unsigned   voltage; // in mv","};","","static struct msm7x27a_regulators msm7x27a_reg[] = {","[0] = {","        .id = \"smps3\",","        .voltage = 1800,","      },","};","","/* function to Enable the regulators */","static void msm7x27a_enable_regulators(void)","{","   struct vreg *vreg = NULL;","   struct msm7x27a_regulators *regulators = msm7x27a_reg;","   static int i = 0, ret =0, VRG_SIZE =0;","","   /* Get the count of regulators */","   VRG_SIZE= ARRAY_SIZE(msm7x27a_reg);","","   for(i=0; i<VRG_SIZE; i++) {","","       /* get the regulator descriptor */","       vreg = vreg_get( NULL, regulators[i].id);","","       if(IS_ERR(vreg)) {","         pr_err(\"failed to get the regulator %s\\n\",regulators[i].id);","         return ;","       }","","       /* set the regulator voltage(optimum) */","       ret = vreg_set_level(vreg,regulators[i].voltage);","","       if(ret)","       {","         pr_err(\"failed to set the voltage level for regulator %s\\n\",regulators[i].id);","         return ;","       }","","       /* enable the regulator or ldo */","       if(vreg_enable(vreg))","       {","         pr_err(\"failed to enable the regulator %s\\n\",regulators[i].id);","         return ;","       }","    }","   pr_debug(\"Successfully enabled all regulators\\n\");","   return;","}","","static void __init msm7x2x_init(void)","{","    msm7x2x_misc_init();","","\t/* Initialize the regulators */","\tmsm7x27a_init_regulators();","","\t/* Enable the Required regulators */","    msm7x27a_enable_regulators();","","\t/* Common functions for SURF/FFA/RUMI3 */","\tmsm_device_i2c_init();","\tmsm7x27a_init_ebi2();","","#ifdef CONFIG_SERIAL_MSM_HS","\tmsm_uart_dm1_pdata.wakeup_irq = gpio_to_irq(UART1DM_RX_GPIO);","\tmsm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;","#endif","","#ifdef CONFIG_USB_MSM_OTG_72K","\tmsm_otg_pdata.swfi_latency =","\t\tmsm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT].latency;","\tmsm_device_otg.dev.platform_data = &msm_otg_pdata;","#endif","\tmsm_device_gadget_peripheral.dev.platform_data =","\t\t&msm_gadget_pdata;","\tmsm7x27a_cfg_smsc911x();","#ifdef CONFIG_SAMSUNG_JACK","\t\tsec_jack_gpio_init();","#endif","\tplatform_add_devices(msm_footswitch_devices,","\t\t\tmsm_num_footswitch_devices);","\tplatform_add_devices(surf_ffa_devices,","\t\t\tARRAY_SIZE(surf_ffa_devices));","\t\tif (!kernel_uart_flag)","\t\t{","\t\t\tplatform_device_register(&msm_device_uart3);","\t\t}","","\t/* Ensure ar6000pm device is registered before MMC/SDC */","\tmsm7x27a_init_ar6000pm();","\tmsm7x27a_init_mmc();","","\tlcdc_trebon_gpio_init();","\tmsm_fb_add_devices();","","","#ifdef CONFIG_USB_EHCI_MSM_72K","\tmsm7x2x_init_host();","#endif","","\tmsm_pm_set_platform_data(msm7x27a_pm_data,","\t\t\t\tARRAY_SIZE(msm7x27a_pm_data));","","\tBUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));","","\tregister_i2c_devices();","","\twlan_power_init();","","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","\tbt_power_init();","#endif","","#ifdef CONFIG_TOUCHSCREEN_ZINITIX_TREBON","\ttsp_power_on();","#endif","","\tsamsung_sys_class_init();","\ti2c_register_board_info( 2, touch_i2c_devices, ARRAY_SIZE(touch_i2c_devices));","\ti2c_register_board_info( 3, fsa880_i2c_devices, ARRAY_SIZE(fsa880_i2c_devices));","#ifdef CONFIG_BQ27425_FUEL_GAUGE","\ti2c_register_board_info(6, fg_i2c_devices, ARRAY_SIZE(fg_i2c_devices));","#endif","","\ti2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,","\t\t\ti2c_camera_devices,","\t\t\tARRAY_SIZE(i2c_camera_devices));","\tkeypad_gpio_init();","\tplatform_device_register(&kp_pdev);","\tplatform_device_register(&hs_pdev);","","\t/* Configure it as a pdm function*/","\tif (gpio_tlmm_config(GPIO_CFG(LED_GPIO_PDM, 3,","\t\t\t\tGPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,","\t\t\t\tGPIO_CFG_8MA), GPIO_CFG_ENABLE))","\t\tpr_err(\"%s: gpio_tlmm_config for %d failed\\n\",","\t\t\t__func__, LED_GPIO_PDM);","\telse","\t\tplatform_device_register(&led_pdev);","","#ifdef CONFIG_MSM_RPC_VIBRATOR","\tif (machine_is_msm7x27a_ffa() || machine_is_msm7625a_ffa())","\t\tmsm_init_pmic_vibrator();","#endif","       /*7x25a kgsl initializations*/","       msm7x25a_kgsl_3d0_init();","","\t   //ar6000_prealloc_init();","}","","static void __init msm7x2x_init_early(void)","{","\tmsm_msm7x2x_allocate_memory_regions();","}","","MACHINE_START(MSM7X27A_RUMI3, \"QCT MSM7x27a RUMI3\")","\t.boot_params\t= PHYS_OFFSET + 0x100,","\t.map_io\t\t= msm_common_io_init,","\t.reserve\t= msm7x27a_reserve,","\t.init_irq\t= msm_init_irq,","\t.init_machine\t= msm7627a_rumi3_init,","\t.timer\t\t= &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7X27A_SURF, \"QCT MSM7x27a SURF\")","\t.boot_params\t= PHYS_OFFSET + 0x100,","\t.map_io\t\t= msm_common_io_init,","\t.reserve\t= msm7x27a_reserve,","\t.init_irq\t= msm_init_irq,","\t.init_machine\t= msm7x2x_init,","\t.timer\t\t= &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7X27A_FFA, \"QCT MSM7x27a FFA\")","\t.boot_params\t= PHYS_OFFSET + 0x100,","\t.map_io\t\t= msm_common_io_init,","\t.reserve\t= msm7x27a_reserve,","\t.init_irq\t= msm_init_irq,","\t.init_machine\t= msm7x2x_init,","\t.timer\t\t= &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7625A_SURF, \"QCT MSM7625a SURF\")","\t.boot_params    = PHYS_OFFSET + 0x100,","\t.map_io         = msm_common_io_init,","\t.reserve        = msm7x27a_reserve,","\t.init_irq       = msm_init_irq,","\t.init_machine   = msm7x2x_init,","\t.timer          = &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7625A_FFA, \"QCT MSM7625a FFA\")","\t.boot_params    = PHYS_OFFSET + 0x100,","\t.map_io         = msm_common_io_init,","\t.reserve        = msm7x27a_reserve,","\t.init_irq       = msm_init_irq,","\t.init_machine   = msm7x2x_init,","\t.timer          = &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END",""]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":4444,"column":11},"action":"insert","lines":["/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved."," *"," * This program is free software; you can redistribute it and/or modify"," * it under the terms of the GNU General Public License version 2 and"," * only version 2 as published by the Free Software Foundation."," *"," * This program is distributed in the hope that it will be useful,"," * but WITHOUT ANY WARRANTY; without even the implied warranty of"," * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"," * GNU General Public License for more details."," *"," */","#include <linux/kernel.h>","#include <linux/init.h>","#include <linux/gpio_event.h>","#include <linux/i2c-gpio.h>","#include <asm/mach-types.h>","#include <asm/mach/arch.h>","#include <mach/board.h>","#include <mach/msm_iomap.h>","#include <mach/msm_hsusb.h>","#include <mach/rpc_hsusb.h>","#include <mach/rpc_pmapp.h>","#include <mach/usbdiag.h>","#include <mach/usb_gadget_fserial.h>","#include <mach/msm_memtypes.h>","#include <mach/msm_serial_hs.h>","#include <linux/usb/android.h>","#include <linux/platform_device.h>","#include <linux/io.h>","#include <mach/gpio_trebon.h>","#include <mach/pmic.h>","#include <mach/socinfo.h>","#include <linux/mtd/nand.h>","#include <linux/mtd/partitions.h>","#include <asm/mach/mmc.h>","#include <linux/i2c.h>","#include <linux/i2c/sx150x.h>","#include <linux/gpio.h>","#include <linux/android_pmem.h>","#include <linux/bootmem.h>","#include <linux/mfd/marimba.h>","#include <mach/vreg.h>","#include <linux/power_supply.h>","#include <linux/regulator/consumer.h>","#include <mach/rpc_pmapp.h>","#include <mach/msm_battery.h>","#include <linux/smsc911x.h>","#include <linux/ion.h>","#include \"devices.h\"","#include \"timer.h\"","#include \"board-msm7x27a-regulator.h\"","#include \"devices-msm7x2xa.h\"","#include \"pm.h\"","#ifdef CONFIG_SAMSUNG_JACK","#include <linux/sec_jack.h>","#endif","#include <mach/rpc_server_handset.h>","#include <mach/socinfo.h>","#include <linux/fsaxxxx_usbsw.h>","#include \"proc_comm.h\"","#include \"pm-boot.h\"","#ifdef CONFIG_PROXIMITY_SENSOR","#include <linux/gp2a.h>","#endif","/*","#ifdef CONFIG_FORCE_FAST_CHARGE","#include <linux/fastchg.h>","#endif","*/","#ifndef CONFIG_MSM_CAMERA","#define CONFIG_MSM_CAMERA","#endif","","#ifdef CONFIG_FORCE_FAST_CHARGE","#include <linux/fastchg.h>","#endif","","#define _CONFIG_MACH_JENA // Temporary flag","#define _CONFIG_MACH_TREBON // Temporary flag","#define ADSP_RPC_PROG           0x3000000a","","#define PMEM_KERNEL_EBI1_SIZE\t0x3A000","#define MSM_PMEM_AUDIO_SIZE\t0x1F4000 //0x5B000","#define BAHAMA_SLAVE_ID_FM_ADDR         0x2A","#define BAHAMA_SLAVE_ID_QMEMBIST_ADDR   0x7B","#define BAHAMA_SLAVE_ID_FM_REG 0x02","#define FM_GPIO\t83","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","#define GPIO_BLUETOOTH_LDO 82","#endif","","#ifdef CONFIG_BQ27425_FUEL_GAUGE","#define FUEL_I2C_SCL 78","#define FUEL_I2C_SDA 79","#endif","","int charging_boot;","EXPORT_SYMBOL(charging_boot);","int\tfota_boot;","EXPORT_SYMBOL(fota_boot);","","#define WLAN_33V_CONTROL_FOR_BT_ANTENNA","","#define WLAN_OK (0)","#define WLAN_ERROR (-1)","","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","#define WLAN_33V_WIFI_FLAG (0x01)","#define WLAN_33V_BT_FLAG (0x02)","","int wlan_33v_flag;","","static int wlan_setup_ldo_33v(int input_flag, int on);","#endif","","#ifdef CONFIG_SAMSUNG_JACK","","#define GPIO_JACK_S_35\t48","#define GPIO_SEND_END\t92","","static struct sec_jack_zone jack_zones[] = {","\t[0] = {","\t\t.adc_high\t= 3,","\t\t.delay_ms\t= 10,","\t\t.check_count\t= 5,","\t\t.jack_type\t= SEC_HEADSET_3POLE,","\t},","\t[1] = {","\t\t.adc_high\t= 99,","\t\t.delay_ms\t= 10,","\t\t.check_count\t= 10,","\t\t.jack_type\t= SEC_HEADSET_3POLE,","\t},","\t[2] = {","\t\t.adc_high\t= 9999,","\t\t.delay_ms\t= 10,","\t\t.check_count\t= 5,","\t\t.jack_type\t= SEC_HEADSET_4POLE,","\t},","};","","int get_msm7x27a_det_jack_state(void)","{","\t/* Active Low */","\treturn(gpio_get_value(GPIO_JACK_S_35)) ^ 1;","}","EXPORT_SYMBOL(get_msm7x27a_det_jack_state);","","static int get_msm7x27a_send_key_state(void)","{","\treturn 0;","}","","#define SMEM_PROC_COMM_MICBIAS_ONOFF\t\tPCOM_OEM_MICBIAS_ONOFF","#define SMEM_PROC_COMM_MICBIAS_ONOFF_REG5\tPCOM_OEM_MICBIAS_ONOFF_REG5","#define SMEM_PROC_COMM_GET_ADC\t\t\t\tPCOM_OEM_SAMSUNG_GET_ADC","","enum {","\tSMEM_PROC_COMM_GET_ADC_BATTERY = 0x0,","\tSMEM_PROC_COMM_GET_ADC_TEMP,","\tSMEM_PROC_COMM_GET_ADC_VF,","\tSMEM_PROC_COMM_GET_ADC_ALL, // data1 : VF(MSB 2 bytes) vbatt_adc(LSB 2bytes), data2 : temp_adc","\tSMEM_PROC_COMM_GET_ADC_EAR_ADC,\t\t// 3PI_ADC","\tSMEM_PROC_COMM_GET_ADC_MAX,","};","","enum {","\tSMEM_PROC_COMM_MICBIAS_CONTROL_OFF = 0x0,","\tSMEM_PROC_COMM_MICBIAS_CONTROL_ON,","\tSMEM_PROC_COMM_MICBIAS_CONTROL_MAX","};","","static void set_msm7x27a_micbias_state_reg5(bool state) {}","static bool cur_state = false;","static bool proximity_init;","","static void set_msm7x27a_micbias_state(bool state)","{","\tif(cur_state == state)","\t{","\t\tpr_info(\"sec_jack : earmic_bias same as cur_state\\n\");","\t\treturn;","\t}","\tif(state)","\t{","\t\tpmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_ALWAYS);","\t\tmsleep(130);","\t\tcur_state = true;","\t}","\telse","\t{","\t\tpmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_OFF);","\t\tcur_state = false;","\t}","","\treport_headset_status(state);","\tpr_info(\"sec_jack : earmic_bias %s\\n\", state?\"on\":\"off\");","}","","static int sec_jack_get_adc_value(void)","{","\treturn current_jack_type;","}","","void sec_jack_gpio_init(void)","{","\tgpio_tlmm_config(GPIO_CFG(GPIO_JACK_S_35, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tif(gpio_request(GPIO_JACK_S_35, \"h2w_detect\")<0)","\t\tpr_err(\"sec_jack:gpio_request fail\\n\");","\tif(gpio_direction_input(GPIO_JACK_S_35)<0)","\t\tpr_err(\"sec_jack:gpio_direction fail\\n\");","}","","static struct sec_jack_platform_data sec_jack_data = {","\t.get_det_jack_state\t= get_msm7x27a_det_jack_state,","\t.get_send_key_state\t= get_msm7x27a_send_key_state,","\t.set_micbias_state\t= set_msm7x27a_micbias_state,","\t.set_micbias_state_reg5\t= set_msm7x27a_micbias_state_reg5,","\t.get_adc_value\t= sec_jack_get_adc_value,","\t.zones\t\t= jack_zones,","\t.num_zones\t= ARRAY_SIZE(jack_zones),","\t.det_int\t= MSM_GPIO_TO_INT(GPIO_JACK_S_35),","\t.send_int\t= MSM_GPIO_TO_INT(GPIO_SEND_END),","};","","static struct platform_device sec_device_jack = {","\t.name           = \"sec_jack\",","\t.id             = -1,","\t.dev            = {","\t\t.platform_data  = &sec_jack_data,","\t},","};","#endif","","enum {","\tGPIO_EXPANDER_IRQ_BASE\t= NR_MSM_IRQS + NR_GPIO_IRQS,","\tGPIO_EXPANDER_GPIO_BASE\t= NR_MSM_GPIOS,","\t/* SURF expander */","\tGPIO_CORE_EXPANDER_BASE\t= GPIO_EXPANDER_GPIO_BASE,","\tGPIO_BT_SYS_REST_EN\t= GPIO_CORE_EXPANDER_BASE,","\tGPIO_WLAN_EXT_POR_N,","\tGPIO_DISPLAY_PWR_EN,","\tGPIO_BACKLIGHT_EN,","\tGPIO_PRESSURE_XCLR,","\tGPIO_VREG_S3_EXP,","\tGPIO_UBM2M_PWRDWN,","\tGPIO_ETM_MODE_CS_N,","\tGPIO_HOST_VBUS_EN,","\txGPIO_SPI_MOSI,","\txGPIO_SPI_MISO,","\txGPIO_SPI_CLK,","\txGPIO_SPI_CS0_N,","\tGPIO_CORE_EXPANDER_IO13,","\tGPIO_CORE_EXPANDER_IO14,","\tGPIO_CORE_EXPANDER_IO15,","\t/* Camera expander */","\tGPIO_CAM_EXPANDER_BASE\t= GPIO_CORE_EXPANDER_BASE + 16,","\tGPIO_CAM_GP_STROBE_READY\t= GPIO_CAM_EXPANDER_BASE,","\tGPIO_CAM_GP_AFBUSY,","\tGPIO_CAM_GP_CAM_PWDN,","\tGPIO_CAM_GP_CAM1MP_XCLR,","\tGPIO_CAM_GP_CAMIF_RESET_N,","\tGPIO_CAM_GP_STROBE_CE,","\tGPIO_CAM_GP_LED_EN1,","\tGPIO_CAM_GP_LED_EN2,","};","","#if defined(CONFIG_GPIO_SX150X)","enum {","\tSX150X_CORE,","\tSX150X_CAM,","};","","static struct sx150x_platform_data sx150x_data[] __initdata = {","\t[SX150X_CORE]\t= {","\t\t.gpio_base\t\t= GPIO_CORE_EXPANDER_BASE,","\t\t.oscio_is_gpo\t\t= false,","\t\t.io_pullup_ena\t\t= 0,","\t\t.io_pulldn_ena\t\t= 0,","\t\t.io_open_drain_ena\t= 0,","\t\t.irq_summary\t\t= -1,","\t},","\t[SX150X_CAM]\t= {","\t\t.gpio_base\t\t= GPIO_CAM_EXPANDER_BASE,","\t\t.oscio_is_gpo\t\t= false,","\t\t.io_pullup_ena\t\t= 0,","\t\t.io_pulldn_ena\t\t= 0,","\t\t.io_open_drain_ena\t= 0,","\t\t.irq_summary\t\t= -1,","\t},","};","#endif","","extern unsigned int board_hw_revision;","extern unsigned int kernel_uart_flag;","","/* FM Platform power and shutdown routines */","#define FPGA_MSM_CNTRL_REG2 0x90008010","","static void config_pcm_i2s_mode(int mode)","{","\tvoid __iomem *cfg_ptr;","\tu8 reg2;","","\tcfg_ptr = ioremap_nocache(FPGA_MSM_CNTRL_REG2, sizeof(char));","","\tif (!cfg_ptr)","\t\treturn;","\tif (mode) {","\t\t/*enable the pcm mode in FPGA*/","\t\treg2 = readb_relaxed(cfg_ptr);","\t\tif (reg2 == 0) {","\t\t\treg2 = 1;","\t\t\twriteb_relaxed(reg2, cfg_ptr);","\t\t}","\t} else {","\t\t/*enable i2s mode in FPGA*/","\t\treg2 = readb_relaxed(cfg_ptr);","\t\tif (reg2 == 1) {","\t\t\treg2 = 0;","\t\t\twriteb_relaxed(reg2, cfg_ptr);","\t\t}","\t}","\tiounmap(cfg_ptr);","}","","static unsigned fm_i2s_config_power_on[] = {","\t/*FM_I2S_SD*/","\tGPIO_CFG(68, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*FM_I2S_WS*/","\tGPIO_CFG(70, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*FM_I2S_SCK*/","\tGPIO_CFG(71, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","","static unsigned fm_i2s_config_power_off[] = {","\t/*FM_I2S_SD*/","\tGPIO_CFG(68, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*FM_I2S_WS*/","\tGPIO_CFG(70, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*FM_I2S_SCK*/","\tGPIO_CFG(71, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","};","","static unsigned bt_config_power_on[] = {","\t/*RFR*/","\tGPIO_CFG(43, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*CTS*/","\tGPIO_CFG(44, 2, GPIO_CFG_INPUT,  GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*RX*/","\tGPIO_CFG(45, 2, GPIO_CFG_INPUT,  GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*TX*/","\tGPIO_CFG(46, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","static unsigned bt_config_pcm_on[] = {","\t/*PCM_DOUT*/","\tGPIO_CFG(68, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*PCM_DIN*/","\tGPIO_CFG(69, 1, GPIO_CFG_INPUT,  GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*PCM_SYNC*/","\tGPIO_CFG(70, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t/*PCM_CLK*/","\tGPIO_CFG(71, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","static unsigned bt_config_power_off[] = {","\t/*RFR*/","\tGPIO_CFG(43, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t/*CTS*/","\tGPIO_CFG(44, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t/*RX*/","\tGPIO_CFG(45, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t/*TX*/","\tGPIO_CFG(46, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","};","static unsigned bt_config_pcm_off[] = {","\t/*PCM_DOUT*/","\tGPIO_CFG(68, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*PCM_DIN*/","\tGPIO_CFG(69, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*PCM_SYNC*/","\tGPIO_CFG(70, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\t/*PCM_CLK*/","\tGPIO_CFG(71, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","};","","","static int config_i2s(int mode)","{","\tint pin, rc = 0;","","\tif (mode == FM_I2S_ON) {","\t\tif (machine_is_msm7x27a_surf())","\t\t\tconfig_pcm_i2s_mode(0);","\t\tpr_err(\"%s mode = FM_I2S_ON\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(fm_i2s_config_power_on);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(","\t\t\t\t\tfm_i2s_config_power_on[pin],","\t\t\t\t\tGPIO_CFG_ENABLE","\t\t\t\t\t);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","\t} else if (mode == FM_I2S_OFF) {","\t\tpr_err(\"%s mode = FM_I2S_OFF\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(fm_i2s_config_power_off);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(","\t\t\t\t\tfm_i2s_config_power_off[pin],","\t\t\t\t\tGPIO_CFG_ENABLE","\t\t\t\t\t);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","\t}","\treturn rc;","}","static int config_pcm(int mode)","{","\tint pin, rc = 0;","","\tif (mode == BT_PCM_ON) {","\t\tif (machine_is_msm7x27a_surf())","\t\t\tconfig_pcm_i2s_mode(1);","\t\tpr_err(\"%s mode =BT_PCM_ON\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_pcm_on);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(bt_config_pcm_on[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","\t} else if (mode == BT_PCM_OFF) {","\t\tpr_err(\"%s mode =BT_PCM_OFF\", __func__);","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_pcm_off);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(bt_config_pcm_off[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\t\tif (rc < 0)","\t\t\t\t\treturn rc;","\t\t\t}","","\t}","","\treturn rc;","}","","static int msm_bahama_setup_pcm_i2s(int mode)","{","\tint fm_state = 0, bt_state = 0;","\tint rc = 0;","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","","\tfm_state = marimba_get_fm_status(&config);","\tbt_state = marimba_get_bt_status(&config);","","\tswitch (mode) {","\tcase BT_PCM_ON:","\tcase BT_PCM_OFF:","\t\tif (!fm_state)","\t\t\trc = config_pcm(mode);","\t\tbreak;","\tcase FM_I2S_ON:","\t\trc = config_i2s(mode);","\t\tbreak;","\tcase FM_I2S_OFF:","\t\tif (bt_state)","\t\t\trc = config_pcm(BT_PCM_ON);","\t\telse","\t\t\trc = config_i2s(mode);","\t\tbreak;","\tdefault:","\t\trc = -EIO;","\t\tpr_err(\"%s:Unsupported mode\", __func__);","\t}","\treturn rc;","}","","static int bt_set_gpio(int on)","{","\tint rc = 0;","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","","\tif (on) {","\t\trc = gpio_direction_output(GPIO_BT_PWR, 1);","\t\tmsleep(100);","\t} else {","\t\tif (!marimba_get_fm_status(&config) &&","\t\t\t\t!marimba_get_bt_status(&config)) {","\t\t\tgpio_set_value_cansleep(GPIO_BT_PWR, 0);","\t\t\trc = gpio_direction_input(GPIO_BT_PWR);","\t\t\tmsleep(100);","\t\t}","\t}","\tif (rc)","\t\tpr_err(\"%s: BT sys_reset_en GPIO : Error\", __func__);","","\treturn rc;","}","static struct regulator *fm_regulator;","static int fm_radio_setup(struct marimba_fm_platform_data *pdata)","{","\tint rc = 0;","\tconst char *id = \"FMPW\";","\tuint32_t irqcfg;","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","\tu8 value;","","\t/* Voting for 1.8V Regulator */","\tfm_regulator = regulator_get(NULL , \"vreg_msme\");","\tif (IS_ERR(fm_regulator)) {","\t\tpr_err(\"%s: regulator get failed with : (%ld)\\n\",","\t\t\t__func__, PTR_ERR(fm_regulator));","\t\treturn -EINVAL;","\t}","","\t/* Set the voltage level to 1.8V */","\trc = regulator_set_voltage(fm_regulator, 1800000, 1800000);","\tif (rc < 0) {","\t\tpr_err(\"%s: set regulator level failed with :(%d)\\n\",","\t\t\t__func__, rc);","\t\tgoto fm_regulator_fail;","\t}","","\t/* Enabling the 1.8V regulator */","\trc = regulator_enable(fm_regulator);","\tif (rc) {","\t\tpr_err(\"%s: enable regulator failed with :(%d)\\n\",","\t\t\t__func__, rc);","\t\tgoto fm_regulator_fail;","\t}","","\t/* Voting for 19.2MHz clock */","\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\tPMAPP_CLOCK_VOTE_ON);","\tif (rc < 0) {","\t\tpr_err(\"%s: clock vote failed with :(%d)\\n\",","\t\t\t __func__, rc);","\t\tgoto fm_clock_vote_fail;","\t}","","\trc = bt_set_gpio(1);","\tif (rc) {","\t\tpr_err(\"%s: bt_set_gpio = %d\", __func__, rc);","\t\tgoto fm_gpio_config_fail;","\t}","\t/*re-write FM Slave Id, after reset*/","\tvalue = BAHAMA_SLAVE_ID_FM_ADDR;","\trc = marimba_write_bit_mask(&config,","\t\t\tBAHAMA_SLAVE_ID_FM_REG, &value, 1, 0xFF);","\tif (rc < 0) {","\t\tpr_err(\"%s: FM Slave ID rewrite Failed = %d\", __func__, rc);","\t\tgoto fm_gpio_config_fail;","\t}","\t/* Configuring the FM GPIO */","\tirqcfg = GPIO_CFG(FM_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL,","\t\t\tGPIO_CFG_2MA);","","\trc = gpio_tlmm_config(irqcfg, GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t __func__, irqcfg, rc);","\t\tgoto fm_gpio_config_fail;","\t}","\treturn 0;","","fm_gpio_config_fail:","\tpmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\tPMAPP_CLOCK_VOTE_OFF);","\tbt_set_gpio(0);","fm_clock_vote_fail:","\tregulator_disable(fm_regulator);","","fm_regulator_fail:","\tregulator_put(fm_regulator);","","\treturn rc;","};","","static void fm_radio_shutdown(struct marimba_fm_platform_data *pdata)","{","\tint rc;","\tconst char *id = \"FMPW\";","","\t/* Releasing the GPIO line used by FM */","\tuint32_t irqcfg = GPIO_CFG(FM_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP,","\t\tGPIO_CFG_2MA);","","\trc = gpio_tlmm_config(irqcfg, GPIO_CFG_ENABLE);","\tif (rc)","\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t __func__, irqcfg, rc);","","\t/* Releasing the 1.8V Regulator */","\tif (fm_regulator != NULL) {","\t\trc = regulator_disable(fm_regulator);","","\t\tif (rc)","\t\t\tpr_err(\"%s: disable regulator failed:(%d)\\n\",","\t\t\t\t__func__, rc);","\t\tfm_regulator = NULL;","\t}","","\t/* Voting off the clock */","\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\tPMAPP_CLOCK_VOTE_OFF);","\tif (rc < 0)","\t\tpr_err(\"%s: voting off failed with :(%d)\\n\",","\t\t\t__func__, rc);","\trc = bt_set_gpio(0);","\tif (rc)","\t\tpr_err(\"%s: bt_set_gpio = %d\", __func__, rc);","}","","","#ifndef ATH_POLLING","static void (*wlan_status_notify_cb)(int card_present, void *dev_id);","void *wlan_devid;","","static int register_wlan_status_notify(void (*callback)(int card_present,","\t\t\t\t\tvoid *dev_id), void *dev_id)","{","\tprintk(KERN_INFO \"%s --enter\\n\", __func__);","","\twlan_status_notify_cb = callback;","\twlan_devid = dev_id;","\treturn 0;","}","","static unsigned int wlan_status(struct device *dev)","{","\tint rc;","","\tprintk(KERN_INFO \"%s entered\\n\", __func__);","","\trc = gpio_get_value(GPIO_WLAN_RESET_N/*gpio_wlan_reset_n*/);","","\treturn rc;","}","#endif /* ATH_POLLING */","","static struct marimba_fm_platform_data marimba_fm_pdata = {","\t.fm_setup = fm_radio_setup,","\t.fm_shutdown = fm_radio_shutdown,","\t.irq = MSM_GPIO_TO_INT(FM_GPIO),","\t.vreg_s2 = NULL,","\t.vreg_xo_out = NULL,","\t/* Configuring the FM SoC as I2S Master */","\t.is_fm_soc_i2s_master = true,","\t.config_i2s_gpio = msm_bahama_setup_pcm_i2s,","};","","static struct platform_device msm_wlan_ar6000_pm_device = {","\t.name           = \"wlan_ar6000_pm_dev\",","\t.id             = -1,","};","","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","static struct platform_device msm_bt_power_device = {","\t.name = \"bt_power\",","};","","struct bahama_config_register {","\tu8 reg;","\tu8 value;","\tu8 mask;","};","","static const char * const regulators_bahama_name[] = {","\t\"vreg_msme\",","#if (CONFIG_MACH_TREBON_HWREV != 0x0)","\t\"vbt\",","#endif","};","","static struct regulator *regulators_bahama[ARRAY_SIZE(regulators_bahama_name)];","","static int bahama_bt(int on)","{","","\tint rc = 0;","\tint i;","","\tstruct marimba config = { .mod_id =  SLAVE_ID_BAHAMA};","","\tstruct bahama_variant_register {","\t\tconst size_t size;","\t\tconst struct bahama_config_register *set;","\t};","","\tconst struct bahama_config_register *p;","","\tu8 version;","","\tconst struct bahama_config_register v10_bt_on[] = {","\t\t{ 0xE9, 0x00, 0xFF },","\t\t{ 0xF4, 0x80, 0xFF },","\t\t{ 0xE4, 0x00, 0xFF },","\t\t{ 0xE5, 0x00, 0x0F },","#ifdef CONFIG_WLAN","\t\t{ 0xE6, 0x38, 0x7F },","\t\t{ 0xE7, 0x06, 0xFF },","#endif","\t\t{ 0xE9, 0x21, 0xFF },","\t\t{ 0x01, 0x0C, 0x1F },","\t\t{ 0x01, 0x08, 0x1F },","\t};","","\tconst struct bahama_config_register v20_bt_on_fm_off[] = {","\t\t{ 0x11, 0x0C, 0xFF },","\t\t{ 0x13, 0x01, 0xFF },","\t\t{ 0xF4, 0x80, 0xFF },","\t\t{ 0xF0, 0x00, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF },","#ifdef CONFIG_WLAN","\t\t{ 0x81, 0x00, 0x7F },","\t\t{ 0x82, 0x00, 0xFF },","\t\t{ 0xE6, 0x38, 0x7F },","\t\t{ 0xE7, 0x06, 0xFF },","#endif","\t\t{ 0x8E, 0x15, 0xFF },","\t\t{ 0x8F, 0x15, 0xFF },","\t\t{ 0x90, 0x15, 0xFF },","","\t\t{ 0xE9, 0x21, 0xFF },","\t};","","\tconst struct bahama_config_register v20_bt_on_fm_on[] = {","\t\t{ 0x11, 0x0C, 0xFF },","\t\t{ 0x13, 0x01, 0xFF },","\t\t{ 0xF4, 0x86, 0xFF },","\t\t{ 0xF0, 0x06, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF },","#ifdef CONFIG_WLAN","\t\t{ 0x81, 0x00, 0x7F },","\t\t{ 0x82, 0x00, 0xFF },","\t\t{ 0xE6, 0x38, 0x7F },","\t\t{ 0xE7, 0x06, 0xFF },","#endif","\t\t{ 0xE9, 0x21, 0xFF },","\t};","","\tconst struct bahama_config_register v10_bt_off[] = {","\t\t{ 0xE9, 0x00, 0xFF },","\t};","","\tconst struct bahama_config_register v20_bt_off_fm_off[] = {","\t\t{ 0xF4, 0x84, 0xFF },","\t\t{ 0xF0, 0x04, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF }","\t};","","\tconst struct bahama_config_register v20_bt_off_fm_on[] = {","\t\t{ 0xF4, 0x86, 0xFF },","\t\t{ 0xF0, 0x06, 0xFF },","\t\t{ 0xE9, 0x00, 0xFF }","\t};","\tconst struct bahama_variant_register bt_bahama[2][3] = {","\t{","\t\t{ ARRAY_SIZE(v10_bt_off), v10_bt_off },","\t\t{ ARRAY_SIZE(v20_bt_off_fm_off), v20_bt_off_fm_off },","\t\t{ ARRAY_SIZE(v20_bt_off_fm_on), v20_bt_off_fm_on }","\t},","\t{","\t\t{ ARRAY_SIZE(v10_bt_on), v10_bt_on },","\t\t{ ARRAY_SIZE(v20_bt_on_fm_off), v20_bt_on_fm_off },","\t\t{ ARRAY_SIZE(v20_bt_on_fm_on), v20_bt_on_fm_on }","\t}","\t};","","\tu8 offset = 0; /* index into bahama configs */","\ton = on ? 1 : 0;","\tversion = marimba_read_bahama_ver(&config);","\tif ((int)version < 0 || version == BAHAMA_VER_UNSUPPORTED) {","\t\tdev_err(&msm_bt_power_device.dev, \"%s: Bahama \\","\t\t\t\tversion read Error, version = %d \\n\",","\t\t\t\t__func__, version);","\t\treturn -EIO;","\t}","","\tif (version == BAHAMA_VER_2_0) {","\t\tif (marimba_get_fm_status(&config))","\t\t\toffset = 0x01;","\t}","","\tp = bt_bahama[on][version + offset].set;","","\tdev_info(&msm_bt_power_device.dev,","\t\t\"%s: found version %d\\n\", __func__, version);","","\tfor (i = 0; i < bt_bahama[on][version + offset].size; i++) {","\t\tu8 value = (p+i)->value;","\t\trc = marimba_write_bit_mask(&config,","\t\t\t(p+i)->reg,","\t\t\t&value,","\t\t\tsizeof((p+i)->value),","\t\t\t(p+i)->mask);","\t\tif (rc < 0) {","\t\t\tdev_err(&msm_bt_power_device.dev,","\t\t\t\t\"%s: reg %x write failed: %d\\n\",","\t\t\t\t__func__, (p+i)->reg, rc);","\t\t\treturn rc;","\t\t}","\t\tdev_dbg(&msm_bt_power_device.dev,","\t\t\t\"%s: reg 0x%02x write value 0x%02x mask 0x%02x\\n\",","\t\t\t\t__func__, (p+i)->reg,","\t\t\t\tvalue, (p+i)->mask);","\t\tvalue = 0;","\t\trc = marimba_read_bit_mask(&config,","\t\t\t\t(p+i)->reg, &value,","\t\t\t\tsizeof((p+i)->value), (p+i)->mask);","\t\tif (rc < 0)","\t\t\tdev_err(&msm_bt_power_device.dev, \"%s marimba_read_bit_mask- error\",","\t\t\t\t\t__func__);","\t\tdev_dbg(&msm_bt_power_device.dev,","\t\t\t\"%s: reg 0x%02x read value 0x%02x mask 0x%02x\\n\",","\t\t\t\t__func__, (p+i)->reg,","\t\t\t\tvalue, (p+i)->mask);","\t}","\t/* Update BT Status */","\tif (on)","\t\tmarimba_set_bt_status(&config, true);","\telse","\t\tmarimba_set_bt_status(&config, false);","\treturn rc;","}","","static int bluetooth_switch_regulators(int on)","{","\tint i, rc = 0;","","\tfor (i = 0; i < ARRAY_SIZE(regulators_bahama_name); i++) {","\t\tif (!regulators_bahama[i]) {","\t\t\tpr_err(\"%s: regulator_get %s failed(%d)\\n\",","\t\t\t__func__, regulators_bahama_name[i], rc);","\t\t\tgoto regulator_fail;","\t\t}","","\t\trc = on ? regulator_set_voltage(regulators_bahama[i],","\t\t\t\t\ti ? 2900000 : 1800000,","\t\t\t\t\t\ti ? 2900000 : 1800000) : 0;","","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: regulator set level failed (%d)\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto regulator_set_voltage_fail;","\t\t}","","\t\trc = on ? regulator_enable(regulators_bahama[i]) :","\t\t\t  regulator_disable(regulators_bahama[i]);","","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: regulator %s %s failed(%d)\\n\",","\t\t\t\t__func__, regulators_bahama_name[i],","\t\t\t       on ? \"enable\" : \"disable\", rc);","\t\t\tgoto regulator_fail;","\t\t\t}","\t}","\treturn rc;","","regulator_fail:","\twhile (i) {","\t\tif (on)","\t\t\tregulator_disable(regulators_bahama[--i]);","\t\t}","regulator_set_voltage_fail:","\tregulator_put(regulators_bahama[0]);","\tregulator_put(regulators_bahama[1]);","\treturn rc;","}","","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","static int bluetooth_setup_ldo(unsigned gpio, int on)","{","\tint rc = 0;","","\tprintk(\"%s - %d : %s\\n\", __func__, gpio, on ? \"on\" : \"off\");","","\t// Request","\tif (gpio_request(gpio, \"bt_en_gpio\")) {","\t\tprintk(KERN_ERR \"%s: gpio_request for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","\tint temp = gpio_get_value(gpio);","       printk( \"%s:gpio_direction_output before(%d):: gpio_get_value=%d\\n\", __func__, on, temp);","","\trc = gpio_direction_output(gpio, on);","","        temp = gpio_get_value(gpio);","       printk( \"%s:gpio_direction_output after(%d):: gpio_get_value=%d\\n\", __func__, on, temp);","","\tgpio_free(gpio);","","\tif (rc) {","\t\tprintk(KERN_ERR \"%s: gpio_direction_output for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","\treturn 0;","}","#endif","","static unsigned int msm_bahama_setup_power(void)","{","\tprintk(\"%s -msm_bahama_setup_power\\n\", __func__);","","\tint rc = 0;","\tstruct regulator *regulator_s3 = NULL;","","\tregulator_s3 = regulator_get(NULL, \"vreg_msme\");","\tif (IS_ERR(regulator_s3)) {","\t\tpr_err(\"%s: regulator get failed (%ld)\\n\",","\t\t\t__func__, PTR_ERR(regulator_s3));","\t\treturn PTR_ERR(regulator_s3);","\t}","\trc = regulator_set_voltage(regulator_s3, 1800000, 1800000);","\tif (rc < 0) {","\t\tpr_err(\"%s: regulator set level failed (%d)\\n\",","\t\t\t\t__func__, rc);","\t\tgoto regulator_fail;","\t}","\trc = regulator_enable(regulator_s3);","\tif (rc < 0) {","\t\tpr_err(\"%s: regulator enable failed (%d)\\n\",","\t\t       __func__, rc);","\t\tgoto regulator_fail;","\t}","","\t/* Setup Bahama_sys_reset_n */","\trc = gpio_request(GPIO_BT_PWR, \"bahama sys_rst_n\");","\tif (rc < 0) {","\t\tpr_err(\"%s: gpio_request %d = %d\\n\", __func__,","\t\t\tGPIO_BT_PWR, rc);","\t\tgoto regulator_fail;","\t}","","\trc = bt_set_gpio(1);","\tif (rc < 0) {","\t\tpr_err(\"%s: bt_set_gpio %d = %d\\n\", __func__,","\t\t\tGPIO_BT_PWR, rc);","\t\tgoto gpio_fail;","\t}","\t//2011.07.06 qcomm - bt on failed","\tmsleep(100);","","\treturn rc;","","gpio_fail:","\tgpio_free(GPIO_BT_PWR);","regulator_fail:","\tregulator_put(regulator_s3);","\treturn rc;","}","","static unsigned int msm_bahama_shutdown_power(int value)","{","       printk(\"%s -msm_bahama_shutdown_power\\n\", __func__);","","\tint rc = 0;","\tstruct regulator *regulator_s3 = NULL;","","\tregulator_s3 = regulator_get(NULL, \"vreg_msme\");","\tif (IS_ERR(regulator_s3)) {","\t\tpr_err(\"%s: regulator get failed (%ld)\\n\",","\t\t\t__func__, PTR_ERR(regulator_s3));","\t\treturn PTR_ERR(regulator_s3);","\t}","\trc = regulator_disable(regulator_s3);","\tif (rc) {","\t\tpr_err(\"%s: regulator disable failed (%d)\\n\",","\t\t       __func__, rc);","\t\tregulator_put(regulator_s3);","\t\treturn rc;","\t}","","\tif (value == BAHAMA_ID) {","\t\trc = bt_set_gpio(0);","\t\tif (rc) {","\t\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t}","\t}","\treturn rc;","}","","static unsigned int msm_bahama_core_config(int type)","{","\tint rc = 0;","","\tif (type == BAHAMA_ID) {","\t\tint i;","\t\tstruct marimba config = { .mod_id = SLAVE_ID_BAHAMA };","\t\tconst struct bahama_config_register v20_init[] = {","\t\t\t/* reg, value, mask */","\t\t\t{ 0xF4, 0x84, 0xFF }, /* AREG */","\t\t\t{ 0xF0, 0x04, 0xFF } /* DREG */","\t\t};","\t\tif (marimba_read_bahama_ver(&config) == BAHAMA_VER_2_0) {","\t\t\tfor (i = 0; i < ARRAY_SIZE(v20_init); i++) {","\t\t\t\tu8 value = v20_init[i].value;","\t\t\t\trc = marimba_write_bit_mask(&config,","\t\t\t\t\tv20_init[i].reg,","\t\t\t\t\t&value,","\t\t\t\t\tsizeof(v20_init[i].value),","\t\t\t\t\tv20_init[i].mask);","\t\t\t\tif (rc < 0) {","\t\t\t\t\tpr_err(\"%s: reg %d write failed: %d\\n\",","\t\t\t\t\t\t__func__, v20_init[i].reg, rc);","\t\t\t\t\treturn rc;","\t\t\t\t}","\t\t\t\tpr_debug(\"%s: reg 0x%02x value 0x%02x\"","\t\t\t\t\t\" mask 0x%02x\\n\",","\t\t\t\t\t__func__, v20_init[i].reg,","\t\t\t\t\tv20_init[i].value, v20_init[i].mask);","\t\t\t}","\t\t}","\t}","\trc = bt_set_gpio(0);","\tif (rc) {","\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t       __func__, rc);","\t}","\tpr_debug(\"core type: %d\\n\", type);","\treturn rc;","}","","static int bluetooth_power(int on)","{","\tprintk(\"%s -bluetooth_power\\n\", __func__);","","\tint pin, rc = 0;","\tconst char *id = \"BTPW\";","\tint cid = 0;","","\tcid = adie_get_detected_connectivity_type();","\tif (cid != BAHAMA_ID) {","\t\tpr_err(\"%s: unexpected adie connectivity type: %d\\n\",","\t\t\t\t\t__func__, cid);","\t\treturn -ENODEV;","\t}","\tif (on) {","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\twlan_setup_ldo_33v(WLAN_33V_BT_FLAG, 1);","#endif","\t\t/* Setup power for BT SOC */","\t\trc = bt_set_gpio(on);","\t\tif (rc) {","\t\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto exit;","\t\t}","\t\trc = bluetooth_switch_regulators(on);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: bluetooth_switch_regulators rc = %d\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto exit;","\t\t}","","\t\t#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t\t if (bluetooth_setup_ldo(GPIO_BLUETOOTH_LDO,1))","\t\t {","\t\t\t\t\tpr_err(\"%s: GPIO_BLUETOOTH_LDO fail = %d\\n\",","\t\t\t\t\t\t\t__func__, GPIO_BLUETOOTH_LDO);","\t\t   return -ENODEV;","\t\t  }","\t\t\tmsleep(100);","\t\t#endif","\t\t/* Setup BT GPIO lines*/","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_power_on);","\t\t\tpin++) {","\t\t\trc = gpio_tlmm_config(bt_config_power_on[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t\t\t\t__func__,","\t\t\t\t\t\tbt_config_power_on[pin],","\t\t\t\t\t\trc);","\t\t\t\tgoto fail_power;","\t\t\t}","\t\t}","","\t\t/* Setup BT clocks */","\t\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\tPMAPP_CLOCK_VOTE_ON);","\t\tif (rc < 0) {","\t\t\tpr_err(\"Failed to vote for TCXO_D1 ON\\n\");","\t\t\tgoto fail_clock;","\t\t}","\t\tmsleep(20);","","\t\t/* I2C config for Bahama */","\t\trc = bahama_bt(1);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: bahama_bt rc = %d\", __func__, rc);","\t\t\tgoto fail_i2c;","\t\t}","\t\tmsleep(20);","","\t\t/* Setup BT PCM lines*/","\t\trc = msm_bahama_setup_pcm_i2s(BT_PCM_ON);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: msm_bahama_setup_pcm_i2s , rc =%d\\n\",","\t\t\t\t__func__, rc);","\t\t\t\tgoto fail_power;","\t\t\t}","\t\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\t\t  PMAPP_CLOCK_VOTE_PIN_CTRL);","\t\tif (rc < 0)","\t\t\tpr_err(\"%s:Pin Control Failed, rc = %d\",","\t\t\t\t\t__func__, rc);","","\t} else {","\t\trc = bahama_bt(0);","\t\tif (rc < 0)","\t\t\tpr_err(\"%s: bahama_bt rc = %d\", __func__, rc);","","\t\t#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t\t if (bluetooth_setup_ldo(GPIO_BLUETOOTH_LDO,0))","\t\t {","\t\t\t\t\tpr_err(\"%s: GPIO_BLUETOOTH_LDO fail = %d\\n\",","\t\t\t\t\t\t\t__func__, GPIO_BLUETOOTH_LDO);","\t\t   return -ENODEV;","\t\t  }","\t\t\tmsleep(100);","\t\t#endif","","\t\trc = bt_set_gpio(on);","\t\tif (rc) {","\t\t\tpr_err(\"%s: bt_set_gpio = %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t}","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\twlan_setup_ldo_33v(WLAN_33V_BT_FLAG, 0);","#endif","fail_i2c:","\t\trc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,","\t\t\t\t  PMAPP_CLOCK_VOTE_OFF);","\t\tif (rc < 0)","\t\t\tpr_err(\"%s: Failed to vote Off D1\\n\", __func__);","fail_clock:","\t\tfor (pin = 0; pin < ARRAY_SIZE(bt_config_power_off);","\t\t\tpin++) {","\t\t\t\trc = gpio_tlmm_config(bt_config_power_off[pin],","\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\t\tif (rc < 0) {","\t\t\t\t\tpr_err(\"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t\t\t__func__, bt_config_power_off[pin], rc);","\t\t\t\t}","\t\t\t}","\t\trc = msm_bahama_setup_pcm_i2s(BT_PCM_OFF);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: msm_bahama_setup_pcm_i2s, rc =%d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\t\t}","fail_power:","\t\trc = bluetooth_switch_regulators(0);","\t\tif (rc < 0) {","\t\t\tpr_err(\"%s: switch_regulators : rc = %d\",\\","\t\t\t\t\t__func__, rc);","\t\t\tgoto exit;","\t\t}","\t}","\treturn rc;","exit:","\tpr_err(\"%s: failed with rc = %d\", __func__, rc);","\treturn rc;","}","","static int __init bt_power_init(void)","{","\tint i, rc = 0;","\tfor (i = 0; i < ARRAY_SIZE(regulators_bahama_name); i++) {","\t\t\tregulators_bahama[i] = regulator_get(NULL,","\t\t\t\t\t\tregulators_bahama_name[i]);","\t\t\tif (IS_ERR(regulators_bahama[i])) {","\t\t\t\tpr_err(\"%s: regulator get %s failed (%ld)\\n\",","\t\t\t\t       __func__, regulators_bahama_name[i],","\t\t\t\t       PTR_ERR(regulators_bahama[i]));","\t\t\t\trc = PTR_ERR(regulators_bahama[i]);","\t\t\t\tgoto regulator_get_fail;","\t\t\t}","\t\t}","","\tmsm_bt_power_device.dev.platform_data = &bluetooth_power;","","\treturn rc;","","regulator_get_fail:","\twhile (i)","\t\tregulator_put(regulators_bahama[--i]);","\treturn rc;","}","","static struct marimba_platform_data marimba_pdata = {","\t.slave_id[SLAVE_ID_BAHAMA_FM]        = BAHAMA_SLAVE_ID_FM_ADDR,","\t.slave_id[SLAVE_ID_BAHAMA_QMEMBIST]  = BAHAMA_SLAVE_ID_QMEMBIST_ADDR,","\t.bahama_setup                        = msm_bahama_setup_power,","\t.bahama_shutdown                     = msm_bahama_shutdown_power,","\t.bahama_core_config                  = msm_bahama_core_config,","\t.fm\t\t\t\t     = &marimba_fm_pdata,","};","","#endif","","#if defined(CONFIG_I2C) && defined(CONFIG_GPIO_SX150X)","static struct i2c_board_info core_exp_i2c_info[] __initdata = {","\t{","\t\tI2C_BOARD_INFO(\"sx1509q\", 0x3e),","\t\t.platform_data =  &sx150x_data[SX150X_CORE],","\t},","};","static struct i2c_board_info cam_exp_i2c_info[] __initdata = {","\t{","\t\tI2C_BOARD_INFO(\"sx1508q\", 0x22),","\t\t.platform_data\t= &sx150x_data[SX150X_CAM],","\t},","};","#endif","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","#ifdef CONFIG_PROXIMITY_SENSOR","static int gp2a_power(bool on)","{","/*","\tstruct regulator *regulator;","","\tldo15_init_data.constraints.state_mem.enabled = on;","\tldo15_init_data.constraints.state_mem.disabled = !on;","","\tif (on) {","\t\tregulator = regulator_get(NULL, \"vled\");","\t\tif (IS_ERR(regulator))","\t\t\treturn 0;","\t\tregulator_enable(regulator);","\t\tregulator_put(regulator);","\t} else {","\t\tregulator = regulator_get(NULL, \"vled\");","\t\tif (IS_ERR(regulator))","\t\t\treturn 0;","\t\tif (regulator_is_enabled(regulator))","\t\t\tregulator_force_disable(regulator);","\t\tregulator_put(regulator);","\t}","*/","","#if defined(CONFIG_MACH_TREBON)","\tint rc = 0;","\tif (board_hw_revision >= 0x06) {","\t\tif (proximity_init == false) {","\t\t\tpr_info(\"[GP2A] board hw revision %d\\n\",","\t\t\t\tboard_hw_revision);","\t\t\tstruct pm8xxx_gpio_rpc_cfg gpio_cfg = {","\t\t\t\t.gpio  = PMIC_GPIO_11,","\t\t\t\t.mode  = OUTPUT_ON,","\t\t\t\t.src_pull = PULL_UP_1_5uA,","\t\t\t\t.volt_src = PMIC_GPIO_VIN2,","\t\t\t\t.buf_config = CONFIG_CMOS,","\t\t\t};","","\t\t\trc = pmic_gpio_config(&gpio_cfg);","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"%s pmic gpio config failed %d \",","\t\t\t\t\t__func__,","\t\t\t\t\trc);","\t\t\t}","\t\t\tpmic_gpio_direction_output(PMIC_GPIO_11);","\t\t\tproximity_init = true;","\t\t\tgpio_tlmm_config(","\t\t\t\tGPIO_CFG(29, 0,","\t\t\t\t\tGPIO_CFG_INPUT,","\t\t\t\t\tGPIO_CFG_PULL_UP,","\t\t\t\t\tGPIO_CFG_2MA),","\t\t\t\tGPIO_CFG_ENABLE);","\t\t}","","\t\tif (on) {","\t\t\tpr_err(\"%s pmic gpio set to 1 \",","\t\t\t\t__func__);","\t\t\trc = pmic_gpio_set_value(PMIC_GPIO_11, 1);","\t\t\tif (rc < 0)","\t\t\t\tpr_err(\"%s pmic gpio set 1 error \",","\t\t\t\t\t__func__);","\t\t} else {","\t\t\tpr_err(\"%s pmic gpio set to 0 \",","\t\t\t\t__func__);","\t\t\trc = pmic_gpio_set_value(PMIC_GPIO_11, 0);","\t\t\tif (rc < 0)","\t\t\t\tpr_err(\"%s pmic gpio set 0 error \",","\t\t\t\t\t__func__);","\t\t}","\t} else {","\t\tgpio_tlmm_config(","\t\t\tGPIO_CFG(29, 0,","\t\t\t\tGPIO_CFG_INPUT,","\t\t\t\tGPIO_CFG_PULL_UP,","\t\t\t\tGPIO_CFG_2MA),","\t\t\tGPIO_CFG_ENABLE);","\t}","#else","\tgpio_tlmm_config(","\t\tGPIO_CFG(29, 0,","\t\t\tGPIO_CFG_INPUT,","\t\t\tGPIO_CFG_PULL_UP,","\t\t\tGPIO_CFG_2MA),","\t\tGPIO_CFG_ENABLE);","#endif","","\treturn 0;","}","","static struct gp2a_platform_data gp2a_pdata = {","\t.p_out = 29,","\t.power = gp2a_power,","};","#endif","","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","static struct i2c_board_info bahama_devices[] = {","{","\tI2C_BOARD_INFO(\"marimba\", 0xc),","\t.platform_data = &marimba_pdata,","},","};","","static struct i2c_board_info sensor_devices[] = {","\t#ifdef CONFIG_SENSORS_HSCD","{","\tI2C_BOARD_INFO(\"bma222\", 0x08),","},","{","\tI2C_BOARD_INFO(\"bma222e\", 0x18),","},","{","\tI2C_BOARD_INFO(\"hscd_i2c\", 0x0d),","},","\t#endif","\t#ifdef CONFIG_PROXIMITY_SENSOR","{","\tI2C_BOARD_INFO(\"gp2a\", 0x44 ),","\t.platform_data = &gp2a_pdata,","},","\t#endif","};","","\t#if defined(CONFIG_SENSORS_HSCD) || defined(CONFIG_PROXIMITY_SENSOR)","static struct i2c_gpio_platform_data sensor_i2c_gpio_data = {","\t.sda_pin = GPIO_SENSOR_SDA,","\t.scl_pin = GPIO_SENSOR_SCL,","\t.udelay = 1,","};","","static struct platform_device sensor_i2c_gpio_device = {","\t.name =\"i2c-gpio\",","\t.id = 4,","\t.dev = {","\t\t.platform_data =&sensor_i2c_gpio_data,","\t},","};","\t#endif","#else","static struct i2c_board_info bahama_devices[] = {","{","\tI2C_BOARD_INFO(\"marimba\", 0xc),","\t.platform_data = &marimba_pdata,","},","\t#ifdef CONFIG_SENSORS_HSCD","{","\tI2C_BOARD_INFO(\"accsns_i2c\", 0x08),","},","{","\tI2C_BOARD_INFO(\"hscd_i2c\", 0x0d),","},","\t#endif","\t#ifdef CONFIG_PROXIMITY_SENSOR","{","\tI2C_BOARD_INFO(\"gp2a\", 0x44 ),","\t.platform_data = &gp2a_pdata,","},","\t#endif","};","#endif","#endif","","static struct platform_device msm_device_pmic_leds = {","\t.name\t= \"pmic-leds\",","\t.id\t\t= -1,","};","","static struct platform_device msm_vibrator_device = {","\t.name\t= \"msm_vibrator\",","\t.id\t\t= -1,","};","","static struct i2c_gpio_platform_data touch_i2c_gpio_data = {","\t.sda_pin    = GPIO_TSP_SDA,","\t.scl_pin    = GPIO_TSP_SCL,","\t.udelay\t= 1,","};","","static struct platform_device touch_i2c_gpio_device = {","\t.name       = \"i2c-gpio\",","\t.id     =  2,","\t.dev        = {","\t\t.platform_data  = &touch_i2c_gpio_data,","\t},","};","","/* I2C 2 */","static struct i2c_board_info touch_i2c_devices[] = {","\t{","\t\tI2C_BOARD_INFO(\"zinitix_isp\", 0x50),","\t},","\t{","\t\tI2C_BOARD_INFO(\"sec_touchscreen\", 0x20),","\t        .irq = MSM_GPIO_TO_INT( GPIO_TOUCH_IRQ ),","\t},","};","","struct msm_battery_callback *charger_callbacks;","static enum cable_type_t set_cable_status;","static enum acc_type_t set_acc_status;","static enum ovp_type_t set_ovp_status;","","static void msm_battery_register_callback(","\t\tstruct msm_battery_callback *ptr)","{","\tcharger_callbacks = ptr;","\tpr_info(\"[BATT] msm_battery_register_callback start\\n\");","\tif ((set_acc_status != 0) && charger_callbacks","\t\t&& charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","","\tif ((set_cable_status != 0) && charger_callbacks","\t\t&& charger_callbacks->set_cable)","\t\tcharger_callbacks->set_cable(charger_callbacks,","\t\tset_cable_status);","","\tif ((set_ovp_status != 0) && charger_callbacks","\t\t&& charger_callbacks->set_ovp_type)","\t\tcharger_callbacks->set_ovp_type(charger_callbacks,","\t\tset_ovp_status);","}","","static u32 msm_calculate_batt_capacity(u32 current_voltage);","","static struct msm_charger_data aries_charger = {","\t.register_callbacks\t= msm_battery_register_callback,","};","","static struct msm_psy_batt_pdata msm_psy_batt_data = {","\t.charger\t\t\t= &aries_charger,","\t.voltage_min_design\t\t= 2800,","\t.voltage_max_design\t= 4300,","\t.avail_chg_sources\t\t= AC_CHG | USB_CHG ,","\t.batt_technology\t\t= POWER_SUPPLY_TECHNOLOGY_LION,","};","","static struct platform_device msm_batt_device = {","\t.name\t\t= \"msm-battery\",","\t.id\t\t= -1,","\t.dev.platform_data\t= &msm_psy_batt_data,","};","","int fsa_cable_type = CABLE_TYPE_UNKNOWN;","int fsa880_get_charger_status(void);","int fsa880_get_charger_status(void)","{","\treturn fsa_cable_type;","}","","static void jena_usb_power(int onoff, char *path) { }","","void trebon_chg_connected(enum chg_type chgtype)","{","\tchar *chg_types[] = {","\t\t    \"STD DOWNSTREAM PORT\",","\t\t\t\"CARKIT\",","\t\t\t\"DEDICATED CHARGER\",","\t\t\t\"INVALID\"};","\tunsigned *data1 = NULL;","\tunsigned *data2 = NULL;","\tint ret = 0;","","\tswitch (chgtype) {","\tcase USB_CHG_TYPE__SDP:","#ifdef CONFIG_FORCE_FAST_CHARGE","    \tif (force_fast_charge == 1)","\t\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_CHARGER_CONNECTED, ","\t\t\t\tdata1, data2);","\t\telse","#endif","\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_PC_CONNECTED, ","\t\t\tdata1, data2);","\t\tbreak;","\tcase USB_CHG_TYPE__WALLCHARGER:","\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_CHARGER_CONNECTED,","\t\t\t\tdata1, data2);","\t\tbreak;","\tcase USB_CHG_TYPE__INVALID:","\t\tret = msm_proc_comm(PCOM_CHG_USB_IS_DISCONNECTED,","\t\t\t\tdata1, data2);","\t\tbreak;","\tdefault:","\t\tbreak;","\t}","","\tif (ret < 0)","\t\tpr_err(\"%s: connection err, ret=%d\\n\", __func__, ret);","","\tpr_info(\"\\nCharger Type: %s\\n\", chg_types[chgtype]);","}","","static void jena_usb_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] [%s] Board file [FSA880]: USB Callback\\n\", __func__);","","\tset_acc_status = attached ? ACC_TYPE_USB : ACC_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","","\tset_cable_status = attached ? CABLE_TYPE_USB : CABLE_TYPE_UNKNOWN;","\tif (charger_callbacks && charger_callbacks->set_cable)","\t\tcharger_callbacks->set_cable(charger_callbacks,","\t\tset_cable_status);","}","","static void jena_charger_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] Board file [FSA880]: Charger Callback\\n\");","","\tset_acc_status = attached ? ACC_TYPE_CHARGER : ACC_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","","\tset_cable_status = attached ? CABLE_TYPE_TA : CABLE_TYPE_UNKNOWN;","\tif (charger_callbacks && charger_callbacks->set_cable)","\t\tcharger_callbacks->set_cable(charger_callbacks,","\t\tset_cable_status);","}","","static void jena_jig_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] Board file [FSA880]: Jig Callback\\n\");","","\tset_acc_status = attached ? ACC_TYPE_JIG : ACC_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_acc_type)","\t\tcharger_callbacks->set_acc_type(charger_callbacks,","\t\tset_acc_status);","}","","static void jena_ovp_cb(u8 attached, struct fsausb_ops *ops)","{","\tpr_info(\"[BATT] Board file [FSA880]: OVP Callback\\n\");","","\tset_ovp_status = attached ? OVP_TYPE_OVP : OVP_TYPE_NONE;","\tif (charger_callbacks && charger_callbacks->set_ovp_type)","\t\tcharger_callbacks->set_ovp_type(charger_callbacks,","\t\tset_ovp_status);","}","","/* check charger cable type for USB phy off */","static int checkChargerType()","{","\treturn set_cable_status;","}","","static void jena_fsa880_reset_cb(void)","{","\tpr_info(\" [BATT] Board file [FSA880]: Reset Callback\\n\");","}","","/* For uUSB Switch */","static struct fsausb_platform_data jena_fsa880_pdata = {","       .intb_gpio      = MSM_GPIO_TO_INT(GPIO_MUSB_INT),","       .usb_cb         = jena_usb_cb,","       .uart_cb        = NULL,","       .charger_cb     = jena_charger_cb,","       .jig_cb         = jena_jig_cb,","\t.ovp_cb\t\t= jena_ovp_cb,","       .reset_cb       = jena_fsa880_reset_cb,","};","","/* I2C 3 */","static struct i2c_gpio_platform_data fsa880_i2c_gpio_data = {","\t.sda_pin    = GPIO_MUS_SDA,","\t.scl_pin    = GPIO_MUS_SCL,","};","","static struct platform_device fsa880_i2c_gpio_device = {","\t.name       = \"i2c-gpio\",","\t.id     =  3,","\t.dev        = {","\t\t.platform_data  = &fsa880_i2c_gpio_data,","\t},","};","","static struct i2c_board_info fsa880_i2c_devices[] = {","\t{","\t\tI2C_BOARD_INFO(\"FSA9280\", 0x4A >> 1),","\t\t.platform_data =  &jena_fsa880_pdata,","\t\t.irq = MSM_GPIO_TO_INT(GPIO_MUSB_INT),","\t},","};","","#ifdef CONFIG_BQ27425_FUEL_GAUGE","/* Fuel_gauge */","static struct i2c_gpio_platform_data fuelgauge_i2c_gpio_data = {","\t.sda_pin = FUEL_I2C_SDA,","\t.scl_pin = FUEL_I2C_SCL,","};","","static struct platform_device fuelgauge_i2c_gpio_device = {","\t.name\t= \"i2c-gpio\",","\t.id\t= 6,","\t.dev\t= {","\t.platform_data\t= &fuelgauge_i2c_gpio_data,","\t},","};","static struct i2c_board_info fg_i2c_devices[] = {","\t{","\t\tI2C_BOARD_INFO( \"bq27425\", 0xAA>>1 ),","\t},","};","#endif","","static void __init register_i2c_devices(void)","{","#if defined(CONFIG_I2C) && defined(CONFIG_GPIO_SX150X)","\ti2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,","\t\t\t\tcam_exp_i2c_info,","\t\t\t\tARRAY_SIZE(cam_exp_i2c_info));","","\tif (machine_is_msm7x27a_surf())","\t\tsx150x_data[SX150X_CORE].io_open_drain_ena = 0xe0f0;","","\tcore_exp_i2c_info[0].platform_data =","\t\t\t&sx150x_data[SX150X_CORE];","","\ti2c_register_board_info(MSM_GSBI1_QUP_I2C_BUS_ID,","\t\t\t\tcore_exp_i2c_info,","\t\t\t\tARRAY_SIZE(core_exp_i2c_info));","#endif","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","\ti2c_register_board_info(MSM_GSBI1_QUP_I2C_BUS_ID,","\t\t\t\tbahama_devices,","\t\t\t\tARRAY_SIZE(bahama_devices));","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t#if defined(CONFIG_SENSORS_HSCD) || defined(CONFIG_PROXIMITY_SENSOR)","\ti2c_register_board_info(4, sensor_devices, ARRAY_SIZE(sensor_devices));","\t#endif","#endif","#endif","}","","static struct msm_gpio qup_i2c_gpios_io[] = {","\t{ GPIO_CFG(60, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(61, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_sda\" },","\t{ GPIO_CFG(131, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(132, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\"qup_sda\" },","};","","static struct msm_gpio qup_i2c_gpios_hw[] = {","\t{ GPIO_CFG(60, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(61, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_sda\" },","\t{ GPIO_CFG(131, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_scl\" },","\t{ GPIO_CFG(132, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\"qup_sda\" },","};","","static void gsbi_qup_i2c_gpio_config(int adap_id, int config_type)","{","\tint rc;","","\tif (adap_id < 0 || adap_id > 1)","\t\treturn;","","\t/* Each adapter gets 2 lines from the table */","\tif (config_type)","\t\trc = msm_gpios_request_enable(&qup_i2c_gpios_hw[adap_id*2], 2);","\telse","\t\trc = msm_gpios_request_enable(&qup_i2c_gpios_io[adap_id*2], 2);","\tif (rc < 0)","\t\tpr_err(\"QUP GPIO request/enable failed: %d\\n\", rc);","}","","static struct msm_i2c_platform_data msm_gsbi0_qup_i2c_pdata = {","\t.clk_freq\t\t= 100000,","\t.msm_i2c_config_gpio\t= gsbi_qup_i2c_gpio_config,","};","","static struct msm_i2c_platform_data msm_gsbi1_qup_i2c_pdata = {","\t.clk_freq\t\t= 100000,","\t.msm_i2c_config_gpio\t= gsbi_qup_i2c_gpio_config,","};","","#ifdef CONFIG_ARCH_MSM7X27A","#define MSM_PMEM_MDP_SIZE       0x1800000 //25MB default: 0x1DD1000 (29MB)","#define MSM7x25A_MSM_PMEM_MDP_SIZE       0x1500000 //22MB","","#define MSM_PMEM_ADSP_SIZE      0x900000 // ~9MB","#define MSM_ION_VIDC_SIZE       0x1200000 // 18MB","#define MSM7x25A_MSM_PMEM_ADSP_SIZE      0xB91000 //12MB","","#ifdef CONFIG_FB_MSM_TRIPLE_BUFFER","#define MSM_FB_SIZE\t\t0x1C2000","#define MSM7x25A_MSM_FB_SIZE    0x1C2000","#define MSM8x25_MSM_FB_SIZE\t0x1C2000","#else","#define MSM_FB_SIZE\t\t0x1C2000","#define MSM7x25A_MSM_FB_SIZE\t0x12C000","#define MSM8x25_MSM_FB_SIZE\t0x1C2000","#endif","#endif","","#ifdef CONFIG_ION_MSM","#define MSM_ION_HEAP_NUM        4","static struct platform_device ion_dev;","static int msm_ion_camera_size;","static int msm_ion_audio_size;","static int msm_ion_sf_size;","#endif","","","static struct android_usb_platform_data android_usb_pdata = {","\t.update_pid_and_serial_num = usb_diag_update_pid_and_serial_num,","};","","static struct platform_device android_usb_device = {","\t.name\t= \"android_usb\",","\t.id\t= -1,","\t.dev\t= {","\t\t.platform_data = &android_usb_pdata,","\t},","};","","static int __init boot_mode_boot(char *onoff)","{","\tif (strncmp(onoff, \"batt\", 5) == 0) {","\t\tcharging_boot = 1;","\t\tfota_boot = 0;","\t\tpr_info(\"%s[BATT]charging_boot: %d\\n\",","\t\t\t__func__, charging_boot);","\t} else if (strncmp(onoff, \"fota\", 5) == 0) {","\t\tfota_boot = 1;","\t\tcharging_boot = 0;","\t} else {","\t\tcharging_boot = 0;","\t\tfota_boot = 0;","\t}","\treturn 1;","}","__setup(\"androidboot.boot_pause=\", boot_mode_boot);","","","#ifdef CONFIG_USB_EHCI_MSM_72K","static void msm_hsusb_vbus_power(unsigned phy_info, int on)","{","\tint rc = 0;","\tunsigned gpio;","","\tgpio = GPIO_HOST_VBUS_EN;","","\t\trc = gpio_request(gpio, \"i2c_host_vbus_en\");","\t\tif (rc < 0) {","\t\t\tpr_err(\"failed to request %d GPIO\\n\", gpio);","\t\t\treturn;","\t\t}","\tgpio_direction_output(gpio, !!on);","\tgpio_set_value_cansleep(gpio, !!on);","\tgpio_free(gpio);","}","","static struct msm_usb_host_platform_data msm_usb_host_pdata = {","\t.phy_info       = (USB_PHY_INTEGRATED | USB_PHY_MODEL_45NM),","};","","static void __init msm7x2x_init_host(void)","{","\tmsm_add_host(0, &msm_usb_host_pdata);","}","#endif","","#ifdef CONFIG_USB_MSM_OTG_72K","static int hsusb_rpc_connect(int connect)","{","\tif (connect)","\t\treturn msm_hsusb_rpc_connect();","\telse","\t\treturn msm_hsusb_rpc_close();","}","","static struct regulator *reg_hsusb;","static int msm_hsusb_ldo_init(int init)","{","\tint rc = 0;","","\tif (init) {","\t\treg_hsusb = regulator_get(NULL, \"usb\");","\t\tif (IS_ERR(reg_hsusb)) {","\t\t\trc = PTR_ERR(reg_hsusb);","\t\t\tpr_err(\"%s: sandeep could not get regulator: %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto out;","\t\t}","","\t\trc = regulator_set_voltage(reg_hsusb, 3300000, 3300000);","\t\tif (rc) {","\t\t\tpr_err(\"%s:sandeep could not set voltage: %d\\n\",","\t\t\t\t\t__func__, rc);","\t\t\tgoto reg_free;","\t\t}","","\t\treturn 0;","\t}","\t/* else fall through */","reg_free:","\tregulator_put(reg_hsusb);","out:","\treg_hsusb = NULL;","\treturn rc;","}","","static int msm_hsusb_ldo_enable(int enable)","{","\tstatic int ldo_status;","","\tif (IS_ERR_OR_NULL(reg_hsusb))","\t\treturn reg_hsusb ? PTR_ERR(reg_hsusb) : -ENODEV;","","\tif (ldo_status == enable)","\t\treturn 0;","","\tldo_status = enable;","","\treturn enable ?","\t\tregulator_enable(reg_hsusb) :","\t\tregulator_disable(reg_hsusb);","}","","#ifndef CONFIG_USB_EHCI_MSM_72K","static int msm_hsusb_pmic_notif_init(void (*callback)(int online), int init)","{","\tint ret = 0;","","\tif (init)","\t\tret = msm_pm_app_rpc_init(callback);","\telse","\t\tmsm_pm_app_rpc_deinit(callback);","","\treturn ret;","}","#endif","","static struct msm_otg_platform_data msm_otg_pdata = {","#ifndef CONFIG_USB_EHCI_MSM_72K","\t.pmic_vbus_notif_init\t = msm_hsusb_pmic_notif_init,","#else","\t.vbus_power\t\t = msm_hsusb_vbus_power,","#endif","\t.rpc_connect\t\t = hsusb_rpc_connect,","\t.pemp_level\t\t = PRE_EMPHASIS_WITH_20_PERCENT,","\t.cdr_autoreset\t\t = CDR_AUTO_RESET_DISABLE,","\t.drv_ampl\t\t = HS_DRV_AMPLITUDE_75_PERCENT,","\t.se1_gating\t\t = SE1_GATING_DISABLE,","\t.ldo_init\t\t = msm_hsusb_ldo_init,","\t.ldo_enable\t\t = msm_hsusb_ldo_enable,","\t.chg_init\t\t = hsusb_chg_init,","\t/* check charger cable type for USB phy off */","\t.chg_connect_type = checkChargerType,","\t/*  \t\t\t\t\t\t\t\t\t\t*/","\t.chg_connected\t\t = hsusb_chg_connected,","\t.chg_vbus_draw\t\t = hsusb_chg_vbus_draw,","};","#endif","","static struct msm_hsusb_gadget_platform_data msm_gadget_pdata = {","\t.is_phy_status_timer_on = 1,","};","","static struct resource smc91x_resources[] = {","\t[0] = {","\t\t.start = 0x90000300,","\t\t.end   = 0x900003ff,","\t\t.flags = IORESOURCE_MEM,","\t},","\t[1] = {","\t\t.start = MSM_GPIO_TO_INT(4),","\t\t.end   = MSM_GPIO_TO_INT(4),","\t\t.flags = IORESOURCE_IRQ,","\t},","};","","static struct platform_device smc91x_device = {","\t.name           = \"smc91x\",","\t.id             = 0,","\t.num_resources  = ARRAY_SIZE(smc91x_resources),","\t.resource       = smc91x_resources,","};","","#define WLAN_HOST_WAKE","","","#ifdef WLAN_HOST_WAKE","struct wlansleep_info {","\tunsigned host_wake;","\tunsigned host_wake_irq;","\tstruct wake_lock wake_lock;","};","","","static struct wlansleep_info *wsi;","static struct tasklet_struct hostwake_task;","","","static void wlan_hostwake_task(unsigned long data)","{","\tprintk(KERN_INFO \"WLAN: wake lock timeout 0.5 sec...\\n\");","\twake_lock_timeout(&wsi->wake_lock, HZ / 2);","}","","","static irqreturn_t wlan_hostwake_isr(int irq, void *dev_id)","{","\t/* schedule a tasklet to handle the change in the host wake line */","\ttasklet_schedule(&hostwake_task);","\treturn IRQ_HANDLED;","}","","","static int wlan_host_wake_init(void)","{","\tint ret;","","\twsi = kzalloc(sizeof(struct wlansleep_info), GFP_KERNEL);","\tif (!wsi)","\t\treturn -ENOMEM;","","\twake_lock_init(&wsi->wake_lock, WAKE_LOCK_SUSPEND, \"bluesleep\");","\ttasklet_init(&hostwake_task, wlan_hostwake_task, 0);","","\twsi->host_wake = GPIO_WLAN_HOST_WAKE;","\twsi->host_wake_irq = MSM_GPIO_TO_INT(wsi->host_wake);","","\tret = request_irq(wsi->host_wake_irq, wlan_hostwake_isr,","\t\t\t\t\t\tIRQF_DISABLED | IRQF_TRIGGER_RISING,","\t\t\t\t\t\t\"wlan hostwake\", NULL);","\tif (ret < 0) {","\t\tprintk(KERN_ERR \"WLAN: Couldn't acquire WLAN_HOST_WAKE IRQ\");","\t\treturn -1;","\t}","","\tret = enable_irq_wake(wsi->host_wake_irq);","\tif (ret < 0) {","\t\tprintk(KERN_ERR \"WLAN: Couldn't enable WLAN_HOST_WAKE as wakeup interrupt\");","\t\tfree_irq(wsi->host_wake_irq, NULL);","\t\treturn -1;","\t}","","\treturn 0;","}","","","static void wlan_host_wake_exit(void)","{","\tif (disable_irq_wake(wsi->host_wake_irq))","\t\tprintk(KERN_ERR \"WLAN: Couldn't disable hostwake IRQ wakeup mode \\n\");","","\tfree_irq(wsi->host_wake_irq, NULL);","","\twake_lock_destroy(&wsi->wake_lock);","\tkfree(wsi);","}","#endif /* WLAN_HOST_WAKE */","","","static int wlan_set_gpio(unsigned gpio, int on)","{","\tint rc = 0;","\tint gpio_value = 0;","","\tprintk(\"%s - %d : %s\\n\", __func__, gpio, on ? \"on\" : \"off\");","","\t// Request","\tif (gpio_request(gpio, \"wlan_ar6000_pm\")) {","\t\tprintk(KERN_ERR \"%s: gpio_request for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","","\tgpio_value = gpio_get_value(gpio);","\tprintk(KERN_INFO \"%s: before (%d) :: gpio_get_value = %d\",","\t\t\t__func__, on, gpio_value);","","\t// Direction Output On/Off","\trc = gpio_direction_output(gpio, on);","\tgpio_free(gpio);","","\tgpio_value = gpio_get_value(gpio);","\tprintk(KERN_INFO \"%s: after (%d) :: gpio_get_value = %d\",","\t\t\t__func__, on, gpio_value);","","\tif (rc) {","\t\tprintk(KERN_ERR \"%s: gpio_direction_output for %d failed\\n\",","\t\t\t\t__func__, gpio);","\t\treturn -1;","\t}","","\treturn 0;","}","","","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","int wlan_setup_ldo_33v(int input_flag, int on)","{","\tint skip = 0;","\tint temp_flag = wlan_33v_flag;","","\tprintk(KERN_INFO \"%s - set by %s : %s\\n\",","\t\t\t__func__,","\t\t\t(input_flag == WLAN_33V_WIFI_FLAG) ? \"Wifi\" : \"BT\",","\t\t\ton ? \"on\" : \"off\");","\tprintk(KERN_INFO \"%s - old wlan_33v_flag : %d\\n\",","\t\t\t__func__, temp_flag);","","\tif (on) {","\t\tif (temp_flag)  /* Already On */","\t\t\tskip = 1;","","\t\ttemp_flag |= input_flag;","\t} else {","\t\ttemp_flag &= (~input_flag);","","\t\t/* Keep GPIO_WLAN_33V_EN on if either BT or Wifi is turned on*/","\t\tif (temp_flag)","\t\t\tskip = 1;","\t}","","\tprintk(KERN_INFO \"%s - new wlan_33v_flag : %d\\n\",","\t\t\t__func__, temp_flag);","","\tif (skip) {","\t\tprintk(KERN_INFO \"%s - Skip GPIO_WLAN_33V_EN %s\\n\",","\t\t\t\t__func__, on ? \"on\" : \"off\");","\t} else {","\t\t/* GPIO_WLAN_33V_EN - On / Off */","\t\tif (wlan_set_gpio(GPIO_WLAN_33V_EN, on))","\t\t\treturn WLAN_ERROR;","\t}","","\twlan_33v_flag = temp_flag;","","\treturn WLAN_OK;","}","#endif","","void wlan_setup_power(int on, int detect)","{","\tprintk(\"%s %s --enter\\n\", __func__, on ? \"on\" : \"down\");","","\tif (on) {","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\t/* GPIO_WLAN_33V_EN - On */","\t\tif (wlan_setup_ldo_33v(WLAN_33V_WIFI_FLAG, 1))","\t\t\treturn;","#endif","\t\tudelay(120);","","\t\t// GPIO_WLAN_RESET_N - On","\t\tif (wlan_set_gpio(GPIO_WLAN_RESET_N, 1))","\t\t\treturn;","","#ifdef WLAN_HOST_WAKE","\t\twlan_host_wake_init();","#endif /* WLAN_HOST_WAKE */","\t}","\telse {","#ifdef WLAN_HOST_WAKE","\t\twlan_host_wake_exit();","#endif /* WLAN_HOST_WAKE */","","\t\t// GPIO_WLAN_RESET_N - Off","\t\tif (wlan_set_gpio(GPIO_WLAN_RESET_N, 0))","\t\t\treturn;","","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\t\t/* GPIO_WLAN_33V_EN - Off */","\t\tif (wlan_setup_ldo_33v(WLAN_33V_WIFI_FLAG, 0))","\t\t\treturn;","#endif","\t}","","#ifndef ATH_POLLING","\tmdelay(100);","","\tif (detect) {","\t\t/* Detect card */","\t\tif (wlan_status_notify_cb)","\t\t\twlan_status_notify_cb(on, wlan_devid);","\t\telse","\t\t\tprintk(KERN_ERR \"WLAN: No notify available\\n\");","\t}","#endif /* ATH_POLLING */","}","EXPORT_SYMBOL(wlan_setup_power);","EXPORT_SYMBOL(board_hw_revision);","","","static int wlan_power_init(void)","{","#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA","\twlan_33v_flag = 0;","#endif","","\t/* Set config - GPIO_WLAN_33V_EN */","\tif (gpio_tlmm_config(GPIO_CFG(GPIO_WLAN_33V_EN, 0,","\t\t\tGPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP,","\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE)) {","\t\tprintk(KERN_ERR \"%s: gpio_tlmm_config for %d failed\\n\",","\t\t\t\t__func__, GPIO_WLAN_33V_EN);","\t\treturn WLAN_ERROR;","\t}","","\treturn WLAN_OK;","}","","#if (defined(CONFIG_MMC_MSM_SDC1_SUPPORT)\\","\t|| defined(CONFIG_MMC_MSM_SDC2_SUPPORT)\\","\t|| defined(CONFIG_MMC_MSM_SDC3_SUPPORT)\\","\t|| defined(CONFIG_MMC_MSM_SDC4_SUPPORT))","","static unsigned long vreg_sts, gpio_sts;","static struct vreg *vreg_mmc;","static struct vreg *vreg_emmc;","","struct sdcc_vreg {","\tstruct vreg *vreg_data;","\tunsigned level;","};","","static struct sdcc_vreg sdcc_vreg_data[4];","","struct sdcc_gpio {","\tstruct msm_gpio *cfg_data;","\tuint32_t size;","\tstruct msm_gpio *sleep_cfg_data;","};","","/**"," * Due to insufficient drive strengths for SDC GPIO lines some old versioned"," * SD/MMC cards may cause data CRC errors. Hence, set optimal values"," * for SDC slots based on timing closure and marginality. SDC1 slot"," * require higher value since it should handle bad signal quality due"," * to size of T-flash adapters."," */","static struct msm_gpio sdc1_cfg_data[] = {","\t{GPIO_CFG(51, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_3\"},","\t{GPIO_CFG(52, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_2\"},","\t{GPIO_CFG(53, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_1\"},","\t{GPIO_CFG(54, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_dat_0\"},","\t{GPIO_CFG(55, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_cmd\"},","\t{GPIO_CFG(56, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_14MA),","\t\t\t\t\t\t\t\t\"sdc1_clk\"},","};","","static struct msm_gpio sdc2_cfg_data[] = {","\t{GPIO_CFG(62, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\t\t\t\t\t\t\"sdc2_clk\"},","\t{GPIO_CFG(63, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_cmd\"},","\t{GPIO_CFG(64, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_3\"},","\t{GPIO_CFG(65, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_2\"},","\t{GPIO_CFG(66, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_1\"},","\t{GPIO_CFG(67, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_0\"},","};","","static struct msm_gpio sdc2_sleep_cfg_data[] = {","\t{GPIO_CFG(62, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_clk\"},","\t{GPIO_CFG(63, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_cmd\"},","\t{GPIO_CFG(64, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_3\"},","\t{GPIO_CFG(65, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_2\"},","\t{GPIO_CFG(66, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_1\"},","\t{GPIO_CFG(67, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\t\"sdc2_dat_0\"},","};","static struct msm_gpio sdc3_cfg_data[] = {","\t{GPIO_CFG(88, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\t\t\t\t\t\t\"sdc3_clk\"},","\t{GPIO_CFG(89, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_cmd\"},","\t{GPIO_CFG(90, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_3\"},","\t{GPIO_CFG(91, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_2\"},","\t{GPIO_CFG(92, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_1\"},","\t{GPIO_CFG(93, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_0\"},","#ifdef CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT","\t{GPIO_CFG(19, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_7\"},","\t{GPIO_CFG(20, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_6\"},","\t{GPIO_CFG(21, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_5\"},","\t{GPIO_CFG(108, 3, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc3_dat_4\"},","#endif","};","","static struct msm_gpio sdc4_cfg_data[] = {","\t{GPIO_CFG(19, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_3\"},","\t{GPIO_CFG(20, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_2\"},","\t{GPIO_CFG(21, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_1\"},","\t{GPIO_CFG(106, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_cmd\"},","\t{GPIO_CFG(108, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),","\t\t\t\t\t\t\t\t\"sdc4_dat_0\"},","\t{GPIO_CFG(109, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),","\t\t\t\t\t\t\t\t\"sdc4_clk\"},","};","","static struct sdcc_gpio sdcc_cfg_data[] = {","\t{","\t\t.cfg_data = sdc1_cfg_data,","\t\t.size = ARRAY_SIZE(sdc1_cfg_data),","\t},","\t{","\t\t.cfg_data = sdc2_cfg_data,","\t\t.size = ARRAY_SIZE(sdc2_cfg_data),","\t\t.sleep_cfg_data = sdc2_sleep_cfg_data,","\t},","\t{","\t},","\t{","\t\t.cfg_data = sdc4_cfg_data,","\t\t.size = ARRAY_SIZE(sdc4_cfg_data),","\t},","};","","static int msm_sdcc_setup_gpio(int dev_id, unsigned int enable)","{","\tint rc = 0;","\tstruct sdcc_gpio *curr;","","\tcurr = &sdcc_cfg_data[dev_id - 1];","\tif (!(test_bit(dev_id, &gpio_sts)^enable))","\t\treturn rc;","","\tif (enable) {","\t\tset_bit(dev_id, &gpio_sts);","\t\trc = msm_gpios_request_enable(curr->cfg_data, curr->size);","\t\tif (rc)","\t\t\tpr_err(\"%s: Failed to turn on GPIOs for slot %d\\n\",","\t\t\t\t\t__func__,  dev_id);","\t} else {","\t\tclear_bit(dev_id, &gpio_sts);","\t\tif (curr->sleep_cfg_data) {","\t\t\trc = msm_gpios_enable(curr->sleep_cfg_data, curr->size);","\t\t\tmsm_gpios_free(curr->sleep_cfg_data, curr->size);","\t\t\treturn rc;","\t\t}","\t\tmsm_gpios_disable_free(curr->cfg_data, curr->size);","\t}","\treturn rc;","}","","static int msm_sdcc_setup_vreg(int dev_id, unsigned int enable)","{","\tint rc = 0;","\tstruct sdcc_vreg *curr;","","\tcurr = &sdcc_vreg_data[dev_id - 1];","\tprintk(\"%s : %d : %d : level : %d\\n\", __func__, dev_id, enable, curr->level);","","\tif (!(test_bit(dev_id, &vreg_sts)^enable))","\t\treturn rc;","","\tif (enable) {","\t\tset_bit(dev_id, &vreg_sts);","\t\trc = vreg_set_level(curr->vreg_data, curr->level);","\t\tif (rc)","\t\t\tpr_err(\"%s: vreg_set_level() = %d\\n\", __func__, rc);","","\t\trc = vreg_enable(curr->vreg_data);","\t\tif (rc)","\t\t\tpr_err(\"%s: vreg_enable() = %d\\n\", __func__, rc);","\t} else {","\t\tclear_bit(dev_id, &vreg_sts);","\t\trc = vreg_disable(curr->vreg_data);","\t\tif (rc)","\t\t\tpr_err(\"%s: vreg_disable() = %d\\n\", __func__, rc);","\t}","\treturn rc;","}","","static uint32_t msm_sdcc_setup_power(struct device *dv, unsigned int vdd)","{","\tint rc = 0;","\tstruct platform_device *pdev;","","\tpdev = container_of(dv, struct platform_device, dev);","","\trc = msm_sdcc_setup_gpio(pdev->id, !!vdd);","\tif (rc)","\t\tgoto out;","","\trc = msm_sdcc_setup_vreg(pdev->id, !!vdd);","out:","\treturn rc;","}","","#define GPIO_SDC1_HW_DET 94","","#if defined(CONFIG_MMC_MSM_SDC1_SUPPORT) \\","\t&& defined(CONFIG_MMC_MSM_CARD_HW_DETECTION)","static unsigned int msm7x2xa_sdcc_slot_status(struct device *dev)","{","\tint status;","","\tprintk(\"%s entered\\n\", __func__);","","\tstatus = gpio_tlmm_config(GPIO_CFG(GPIO_SDC1_HW_DET, 2, GPIO_CFG_INPUT,","\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_8MA), GPIO_CFG_ENABLE);","\tif (status)","\t\tpr_err(\"%s:Failed to configure tlmm for GPIO %d\\n\", __func__,","\t\t\t\tGPIO_SDC1_HW_DET);","","\tstatus = gpio_request(GPIO_SDC1_HW_DET, \"SD_HW_Detect\");","\tif (status) {","\t\tpr_err(\"%s:Failed to request GPIO %d\\n\", __func__,","\t\t\t\tGPIO_SDC1_HW_DET);","\t} else {","\t\tstatus = gpio_direction_input(GPIO_SDC1_HW_DET);","\t\tif (!status)","\t\t\tstatus = gpio_get_value(GPIO_SDC1_HW_DET);","\t\tgpio_free(GPIO_SDC1_HW_DET);","\t}","","\tstatus = status?0:1 ; //PMMC","\tprintk(\"<=PMMC=> %s : status : %d \\n\", __func__, status);","\treturn status;","}","#endif","","#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT","static struct mmc_platform_data sdc1_plat_data = {","\t.ocr_mask\t= MMC_VDD_28_29,","\t.translate_vdd  = msm_sdcc_setup_power,","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000,","#ifdef CONFIG_MMC_MSM_CARD_HW_DETECTION","\t.status      = msm7x2xa_sdcc_slot_status,","\t.status_irq  = MSM_GPIO_TO_INT(GPIO_SDC1_HW_DET),","\t.irq_flags   = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,","#endif","};","#endif","","#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT","static struct mmc_platform_data sdc2_plat_data = {","\t/*","\t * SDC2 supports only 1.8V, claim for 2.85V range is just","\t * for allowing buggy cards who advertise 2.8V even though","\t * they can operate at 1.8V supply.","\t */","\t.ocr_mask\t= MMC_VDD_28_29 | MMC_VDD_165_195,","\t.translate_vdd  = msm_sdcc_setup_power,","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","#ifndef ATH_POLLING","\t.status = wlan_status,","\t.register_status_notify = register_wlan_status_notify,","#endif /* ATH_POLLING */","#ifdef CONFIG_MMC_MSM_SDIO_SUPPORT","\t.sdiowakeup_irq = MSM_GPIO_TO_INT(66),","#endif /* CONFIG_MMC_MSM_SDIO_SUPPORT */","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000, //24576000, ///*144000,//*/","#ifdef CONFIG_MMC_MSM_SDC2_DUMMY52_REQUIRED","\t.dummy52_required = 1,","#endif","};","#endif","","#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT","static struct mmc_platform_data sdc3_plat_data = {","\t.ocr_mask\t= MMC_VDD_28_29,","\t.translate_vdd  = msm_sdcc_setup_power,","#ifdef CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT","\t.mmc_bus_width  = MMC_CAP_8_BIT_DATA,","#else","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","#endif","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000,","\t.nonremovable\t= 1,","};","#endif","","#if (defined(CONFIG_MMC_MSM_SDC4_SUPPORT)\\","\t\t&& !defined(CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT))","static struct mmc_platform_data sdc4_plat_data = {","\t.ocr_mask\t= MMC_VDD_28_29,","\t.translate_vdd  = msm_sdcc_setup_power,","\t.mmc_bus_width  = MMC_CAP_4_BIT_DATA,","\t.msmsdcc_fmin\t= 144000,","\t.msmsdcc_fmid\t= 24576000,","\t.msmsdcc_fmax\t= 49152000,","};","#endif","#endif","","#ifdef CONFIG_SERIAL_MSM_HS","static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {","\t.inject_rx_on_wakeup\t= 1,","\t.rx_to_inject\t\t= 0xFD,","};","#endif","static struct msm_pm_platform_data msm7x27a_pm_data[MSM_PM_SLEEP_MODE_NR] = {","\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 1,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 16000,","\t\t\t\t\t.residency = 20000,","\t},","\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE_NO_XO_SHUTDOWN] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 1,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 12000,","\t\t\t\t\t.residency = 20000,","\t},","\t[MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 0,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 2000,","\t\t\t\t\t.residency = 0,","\t},","\t[MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT] = {","\t\t\t\t\t.idle_supported = 1,","\t\t\t\t\t.suspend_supported = 1,","\t\t\t\t\t.idle_enabled = 1,","\t\t\t\t\t.suspend_enabled = 1,","\t\t\t\t\t.latency = 2,","\t\t\t\t\t.residency = 0,","\t},","};","","u32 msm7627a_power_collapse_latency(enum msm_pm_sleep_mode mode)","{","\tswitch (mode) {","\tcase MSM_PM_SLEEP_MODE_POWER_COLLAPSE:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE].latency;","\tcase MSM_PM_SLEEP_MODE_POWER_COLLAPSE_NO_XO_SHUTDOWN:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_POWER_COLLAPSE_NO_XO_SHUTDOWN].latency;","\tcase MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT].latency;","\tcase MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT:","\t\treturn msm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT].latency;","\tdefault:","\t\treturn 0;","\t}","}","","static struct msm_pm_boot_platform_data msm_pm_boot_pdata __initdata = {","\t.mode = MSM_PM_BOOT_CONFIG_RESET_VECTOR_PHYS,","\t.p_addr = 0,","};","","static struct android_pmem_platform_data android_pmem_adsp_pdata = {","\t.name = \"pmem_adsp\",","\t.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,","\t.cached = 1,","\t.memory_type = MEMTYPE_EBI1,","};","","static struct platform_device android_pmem_adsp_device = {","\t.name = \"android_pmem\",","\t.id = 1,","\t.dev = { .platform_data = &android_pmem_adsp_pdata },","};","","static unsigned pmem_mdp_size = MSM_PMEM_MDP_SIZE;","static int __init pmem_mdp_size_setup(char *p)","{","\tpmem_mdp_size = memparse(p, NULL);","\treturn 0;","}","","early_param(\"pmem_mdp_size\", pmem_mdp_size_setup);","","static unsigned pmem_adsp_size = MSM_PMEM_ADSP_SIZE;","static int __init pmem_adsp_size_setup(char *p)","{","\tpmem_adsp_size = memparse(p, NULL);","\treturn 0;","}","","early_param(\"pmem_adsp_size\", pmem_adsp_size_setup);","","static unsigned fb_size = MSM_FB_SIZE;","static int __init fb_size_setup(char *p)","{","\tfb_size = memparse(p, NULL);","\treturn 0;","}","","early_param(\"fb_size\", fb_size_setup);","","static const char * const msm_fb_lcdc_vreg[] = {","\t\t\"gp2\",","\t\t\"msme1\",","};","","static const int msm_fb_lcdc_vreg_mV[] = {","\t2850,","\t1800,","};","","#define LCDC_CONFIG_PROC          21","#define LCDC_UN_CONFIG_PROC       22","#define LCDC_API_PROG             0x30000066","#define LCDC_API_VERS             0x00010001","","#define\tGPIO_SPI_CLK\t\t30","#define\tGPIO_SPI_CS\t\t26","#define\tGPIO_SPI_SDI\t\t57","#define GPIO_SPI_SDO\t23","#define\tGPIO_LCD_RESET_N\t22","#define\tGPIO_LCD_DETECT\t\t38","","struct vreg *lcdc_vreg[ARRAY_SIZE(msm_fb_lcdc_vreg)];","","static int lcdc_gpio_num[] = {","\tGPIO_SPI_CLK,","\tGPIO_SPI_CS,","\tGPIO_SPI_SDI,","\tGPIO_SPI_SDO,","\tGPIO_LCD_RESET_N,","\tGPIO_LCD_DETECT,","};","","static void lcdc_trebon_gpio_init(void)","{","\tint rc;","","\tif (gpio_request(GPIO_SPI_CLK, \"spi_clk\")) {","\t\tpr_err(\"failed to request gpio spi_clk\\n\");","\t}","\tif (gpio_request(GPIO_SPI_CS, \"spi_cs\")) {","\t\tpr_err(\"failed to request gpio spi_cs\\n\");","\t}","\tif (gpio_request(GPIO_SPI_SDI, \"spi_mosi\")) {","\t\tpr_err(\"failed to request gpio spi_sdi\\n\");","\t}","\tif (gpio_request(GPIO_LCD_RESET_N, \"gpio_lcd_reset_n\")) {","\t\tpr_err(\"failed to request gpio lcd_reset_n\\n\");","\t}","","\t/* LCD Detect Irq */","\trc = gpio_tlmm_config(GPIO_CFG(GPIO_LCD_DETECT, 0,","\t\t\t\tGPIO_CFG_INPUT, GPIO_CFG_NO_PULL,","\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"%s: gpio_tlmm_config for %d failed\\n\",","\t\t\t__func__, GPIO_LCD_DETECT);","\t\t//goto err;","\t}","","\trc = gpio_request(GPIO_LCD_DETECT, \"gpio_lcd_detect\");","\tif (rc) {","\t\tpr_err(\"%s: unable to request gpio %d\\n\",","\t\t\t__func__, GPIO_LCD_DETECT);","\t\t//goto err;","\t}","","\trc = gpio_direction_input(GPIO_LCD_DETECT);","\tif (rc < 0) {","\t\tpr_err(\"%s: unable to set the direction of gpio %d\\n\",","\t\t\t__func__, GPIO_LCD_DETECT);","\t\t//goto err;","\t}","","\treturn;","}","","static uint32_t lcdc_gpio_table[] = {","\tGPIO_CFG(GPIO_SPI_CLK, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\tGPIO_CFG(GPIO_SPI_CS, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\tGPIO_CFG(GPIO_SPI_SDI, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\tGPIO_CFG(GPIO_LCD_RESET_N,  0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","};","","static void config_lcdc_gpio_table(uint32_t *table, int len, unsigned enable)","{","\tint n, rc;","","\tfor (n = 0; n < len; n++) {","\t\trc = gpio_tlmm_config(table[n],","\t\t\tenable ? GPIO_CFG_ENABLE : GPIO_CFG_DISABLE);","\t\tif (rc) {","\t\t\tprintk(KERN_ERR \"%s: gpio_tlmm_config(%#x)=%d\\n\",","\t\t\t\t__func__, table[n], rc);","\t\t\tbreak;","\t\t}","\t}","}","static int msm_fb_lcdc_power_save(int on)","{","    return 0;","}","","static struct lcdc_platform_data lcdc_pdata = {","\t.lcdc_gpio_config = NULL,","\t.lcdc_power_save   = msm_fb_lcdc_power_save,","};","","static struct resource lcdc_trebon_resources[] = {","\t{","\t\t.name = \"lcd_breakdown_det\",","\t\t.start = MSM_GPIO_TO_INT(GPIO_LCD_DETECT),","\t\t.end = MSM_GPIO_TO_INT(GPIO_LCD_DETECT),","\t\t.flags  = IORESOURCE_IRQ,","\t}","};","","static void lcdc_trebon_config_gpios(int enable)","{","\tconfig_lcdc_gpio_table(lcdc_gpio_table,","\t\tARRAY_SIZE(lcdc_gpio_table), enable);","}","","static struct msm_panel_common_pdata lcdc_trebon_panel_data = {","\t.panel_config_gpio = lcdc_trebon_config_gpios,","\t.gpio_num\t  = lcdc_gpio_num,","","};","","static struct platform_device lcdc_trebon_panel_device = {","#if defined(CONFIG_FB_MSM_LCDC_TREBON_HVGA)","\t.name   = \"lcdc_trebon_hvga\",","\t.num_resources  = ARRAY_SIZE(lcdc_trebon_resources),","\t.resource       = lcdc_trebon_resources,","#else","\t.name   = \"lcdc_s6d16a0x_hvga\",","#endif","\t.id     = 0,","\t.dev    = {","\t\t.platform_data = &lcdc_trebon_panel_data,","\t}","};","","#ifdef CONFIG_TOUCHSCREEN_ZINITIX_TREBON","static void tsp_power_on(void)","{","\tint rc = 0;","\tprintk(\"[TSP] %s start \\n\", __func__);","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\trc = gpio_request(41, \"touch_en\");","#else","\trc = gpio_request(78, \"touch_en\");","","#endif","\tif (rc < 0) {","\t\tpr_err(\"failed to request touch_en\\n\");","\t}","","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\tgpio_tlmm_config(GPIO_CFG(41, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_direction_output(41, 1);","#else","\tgpio_tlmm_config(GPIO_CFG(78, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_direction_output(78, 1);","#endif","}","#endif","","struct class *sec_class;","EXPORT_SYMBOL(sec_class);","","static void samsung_sys_class_init(void)","{","\tpr_info(\"samsung sys class init.\\n\");","","\tsec_class = class_create(THIS_MODULE, \"sec\");","\tif (IS_ERR(sec_class))","\t\tpr_err(\"Failed to create class(sec) !\\n\");","","}","","static struct resource msm_fb_resources[] = {","\t{","\t\t.flags  = IORESOURCE_DMA,","\t}","};","","/*","* The function of \"update_panel_name()\" is working for support","* different lcd panel more than two. The operation of this function","* is that get the panel name from command line that is pass on from","* bootloader and update lcd id.","*/","static int __init update_panel_name(char *panel_name)","{","\tint i;","\tchar *src = panel_name;","\tchar panel[2][4] = {\"SMD\", \"AUO\"};","\tint panel_id[2] = {1, 2};","\tstatic int lcd_id = -1;","","\tif (!strncmp(src, \"GET\", 3)) {","\t\tprintk(KERN_INFO, \"%s : Lcd name is %s\\n\",","\t\t\t\t__func__, panel[lcd_id - 1]);","\t\treturn lcd_id;","\t} else {","\t\tfor (i = 0; i < sizeof(panel) / sizeof(panel[0]); i++) {","\t\t\tif (!strncmp(src, panel[i], sizeof(panel[i])))","\t\t\t\tlcd_id = panel_id[i];","\t\t}","","\t\tif (lcd_id == -1) {","\t\t\tprintk(KERN_INFO, \"%s : Fail to get lcd panel name\"","\t\t\t\t\" from bootloader\\n\", __func__);","\t\t\tlcd_id = panel_id[1];","\t\t} else {","\t\t\tprintk(KERN_INFO, \"%s : Success to get\"","\t\t\t\t\"lcd panel name(%s) from bootloader\\n\",","\t\t\t\t__func__, panel[lcd_id - 1]);","\t\t}","\t}","","\treturn 1;","}","__setup(\"panel_name=\", update_panel_name);","","/*","* The function of \"msm_fb_detect_panel()\" is working for search","* one panel among panels using the string(variable of panel).","*/","static int msm_fb_detect_panel(const char *name)","{","\tint ret = -EPERM;","\tchar panel[2][21] = {\"lcdc_trebon_smd_hvga\", \"lcdc_trebon_auo_hvga\"};","\tint lcd_id = -1;","\tlcd_id = update_panel_name(\"GET\");","\tprintk(KERN_INFO \"LCD %s selected\\n\", panel[lcd_id - 1]);","","#if defined(CONFIG_FB_MSM_LCDC_S6D16A0X_HVGA)","\t\tif (!strncmp(name, \"lcdc_s6d16a0x_hvga\"), 19)","\t\t\tret = 0;","\t\telse","\t\t\tret = -ENODEV;","#elif defined(CONFIG_FB_MSM_LCDC_TREBON_HVGA)","\t\tif (!strncmp(name, panel[lcd_id - 1],","\t\t\t\t\tsizeof(panel[lcd_id - 1])))","\t\t\tret = 0;","\t\telse","\t\t\tret = -ENODEV;","#else","#endif","\treturn ret;","}","","static struct msm_fb_platform_data msm_fb_pdata = {","\t.detect_client = msm_fb_detect_panel,","};","","static struct platform_device msm_fb_device = {","\t.name   = \"msm_fb\",","\t.id     = 0,","\t.num_resources  = ARRAY_SIZE(msm_fb_resources),","\t.resource       = msm_fb_resources,","\t.dev    = {","\t\t.platform_data = &msm_fb_pdata,","\t}","};","","#ifdef CONFIG_FB_MSM_MIPI_DSI","static int mipi_renesas_set_bl(int level)","{","\tint ret;","","\tret = pmapp_disp_backlight_set_brightness(level);","","\tif (ret)","\t\tpr_err(\"%s: can't set lcd backlight!\\n\", __func__);","","\treturn ret;","}","","static struct msm_panel_common_pdata mipi_renesas_pdata = {","\t.pmic_backlight = mipi_renesas_set_bl,","};","","","static struct platform_device mipi_dsi_renesas_panel_device = {","\t.name = \"mipi_renesas\",","\t.id = 0,","\t.dev    = {","\t\t.platform_data = &mipi_renesas_pdata,","\t}","};","#endif","","","static void __init msm7x27a_init_mmc(void)","{","        vreg_emmc = vreg_get(NULL,\"msme1\");","        if (IS_ERR(vreg_emmc)) {","                pr_err(\"%s: vreg get failed (%ld)\\n\",","                                __func__, PTR_ERR(vreg_emmc));","                return;","        }","","        vreg_mmc = vreg_get(NULL,\"mmc\");","        if (IS_ERR(vreg_mmc)) {","                pr_err(\"%s: vreg get failed (%ld)\\n\",","                                __func__, PTR_ERR(vreg_mmc));","                return;","        }","","\t/* eMMC slot */","#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT","\tsdcc_vreg_data[2].vreg_data = vreg_emmc;","\tsdcc_vreg_data[2].level = 1800;","\tmsm_add_sdcc(3, &sdc3_plat_data);","#endif","\t/* Micro-SD slot */","#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT","\tsdcc_vreg_data[0].vreg_data = vreg_mmc;","\tsdcc_vreg_data[0].level = 2850;","\tmsm_add_sdcc(1, &sdc1_plat_data);","#endif","\t/* SDIO WLAN slot */","#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT","\tsdcc_vreg_data[1].vreg_data = vreg_emmc;","\tsdcc_vreg_data[1].level = 1800; /* 2850 */","\tmsm_add_sdcc(2, &sdc2_plat_data);","#endif","\t/* Not Used */","#if (defined(CONFIG_MMC_MSM_SDC4_SUPPORT)\\","\t\t&& !defined(CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT))","\tsdcc_vreg_data[3].vreg_data = vreg_mmc;","\tsdcc_vreg_data[3].level = 2850;","\tmsm_add_sdcc(4, &sdc4_plat_data);","#endif","}","","#define SND(desc, num) { .name = #desc, .id = num }","static struct snd_endpoint snd_endpoints_list[] = {","\tSND(HANDSET, 0),","\tSND(MONO_HEADSET, 2),","\tSND(HEADSET, 3),","\tSND(SPEAKER, 6),","\tSND(TTY_HEADSET, 8),","\tSND(TTY_VCO, 9),","\tSND(TTY_HCO, 10),","\tSND(BT, 12),","\tSND(IN_S_SADC_OUT_HANDSET, 16),","\tSND(VOICE_RECOGNITION, 24),","\tSND(FM_DIGITAL_STEREO_HEADSET, 26),","\tSND(FM_DIGITAL_SPEAKER_PHONE, 27),","\tSND(FM_DIGITAL_BT_A2DP_HEADSET, 28),","\tSND(FM_STEREO_HEADSET, 29),","\tSND(FM_SPEAKER_PHONE, 30),","\tSND(STEREO_HEADSET_AND_SPEAKER, 31),","\tSND(HEADSET_AND_SPEAKER, 32),","\tSND(STEREO_HEADSET_3POLE, 34),","\tSND(MP3_SPEAKER_PHONE, 35),","\tSND(MP3_STEREO_HEADSET, 36),","\tSND(BT_NSEC_OFF, 37),","\tSND(HANDSET_VOIP, 38),","\tSND(STEREO_HEADSET_VOIP, 39),","\tSND(SPEAKER_VOIP, 40),","\tSND(BT_VOIP, 41),","\tSND(HANDSET_VOIP2, 42),","\tSND(STEREO_HEADSET_VOIP2, 43),","\tSND(SPEAKER_VOIP2, 44),","\tSND(BT_VOIP2, 45),","\tSND(VOICE_RECORDER_HPH, 46),","\tSND(VOICE_RECORDER_SPK, 47),","\tSND(FM_ANALOG_STEREO_HEADSET, 50),","\tSND(FM_ANALOG_STEREO_HEADSET_CODEC, 51),","\tSND(CURRENT, 0x7FFFFFFE),","};","#undef SND","","static struct msm_snd_endpoints msm_device_snd_endpoints = {","\t.endpoints = snd_endpoints_list,","\t.num = sizeof(snd_endpoints_list) / sizeof(struct snd_endpoint)","};","","static struct platform_device msm_device_snd = {","\t.name = \"msm_snd\",","\t.id = -1,","\t.dev    = {","\t\t.platform_data = &msm_device_snd_endpoints","\t},","};","","#define DEC0_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC1_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC2_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC3_FORMAT ((1<<MSM_ADSP_CODEC_MP3)| \\","\t(1<<MSM_ADSP_CODEC_AAC)|(1<<MSM_ADSP_CODEC_WMA)| \\","\t(1<<MSM_ADSP_CODEC_WMAPRO)|(1<<MSM_ADSP_CODEC_AMRWB)| \\","\t(1<<MSM_ADSP_CODEC_AMRNB)|(1<<MSM_ADSP_CODEC_WAV)| \\","\t(1<<MSM_ADSP_CODEC_ADPCM)|(1<<MSM_ADSP_CODEC_YADPCM)| \\","\t(1<<MSM_ADSP_CODEC_EVRC)|(1<<MSM_ADSP_CODEC_QCELP))","#define DEC4_FORMAT (1<<MSM_ADSP_CODEC_MIDI)","","static unsigned int dec_concurrency_table[] = {","\t/* Audio LP */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DMA)), 0,","\t0, 0, 0,","","\t/* Concurrency 1 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t /* Concurrency 2 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 3 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 4 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 5 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","","\t/* Concurrency 6 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_TUNNEL)|","\t\t\t(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t0, 0, 0, 0,","","\t/* Concurrency 7 */","\t(DEC0_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC1_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC2_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC3_FORMAT|(1<<MSM_ADSP_MODE_NONTUNNEL)|(1<<MSM_ADSP_OP_DM)),","\t(DEC4_FORMAT),","};","","#define DEC_INFO(name, queueid, decid, nr_codec) { .module_name = name, \\","\t.module_queueid = queueid, .module_decid = decid, \\","\t.nr_codec_support = nr_codec}","","static struct msm_adspdec_info dec_info_list[] = {","\tDEC_INFO(\"AUDPLAY0TASK\", 13, 0, 11), /* AudPlay0BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY1TASK\", 14, 1, 11),  /* AudPlay1BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY2TASK\", 15, 2, 11),  /* AudPlay2BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY3TASK\", 16, 3, 11),  /* AudPlay3BitStreamCtrlQueue */","\tDEC_INFO(\"AUDPLAY4TASK\", 17, 4, 1),  /* AudPlay4BitStreamCtrlQueue */","};","","static struct msm_adspdec_database msm_device_adspdec_database = {","\t.num_dec = ARRAY_SIZE(dec_info_list),","\t.num_concurrency_support = (ARRAY_SIZE(dec_concurrency_table) / \\","\t\t\t\t\tARRAY_SIZE(dec_info_list)),","\t.dec_concurrency_table = dec_concurrency_table,","\t.dec_info_list = dec_info_list,","};","","static struct platform_device msm_device_adspdec = {","\t.name = \"msm_adspdec\",","\t.id = -1,","\t.dev    = {","\t\t.platform_data = &msm_device_adspdec_database","\t},","};","","static struct android_pmem_platform_data android_pmem_audio_pdata = {","\t.name = \"pmem_audio\",","\t.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,","\t.cached = 0,","\t.memory_type = MEMTYPE_EBI1,","};","","static struct platform_device android_pmem_audio_device = {","\t.name = \"android_pmem\",","\t.id = 2,","\t.dev = { .platform_data = &android_pmem_audio_pdata },","};","","static struct android_pmem_platform_data android_pmem_pdata = {","\t.name = \"pmem\",","\t.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,","\t.cached = 1,","\t.memory_type = MEMTYPE_EBI1,","};","static struct platform_device android_pmem_device = {","\t.name = \"android_pmem\",","\t.id = 0,","\t.dev = { .platform_data = &android_pmem_pdata },","};","","static struct smsc911x_platform_config smsc911x_config = {","\t.irq_polarity\t= SMSC911X_IRQ_POLARITY_ACTIVE_HIGH,","\t.irq_type\t= SMSC911X_IRQ_TYPE_PUSH_PULL,","\t.flags\t\t= SMSC911X_USE_16BIT,","};","","static struct resource smsc911x_resources[] = {","\t[0] = {","\t\t.start\t= 0x90000000,","\t\t.end\t= 0x90007fff,","\t\t.flags\t= IORESOURCE_MEM,","\t},","\t[1] = {","\t\t.start\t= MSM_GPIO_TO_INT(48),","\t\t.end\t= MSM_GPIO_TO_INT(48),","\t\t.flags\t= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,","\t},","};","","static struct platform_device smsc911x_device = {","\t.name\t\t= \"smsc911x\",","\t.id\t\t= 0,","\t.num_resources\t= ARRAY_SIZE(smsc911x_resources),","\t.resource\t= smsc911x_resources,","\t.dev\t\t= {","\t\t.platform_data\t= &smsc911x_config,","\t},","};","","static struct msm_gpio smsc911x_gpios[] = {","\t{ GPIO_CFG(48, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_6MA),","\t\t\t\t\t\t\t \"smsc911x_irq\"  },","\t{ GPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_6MA),","\t\t\t\t\t\t\t \"eth_fifo_sel\" },","};","","#define ETH_FIFO_SEL_GPIO\t49","static void msm7x27a_cfg_smsc911x(void)","{","\tint res;","","\tres = msm_gpios_request_enable(smsc911x_gpios,","\t\t\t\t ARRAY_SIZE(smsc911x_gpios));","\tif (res) {","\t\tpr_err(\"%s: unable to enable gpios for SMSC911x\\n\", __func__);","\t\treturn;","\t}","","\t/* ETH_FIFO_SEL */","\tres = gpio_direction_output(ETH_FIFO_SEL_GPIO, 0);","\tif (res) {","\t\tpr_err(\"%s: unable to get direction for gpio %d\\n\", __func__,","\t\t\t\t\t\t\t ETH_FIFO_SEL_GPIO);","\t\tmsm_gpios_disable_free(smsc911x_gpios,","\t\t\t\t\t\t ARRAY_SIZE(smsc911x_gpios));","\t\treturn;","\t}","\tgpio_set_value(ETH_FIFO_SEL_GPIO, 0);","}","","#ifdef CONFIG_MSM_CAMERA","static uint32_t camera_off_gpio_table[] = {","\tGPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","};","","static uint32_t camera_on_gpio_table[] = {","","#ifdef CONFIG_MACH_JENA","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\tGPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(18, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(58, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(98, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(84, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(107, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","#else","\tGPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(93, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(92, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(89, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(84, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(79, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","\tGPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),","#endif","#endif","","};","","#ifdef CONFIG_MSM_CAMERA_FLASH","static struct msm_camera_sensor_flash_src msm_flash_src = {","\t.flash_sr_type = MSM_CAMERA_FLASH_SRC_CURRENT_DRIVER,","};","#endif","","static struct vreg *vreg_gp1;","static struct vreg *vreg_gp2;","static struct vreg *vreg_gp3;","static void msm_camera_vreg_config(int vreg_en)","{","}","","static int config_gpio_table(uint32_t *table, int len)","{","\tint rc = 0, i = 0;","","\tfor (i = 0; i < len; i++) {","\t\trc = gpio_tlmm_config(table[i], GPIO_CFG_ENABLE);","\t\tif (rc) {","\t\t\tpr_err(\"%s not able to get gpio\\n\", __func__);","\t\t\tfor (i--; i >= 0; i--)","\t\t\t\tgpio_tlmm_config(camera_off_gpio_table[i],","\t\t\t\t\t\t\tGPIO_CFG_ENABLE);","\t\t\tbreak;","\t\t}","\t}","\treturn rc;","}","","static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1_data;","static struct msm_camera_sensor_info msm_camera_sensor_ov9726_data;","static int config_camera_on_gpios_rear(void)","{","\tint rc = 0;","","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(1);","","\trc = config_gpio_table(camera_on_gpio_table,","\t\t\tARRAY_SIZE(camera_on_gpio_table));","\tif (rc < 0) {","\t\tpr_err(\"%s: CAMSENSOR gpio table request\"","\t\t\"failed\\n\", __func__);","\t\treturn rc;","\t}","","\treturn rc;","}","","static void config_camera_off_gpios_rear(void)","{","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(0);","","\tconfig_gpio_table(camera_off_gpio_table,","\t\t\tARRAY_SIZE(camera_off_gpio_table));","}","","static int config_camera_on_gpios_front(void)","{","\tint rc = 0;","","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(1);","","\trc = config_gpio_table(camera_on_gpio_table,","\t\t\tARRAY_SIZE(camera_on_gpio_table));","\tif (rc < 0) {","\t\tpr_err(\"%s: CAMSENSOR gpio table request\"","\t\t\t\"failed\\n\", __func__);","\t\treturn rc;","\t}","","\treturn rc;","}","","static void config_camera_off_gpios_front(void)","{","\tif (machine_is_msm7x27a_ffa())","\t\tmsm_camera_vreg_config(0);","","\tconfig_gpio_table(camera_off_gpio_table,","\t\t\tARRAY_SIZE(camera_off_gpio_table));","}","","struct msm_camera_device_platform_data msm_camera_device_data_rear = {","\t.camera_gpio_on  = config_camera_on_gpios_rear,","\t.camera_gpio_off = config_camera_off_gpios_rear,","\t.ioext.csiphy = 0xA1000000,","\t.ioext.csisz  = 0x00100000,","\t.ioext.csiirq = INT_CSI_IRQ_1,","\t.ioclk.mclk_clk_rate = 24000000,","\t.ioclk.vfe_clk_rate  = 192000000,","\t.ioext.appphy = MSM_CLK_CTL_PHYS,","\t.ioext.appsz  = MSM_CLK_CTL_SIZE,","};","","struct msm_camera_device_platform_data msm_camera_device_data_front = {","\t.camera_gpio_on  = config_camera_on_gpios_front,","\t.camera_gpio_off = config_camera_off_gpios_front,","\t.ioext.csiphy = 0xA0F00000,","\t.ioext.csisz  = 0x00100000,","\t.ioext.csiirq = INT_CSI_IRQ_0,","\t.ioclk.mclk_clk_rate = 24000000,","\t.ioclk.vfe_clk_rate  = 192000000,","\t.ioext.appphy = MSM_CLK_CTL_PHYS,","\t.ioext.appsz  = MSM_CLK_CTL_SIZE,","};","","#ifdef CONFIG_S5K4E1","static struct msm_camera_sensor_platform_info s5k4e1_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_s5k4e1 = {","\t.flash_type             = MSM_CAMERA_FLASH_LED,","\t.flash_src              = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_s5k4e1_data = {","\t.sensor_name    = \"s5k4e1\",","\t.sensor_reset_enable = 1,","\t.sensor_reset   = GPIO_CAM_GP_CAMIF_RESET_N,","\t.sensor_pwd             = 85,","\t.vcm_pwd                = GPIO_CAM_GP_CAM_PWDN,","\t.vcm_enable             = 1,","\t.pdata                  = &msm_camera_device_data_rear,","\t.flash_data             = &flash_s5k4e1,","\t.sensor_platform_info   = &s5k4e1_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_s5k4e1 = {","\t.name   = \"msm_camera_s5k4e1\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_s5k4e1_data,","\t},","};","#endif","","#ifdef CONFIG_IMX072","static struct msm_camera_sensor_platform_info imx072_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_imx072 = {","\t.flash_type             = MSM_CAMERA_FLASH_LED,","\t.flash_src              = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_imx072_data = {","\t.sensor_name    = \"imx072\",","\t.sensor_reset_enable = 1,","\t.sensor_reset   = 85, /* TODO 106,*/","\t.sensor_pwd             = 123,","\t.vcm_pwd                = GPIO_CAM_GP_CAM_PWDN,","\t.vcm_enable             = 1,","\t.pdata                  = &msm_camera_device_data_rear,","\t.flash_data             = &flash_imx072,","\t.sensor_platform_info = &imx072_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_imx072 = {","\t.name   = \"msm_camera_imx072\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_imx072_data,","\t},","};","#endif","","#ifdef CONFIG_WEBCAM_OV9726","static struct msm_camera_sensor_platform_info ov9726_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_ov9726 = {","\t.flash_type             = MSM_CAMERA_FLASH_NONE,","\t.flash_src              = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_ov9726_data = {","\t.sensor_name    = \"ov9726\",","\t.sensor_reset_enable = 0,","\t.sensor_reset   = GPIO_CAM_GP_CAM1MP_XCLR,","\t.sensor_pwd             = 85,","\t.vcm_pwd                = 1,","\t.vcm_enable             = 0,","\t.pdata                  = &msm_camera_device_data_front,","\t.flash_data             = &flash_ov9726,","\t.sensor_platform_info   = &ov9726_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_ov9726 = {","\t.name   = \"msm_camera_ov9726\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_ov9726_data,","\t},","};","#endif","","#ifdef CONFIG_S5K4ECGX","static struct msm_camera_sensor_platform_info s5k4ecgx_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_s5k4ecgx = {","\t.flash_type             = MSM_CAMERA_FLASH_LED,","};","","static struct msm_camera_sensor_info msm_camera_sensor_s5k4ecgx_data = {","\t.sensor_name    = \"s5k4ecgx\",","\t.sensor_reset_enable = 0,","\t.vcm_enable             = 0,","\t.pdata                  = &msm_camera_device_data_rear,","\t.flash_data             = &flash_s5k4ecgx,","\t.sensor_platform_info   = &s5k4ecgx_sensor_7627a_info,","\t.csi_if                 = 1","};","","static struct platform_device msm_camera_sensor_s5k4ecgx = {","\t.name   = \"msm_camera_s5k4ecgx\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_s5k4ecgx_data,","\t},","};","#endif","","#ifdef CONFIG_MT9V113","static struct msm_camera_sensor_platform_info mt9v113_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_mt9v113 = {","\t.flash_type             = MSM_CAMERA_FLASH_NONE,","};","","static struct msm_camera_sensor_info msm_camera_sensor_mt9v113_data = {","\t.sensor_name    = \"mt9v113\",","\t.sensor_reset_enable = 0,","\t.vcm_enable             = 0,","\t.pdata                  = &msm_camera_device_data_front,","\t.flash_data             = &flash_mt9v113,","\t.sensor_platform_info   = &mt9v113_sensor_7627a_info,","\t.csi_if                 = 1 // 0: Parallel interface , 1: MIPI interface","};","","static struct platform_device msm_camera_sensor_mt9v113 = {","\t.name   = \"msm_camera_mt9v113\",","\t.dev    = {","\t\t.platform_data = &msm_camera_sensor_mt9v113_data,","\t},","};","#endif","#ifdef CONFIG_MT9E013","static struct msm_camera_sensor_platform_info mt9e013_sensor_7627a_info = {","\t.mount_angle = 0","};","","static struct msm_camera_sensor_flash_data flash_mt9e013 = {","\t.flash_type = MSM_CAMERA_FLASH_LED,","\t.flash_src  = &msm_flash_src","};","","static struct msm_camera_sensor_info msm_camera_sensor_mt9e013_data = {","\t.sensor_name    = \"mt9e013\",","\t.sensor_reset   = 0,","\t.sensor_reset_enable = 1,","\t.sensor_pwd     = 85,","\t.vcm_pwd        = 1,","\t.vcm_enable     = 0,","\t.pdata          = &msm_camera_device_data_rear,","\t.flash_data     = &flash_mt9e013,","\t.sensor_platform_info   = &mt9e013_sensor_7627a_info,","\t.csi_if         = 1","};","","static struct platform_device msm_camera_sensor_mt9e013 = {","\t.name      = \"msm_camera_mt9e013\",","\t.dev       = {","\t\t.platform_data = &msm_camera_sensor_mt9e013_data,","\t},","};","#endif","","static struct i2c_board_info i2c_camera_devices[] = {","\t#ifdef CONFIG_S5K4E1","\t{","\t\tI2C_BOARD_INFO(\"s5k4e1\", 0x36),","\t},","\t{","\t\tI2C_BOARD_INFO(\"s5k4e1_af\", 0x8c >> 1),","\t},","\t#endif","\t#ifdef CONFIG_WEBCAM_OV9726","\t{","\t\tI2C_BOARD_INFO(\"ov9726\", 0x10),","\t},","\t#endif","\t#ifdef CONFIG_MT9V113","\t{","\t\tI2C_BOARD_INFO(\"mt9v113\", 0x7A >> 1),","\t},","\t#endif","    #ifdef CONFIG_S5K4ECGX","\t{","\t\tI2C_BOARD_INFO(\"s5k4ecgx\", 0xAC >> 1),","\t},","    #endif","\t#ifdef CONFIG_IMX072","\t{","\t\tI2C_BOARD_INFO(\"imx072\", 0x34),","\t},","\t#endif","\t#ifdef CONFIG_MT9E013","\t{","\t\tI2C_BOARD_INFO(\"mt9e013\", 0x6C >> 2),","\t},","\t#endif","\t{","\t\tI2C_BOARD_INFO(\"sc628a\", 0x37),","\t},","};","#endif","","#if defined(CONFIG_SERIAL_MSM_HSL_CONSOLE) \\","\t\t&& defined(CONFIG_MSM_SHARED_GPIO_FOR_UART2DM)","static struct msm_gpio uart2dm_gpios[] = {","\t{GPIO_CFG(19, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_rfr_n\" },","\t{GPIO_CFG(20, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_cts_n\" },","\t{GPIO_CFG(21, 2, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_rx\"    },","\t{GPIO_CFG(108, 2, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),","\t\t\t\t\t\t\t\"uart2dm_tx\"    },","};","","static void msm7x27a_cfg_uart2dm_serial(void)","{","\tint ret;","\tret = msm_gpios_request_enable(uart2dm_gpios,","\t\t\t\t\tARRAY_SIZE(uart2dm_gpios));","\tif (ret)","\t\tpr_err(\"%s: unable to enable gpios for uart2dm\\n\", __func__);","}","#else","static void msm7x27a_cfg_uart2dm_serial(void) { }","#endif","","static struct platform_device *rumi_sim_devices[] __initdata = {","\t&msm_device_dmov,","\t&msm_device_smd,","\t&smc91x_device,","\t&msm_device_uart1,","\t&msm_device_nand,","\t&msm_device_uart_dm1,","\t&msm_gsbi0_qup_i2c_device,","\t&msm_gsbi1_qup_i2c_device","};","","static struct platform_device *surf_ffa_devices[] __initdata = {","\t&msm_device_dmov,","\t&msm_device_smd,","\t&msm_device_uart1,","\t&msm_device_uart_dm1,","\t&msm_device_nand,","\t&msm_gsbi0_qup_i2c_device,","\t&msm_gsbi1_qup_i2c_device,","\t&msm_device_otg,","\t&msm_device_gadget_peripheral,","\t&android_usb_device,","\t&android_pmem_device,","\t&android_pmem_adsp_device,","\t&android_pmem_audio_device,","\t&msm_device_snd,","\t&msm_device_adspdec,","\t&msm_fb_device,","\t&lcdc_trebon_panel_device,","\t&msm_batt_device,","\t&msm_kgsl_3d0,","#ifdef CONFIG_ANDROID_RAM_CONSOLE","\t&ram_console_device,","#endif","#ifdef CONFIG_ION_MSM","\t&ion_dev,","#endif","#ifdef CONFIG_IMX072","\t&msm_camera_sensor_imx072,","#endif","#ifdef CONFIG_WEBCAM_OV9726","\t&msm_camera_sensor_ov9726,","#endif","#ifdef CONFIG_S5K4ECGX","\t&msm_camera_sensor_s5k4ecgx,","#endif","","#ifdef CONFIG_MT9V113","\t&msm_camera_sensor_mt9v113,","#endif","#ifdef CONFIG_MT9E013","\t&msm_camera_sensor_mt9e013,","#endif","#ifdef CONFIG_FB_MSM_MIPI_DSI","\t&mipi_dsi_renesas_panel_device,","#endif","#ifdef CONFIG_BT","\t&msm_bt_power_device,","#endif","\t&touch_i2c_gpio_device,","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t&sensor_i2c_gpio_device,","#endif","#ifdef CONFIG_BQ27425_FUEL_GAUGE","\t&fuelgauge_i2c_gpio_device,","#endif","\t&fsa880_i2c_gpio_device,","\t&msm_device_pmic_leds,","\t&msm_vibrator_device,","#ifdef CONFIG_SAMSUNG_JACK","\t&sec_device_jack,","#endif","\t&asoc_msm_pcm,","\t&asoc_msm_dai0,","\t&asoc_msm_dai1,","};","","static unsigned pmem_kernel_ebi1_size = PMEM_KERNEL_EBI1_SIZE;","static int __init pmem_kernel_ebi1_size_setup(char *p)","{","\tpmem_kernel_ebi1_size = memparse(p, NULL);","\treturn 0;","}","early_param(\"pmem_kernel_ebi1_size\", pmem_kernel_ebi1_size_setup);","","static unsigned pmem_audio_size = MSM_PMEM_AUDIO_SIZE;","static int __init pmem_audio_size_setup(char *p)","{","\tpmem_audio_size = memparse(p, NULL);","\treturn 0;","}","early_param(\"pmem_audio_size\", pmem_audio_size_setup);","","static void __init msm_msm7x2x_allocate_memory_regions(void)","{","\tvoid *addr;","\tunsigned long size;","","\tsize = fb_size ? : MSM_FB_SIZE;","\taddr = alloc_bootmem_align(size, 0x1000);","\tmsm_fb_resources[0].start = __pa(addr);","\tmsm_fb_resources[0].end = msm_fb_resources[0].start + size - 1;","\tpr_info(\"allocating %lu bytes at %p (%lx physical) for fb\\n\",","\t\tsize, addr, __pa(addr));","\t\t","#ifdef CONFIG_ANDROID_RAM_CONSOLE","\t/* RAM Console can't use alloc_bootmem(), since that zeroes the","     * region */","    size = MSM_RAM_CONSOLE_SIZE;","    ram_console_resources[0].start = msm_fb_resources[0].end+1;","    ram_console_resources[0].end = ram_console_resources[0].start + size - 1;","    pr_info(\"allocating %lu bytes at (%lx physical) for ram console\\n\",","           size, (unsigned long)ram_console_resources[0].start);","    /* We still have to reserve it, though */","    reserve_bootmem(ram_console_resources[0].start,size,0);","#endif","}","","#ifdef CONFIG_ION_MSM","#ifdef CONFIG_MSM_MULTIMEDIA_USE_ION","static struct ion_co_heap_pdata co_ion_pdata = {","\t.adjacent_mem_id = INVALID_HEAP_ID,","\t.align = PAGE_SIZE,","};","#endif","","/**"," * These heaps are listed in the order they will be allocated."," * Don't swap the order unless you know what you are doing!"," */","static struct ion_platform_data ion_pdata = {","        .nr = MSM_ION_HEAP_NUM,","        .has_outer_cache = 1,","        .heaps = {","                {","                        .id        = ION_SYSTEM_HEAP_ID,","                        .type        = ION_HEAP_TYPE_SYSTEM,","                        .name        = ION_VMALLOC_HEAP_NAME,","                },","#ifdef CONFIG_MSM_MULTIMEDIA_USE_ION","                /* PMEM_ADSP = CAMERA */","                {","                        .id        = ION_CAMERA_HEAP_ID,","                        .type        = ION_HEAP_TYPE_CARVEOUT,","                        .name        = ION_CAMERA_HEAP_NAME,","                        .memory_type = ION_EBI_TYPE,","                        .extra_data = (void *)&co_ion_pdata,","                },","                /* PMEM_AUDIO */","                {","                        .id        = ION_AUDIO_HEAP_ID,","                        .type        = ION_HEAP_TYPE_CARVEOUT,","                        .name        = ION_AUDIO_HEAP_NAME,","                        .memory_type = ION_EBI_TYPE,","                        .extra_data = (void *)&co_ion_pdata,","                },","                /* PMEM_MDP = SF */","                {","                        .id        = ION_SF_HEAP_ID,","                        .type        = ION_HEAP_TYPE_CARVEOUT,","                        .name        = ION_SF_HEAP_NAME,","                        .memory_type = ION_EBI_TYPE,","                        .extra_data = (void *)&co_ion_pdata,","                },","#endif","        }","};","","static struct platform_device ion_dev = {","\t.name = \"ion-msm\",","\t.id = 1,","\t.dev = { .platform_data = &ion_pdata },","};","#endif","","static struct memtype_reserve msm7x27a_reserve_table[] __initdata = {","\t[MEMTYPE_SMI] = {","\t},","\t[MEMTYPE_EBI0] = {","\t\t.flags\t=\tMEMTYPE_FLAGS_1M_ALIGN,","\t},","\t[MEMTYPE_EBI1] = {","\t\t.flags\t=\tMEMTYPE_FLAGS_1M_ALIGN,","\t},","};","","#ifdef CONFIG_ANDROID_PMEM","#if !defined(CONFIG_MSM_MULTIMEDIA_USE_ION) || defined(CONFIG_MSM_ADSP_USE_PMEM)","static struct android_pmem_platform_data *pmem_pdata_array[] __initdata = {","#ifdef CONFIG_MSM_ADSP_USE_PMEM","\t\t&android_pmem_adsp_pdata,","#endif","#ifndef CONFIG_MSM_MULTIMEDIA_USE_ION","\t\t&android_pmem_audio_pdata,","\t\t&android_pmem_pdata,","#endif","};","#endif","#endif","","static void __init size_pmem_devices(void)","{","#ifdef CONFIG_ANDROID_PMEM","#ifdef CONFIG_MSM_ADSP_USE_PMEM","\tandroid_pmem_adsp_pdata.size = pmem_adsp_size;","#endif","#ifndef CONFIG_MSM_MULTIMEDIA_USE_ION","\tandroid_pmem_pdata.size = pmem_mdp_size;","\tandroid_pmem_audio_pdata.size = pmem_audio_size;","","#endif","#endif","}","","#ifdef CONFIG_ANDROID_PMEM","#if !defined(CONFIG_MSM_MULTIMEDIA_USE_ION) || defined(CONFIG_MSM_ADSP_USE_PMEM)","static void __init reserve_memory_for(struct android_pmem_platform_data *p)","{","\tmsm7x27a_reserve_table[p->memory_type].size += p->size;","}","#endif","#endif","","static void __init reserve_pmem_memory(void)","{","#ifdef CONFIG_ANDROID_PMEM","#if !defined(CONFIG_MSM_MULTIMEDIA_USE_ION) || defined(CONFIG_MSM_ADSP_USE_PMEM)","\tunsigned int i;","\tfor (i = 0; i < ARRAY_SIZE(pmem_pdata_array); ++i)","\t\treserve_memory_for(pmem_pdata_array[i]);","","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += pmem_kernel_ebi1_size;","#endif","#endif","}","","static void __init size_ion_devices(void)","{","#ifdef CONFIG_MSM_MULTIMEDIA_USE_ION","\tion_pdata.heaps[1].size = msm_ion_camera_size;","\tion_pdata.heaps[2].size = msm_ion_audio_size;","\tion_pdata.heaps[3].size = msm_ion_sf_size;","#endif","}","","static void __init reserve_ion_memory(void)","{","#if defined(CONFIG_ION_MSM) && defined(CONFIG_MSM_MULTIMEDIA_USE_ION)","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += msm_ion_camera_size;","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += msm_ion_audio_size;","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += msm_ion_sf_size;","\tmsm7x27a_reserve_table[MEMTYPE_EBI1].size += 1;","#endif","}","","static void __init msm7x27a_calculate_reserve_sizes(void)","{","\tsize_pmem_devices();","\treserve_pmem_memory();","\tsize_ion_devices();","\treserve_ion_memory();","}","","static int msm7x27a_paddr_to_memtype(unsigned int paddr)","{","\treturn MEMTYPE_EBI1;","}","","static struct reserve_info msm7x27a_reserve_info __initdata = {","\t.memtype_reserve_table = msm7x27a_reserve_table,","\t.calculate_reserve_sizes = msm7x27a_calculate_reserve_sizes,","\t.paddr_to_memtype = msm7x27a_paddr_to_memtype,","};","","static void __init msm7x27a_reserve(void)","{","\treserve_info = &msm7x27a_reserve_info;","\tmsm_reserve();","}","","static void __init msm_device_i2c_init(void)","{","\tmsm_gsbi0_qup_i2c_device.dev.platform_data = &msm_gsbi0_qup_i2c_pdata;","\tmsm_gsbi1_qup_i2c_device.dev.platform_data = &msm_gsbi1_qup_i2c_pdata;","","\tgpio_tlmm_config(GPIO_CFG(GPIO_TSP_SDA, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_TSP_SCL, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_MUS_SDA, 0, GPIO_CFG_OUTPUT,","\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_MUS_SCL, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","#if (CONFIG_MACH_TREBON_HWREV == 0x0)","\t#if defined(CONFIG_SENSORS_HSCD) || defined(CONFIG_PROXIMITY_SENSOR)","\tgpio_tlmm_config(GPIO_CFG(GPIO_SENSOR_SCL, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(GPIO_SENSOR_SDA, 0, GPIO_CFG_OUTPUT,","\t\t\t\tGPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);","\t#endif","#endif","\tprintk(\"[TSP] %s =======gpio_request==test======ln=%d\\n\",","\t\t\t__func__, __LINE__);","}","","static struct msm_panel_common_pdata mdp_pdata = {","\t.gpio = 97,","\t.mdp_rev = MDP_REV_303,","};","","#define GPIO_LCDC_BRDG_PD\t128","#define GPIO_LCDC_BRDG_RESET_N\t129","","#define LCDC_RESET_PHYS\t\t0x90008014","","static\tvoid __iomem *lcdc_reset_ptr;","","static unsigned mipi_dsi_gpio[] = {","\tGPIO_CFG(GPIO_LCDC_BRDG_RESET_N, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,","\t\tGPIO_CFG_2MA),       /* LCDC_BRDG_RESET_N */","\tGPIO_CFG(GPIO_LCDC_BRDG_PD, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,","\t\tGPIO_CFG_2MA),       /* LCDC_BRDG_RESET_N */","};","","enum {","\tDSI_SINGLE_LANE = 1,","\tDSI_TWO_LANES,","};","","static int msm_fb_get_lane_config(void)","{","\tint rc = DSI_TWO_LANES;","","\tif (machine_is_msm7625a_surf() || machine_is_msm7625a_ffa()) {","\t\trc = DSI_SINGLE_LANE;","\t\tpr_info(\"DSI Single Lane\\n\");","\t} else {","\t\tpr_info(\"DSI Two Lanes\\n\");","\t}","\treturn rc;","}","","static int msm_fb_dsi_client_reset(void)","{","\tint rc = 0;","","\trc = gpio_request(GPIO_LCDC_BRDG_RESET_N, \"lcdc_brdg_reset_n\");","\tif (rc < 0) {","\t\tpr_err(\"failed to request lcd brdg reset_n\\n\");","\t\treturn rc;","\t}","","\trc = gpio_request(GPIO_LCDC_BRDG_PD, \"lcdc_brdg_pd\");","\tif (rc < 0) {","\t\tpr_err(\"failed to request lcd brdg pd\\n\");","\t\treturn rc;","\t}","","\trc = gpio_tlmm_config(mipi_dsi_gpio[0], GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"Failed to enable LCDC Bridge reset enable\\n\");","\t\tgoto gpio_error;","\t}","","\trc = gpio_tlmm_config(mipi_dsi_gpio[1], GPIO_CFG_ENABLE);","\tif (rc) {","\t\tpr_err(\"Failed to enable LCDC Bridge pd enable\\n\");","\t\tgoto gpio_error2;","\t}","","\trc = gpio_direction_output(GPIO_LCDC_BRDG_RESET_N, 1);","\trc |= gpio_direction_output(GPIO_LCDC_BRDG_PD, 1);","\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_PD, 0);","","\tif (!rc) {","\t\tif (machine_is_msm7x27a_surf()) {","\t\t\tlcdc_reset_ptr = ioremap_nocache(LCDC_RESET_PHYS,","\t\t\t\tsizeof(uint32_t));","","\t\t\tif (!lcdc_reset_ptr)","\t\t\t\treturn 0;","\t\t}","\t\treturn rc;","\t} else {","\t\tgoto gpio_error;","\t}","","gpio_error2:","\tpr_err(\"Failed GPIO bridge pd\\n\");","\tgpio_free(GPIO_LCDC_BRDG_PD);","","gpio_error:","\tpr_err(\"Failed GPIO bridge reset\\n\");","\tgpio_free(GPIO_LCDC_BRDG_RESET_N);","\treturn rc;","}","","static const char * const msm_fb_dsi_vreg[] = {","\t\"gp2\",","\t\"msme1\",","\t\"mddi\"","};","","static const int msm_fb_dsi_vreg_mV[] = {","\t2850,","\t1800,","\t1200","};","","static struct vreg *dsi_vreg[ARRAY_SIZE(msm_fb_dsi_vreg)];","static int dsi_gpio_initialized;","","static int mipi_dsi_panel_power(int on)","{","\tint i, rc = 0;","\tuint32_t lcdc_reset_cfg;","","\tprintk(KERN_INFO \"%s: %d (on = 1, off = 0)\\n\", __func__, on);","","\t/* I2C-controlled GPIO Expander -init of the GPIOs very late */","\tif (!dsi_gpio_initialized) {","\t\tpmapp_disp_backlight_init();","","\t\trc = gpio_request(GPIO_DISPLAY_PWR_EN, \"gpio_disp_pwr\");","\t\tif (rc < 0) {","\t\t\tpr_err(\"failed to request gpio_disp_pwr\\n\");","\t\t\treturn rc;","\t\t}","","\t\trc = gpio_direction_output(GPIO_DISPLAY_PWR_EN, 1);","\t\tif (rc < 0) {","\t\t\tpr_err(\"failed to enable display pwr\\n\");","\t\t\tgoto fail_gpio1;","\t\t}","","\t\tif (machine_is_msm7x27a_surf()) {","\t\t\trc = gpio_request(GPIO_BACKLIGHT_EN, \"gpio_bkl_en\");","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"failed to request gpio_bkl_en\\n\");","\t\t\t\tgoto fail_gpio1;","\t\t\t}","","\t\t\trc = gpio_direction_output(GPIO_BACKLIGHT_EN, 1);","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"failed to enable backlight\\n\");","\t\t\t\tgoto fail_gpio2;","\t\t\t}","\t\t}","","\t\tfor (i = 0; i < ARRAY_SIZE(msm_fb_dsi_vreg); i++) {","\t\t\tdsi_vreg[i] = vreg_get(0, msm_fb_dsi_vreg[i]);","","\t\t\tif (IS_ERR(dsi_vreg[i])) {","\t\t\t\tpr_err(\"%s: vreg get failed with : (%ld)\\n\",","\t\t\t\t\t__func__, PTR_ERR(dsi_vreg[i]));","\t\t\t\tgoto fail_gpio2;","\t\t\t}","","\t\t\trc = vreg_set_level(dsi_vreg[i],","\t\t\t\tmsm_fb_dsi_vreg_mV[i]);","","\t\t\tif (rc < 0) {","\t\t\t\tpr_err(\"%s: set regulator level failed \"","\t\t\t\t\t\"with :(%d)\\n\",\t__func__, rc);","\t\t\t\tgoto vreg_fail1;","\t\t\t}","\t\t}","\t\tdsi_gpio_initialized = 1;","\t}","","\t\tgpio_set_value_cansleep(GPIO_DISPLAY_PWR_EN, on);","\t\tif (machine_is_msm7x27a_surf()) {","\t\t\tgpio_set_value_cansleep(GPIO_BACKLIGHT_EN, on);","\t\t}","","\t\tif (on) {","\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_PD, 0);","","\t\t\tif (machine_is_msm7x27a_surf()) {","\t\t\t\tlcdc_reset_cfg = readl_relaxed(lcdc_reset_ptr);","\t\t\t\trmb();","\t\t\t\tlcdc_reset_cfg &= ~1;","","\t\t\t\twritel_relaxed(lcdc_reset_cfg, lcdc_reset_ptr);","\t\t\t\tmsleep(20);","\t\t\t\twmb();","\t\t\t\tlcdc_reset_cfg |= 1;","\t\t\t\twritel_relaxed(lcdc_reset_cfg, lcdc_reset_ptr);","\t\t\t} else {","\t\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_RESET_N,","\t\t\t\t\t0);","\t\t\t\tmsleep(20);","\t\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_RESET_N,","\t\t\t\t\t1);","\t\t\t}","","\t\t\tif (pmapp_disp_backlight_set_brightness(100))","\t\t\t\tpr_err(\"backlight set brightness failed\\n\");","\t\t} else {","\t\t\tgpio_set_value_cansleep(GPIO_LCDC_BRDG_PD, 1);","","\t\t\tif (pmapp_disp_backlight_set_brightness(0))","\t\t\t\tpr_err(\"backlight set brightness failed\\n\");","\t\t}","","\t\t/* Configure vreg lines */","\t\tfor (i = 0; i < ARRAY_SIZE(msm_fb_dsi_vreg); i++) {","\t\t\tif (on) {","\t\t\t\trc = vreg_enable(dsi_vreg[i]);","","\t\t\t\tif (rc) {","\t\t\t\t\tprintk(KERN_ERR \"vreg_enable: %s vreg\"","\t\t\t\t\t\t\"operation failed\\n\",","\t\t\t\t\t\tmsm_fb_dsi_vreg[i]);","","\t\t\t\t\tgoto vreg_fail2;","\t\t\t\t}","\t\t\t} else {","\t\t\t\trc = vreg_disable(dsi_vreg[i]);","","\t\t\t\tif (rc) {","\t\t\t\t\tprintk(KERN_ERR \"vreg_disable: %s vreg \"","\t\t\t\t\t\t\"operation failed\\n\",","\t\t\t\t\t\tmsm_fb_dsi_vreg[i]);","\t\t\t\t\tgoto vreg_fail2;","\t\t\t\t}","\t\t\t}","\t\t}","","\treturn rc;","","vreg_fail2:","\tif (on) {","\t\tfor (; i > 0; i--)","\t\t\tvreg_disable(dsi_vreg[i - 1]);","\t} else {","\t\tfor (; i > 0; i--)","\t\t\tvreg_enable(dsi_vreg[i - 1]);","\t}","","\treturn rc;","","vreg_fail1:","\tfor (; i > 0; i--)","\t\tvreg_put(dsi_vreg[i - 1]);","","fail_gpio2:","\tgpio_free(GPIO_BACKLIGHT_EN);","fail_gpio1:","\tgpio_free(GPIO_DISPLAY_PWR_EN);","\tdsi_gpio_initialized = 0;","\treturn rc;","}","","#define MDP_303_VSYNC_GPIO 97","","#ifdef CONFIG_FB_MSM_MDP303","static struct mipi_dsi_platform_data mipi_dsi_pdata = {","\t.vsync_gpio = MDP_303_VSYNC_GPIO,","\t.dsi_power_save   = mipi_dsi_panel_power,","\t.dsi_client_reset = msm_fb_dsi_client_reset,","\t.get_lane_config = msm_fb_get_lane_config,","};","#endif","","static void __init msm_fb_add_devices(void)","{","\tmsm_fb_register_device(\"mdp\", &mdp_pdata);","\tmsm_fb_register_device(\"lcdc\", &lcdc_pdata);","#ifdef CONFIG_FB_MSM_MDP303","\tmsm_fb_register_device(\"mipi_dsi\", &mipi_dsi_pdata);","#endif","}","","#define MSM_EBI2_PHYS\t\t\t0xa0d00000","#define MSM_EBI2_XMEM_CS2_CFG1\t\t0xa0d10030","","static void __init msm7x27a_init_ebi2(void)","{","\tuint32_t ebi2_cfg;","\tvoid __iomem *ebi2_cfg_ptr;","","\tebi2_cfg_ptr = ioremap_nocache(MSM_EBI2_PHYS, sizeof(uint32_t));","\tif (!ebi2_cfg_ptr)","\t\treturn;","","\tebi2_cfg = readl(ebi2_cfg_ptr);","\tif (machine_is_msm7x27a_rumi3() || machine_is_msm7x27a_surf())","\t\tebi2_cfg |= (1 << 4); /* CS2 */","","\twritel(ebi2_cfg, ebi2_cfg_ptr);","\tiounmap(ebi2_cfg_ptr);","","\t/* Enable A/D MUX[bit 31] from EBI2_XMEM_CS2_CFG1 */","\tebi2_cfg_ptr = ioremap_nocache(MSM_EBI2_XMEM_CS2_CFG1,","\t\t\t\t\t\t\t sizeof(uint32_t));","\tif (!ebi2_cfg_ptr)","\t\treturn;","","\tebi2_cfg = readl(ebi2_cfg_ptr);","\tif (machine_is_msm7x27a_surf())","\t\tebi2_cfg |= (1 << 31);","","\twritel(ebi2_cfg, ebi2_cfg_ptr);","\tiounmap(ebi2_cfg_ptr);","}","","static void keypad_gpio_init(void)","{","\tint rc = 0;","\tprintk(KERN_INFO \"[KEY] %s start\\n\", __func__);","","\tgpio_tlmm_config(GPIO_CFG(36, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(37, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(39, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_tlmm_config(GPIO_CFG(31, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, \\","\t\t\t\t\t\tGPIO_CFG_2MA), GPIO_CFG_ENABLE);","\tgpio_set_value_cansleep(31, 0);","}","","#define KP_INDEX(row, col) ((row)*ARRAY_SIZE(kp_col_gpios) + (col))","\tstatic unsigned int kp_row_gpios[] = {36, 37, 39};","\tstatic unsigned int kp_col_gpios[] = {31};","\tstatic unsigned int kp_wakeup_gpios[] = {37};","\tstatic const unsigned short keymap[ARRAY_SIZE(kp_col_gpios) *","\t\t\t\t\t  ARRAY_SIZE(kp_row_gpios)] = {","\t\t[KP_INDEX(0, 0)] = KEY_VOLUMEDOWN,","","\t\t[KP_INDEX(1, 0)] = KEY_HOME,","","\t\t[KP_INDEX(2, 0)] = KEY_VOLUMEUP,","\t};","","/* SURF keypad platform device information */","static struct gpio_event_matrix_info kp_matrix_info = {","\t.info.func\t= gpio_event_matrix_func,","\t.keymap\t\t= keymap,","\t.output_gpios\t= kp_col_gpios,","\t.input_gpios\t= kp_row_gpios,","\t.wakeup_gpios\t= kp_wakeup_gpios,","\t.nwakeups\t= ARRAY_SIZE(kp_wakeup_gpios),","\t.noutputs\t= ARRAY_SIZE(kp_col_gpios),","\t.ninputs\t= ARRAY_SIZE(kp_row_gpios),","\t.settle_time.tv_nsec = 40 * NSEC_PER_USEC,","\t.poll_time.tv_nsec = 20 * NSEC_PER_MSEC,","\t.debounce_delay.tv_nsec = 20 * NSEC_PER_MSEC,","\t.flags\t\t= GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_DRIVE_INACTIVE |","\t\t\t  GPIOKPF_PRINT_UNMAPPED_KEYS | GPIOKPF_DEBOUNCE,","};","","static struct gpio_event_info *kp_info[] = {","\t&kp_matrix_info.info","};","","static struct gpio_event_platform_data kp_pdata = {","\t.name\t\t= \"7x27a_kp\",","\t.info\t\t= kp_info,","\t.info_count\t= ARRAY_SIZE(kp_info)","};","","static struct platform_device kp_pdev = {","\t.name\t= GPIO_EVENT_DEV_NAME,","\t.id\t= -1,","\t.dev\t= {","\t\t.platform_data\t= &kp_pdata,","\t},","};","","static struct msm_handset_platform_data hs_platform_data = {","\t.hs_name = \"sec_jack\",","\t.pwr_key_delay_ms = 500, /* 0 will disable end key */","};","","static struct platform_device hs_pdev = {","\t.name   = \"msm-handset\",","\t.id     = -1,","\t.dev    = {","\t\t.platform_data = &hs_platform_data,","\t},","};","","static struct platform_device msm_proccomm_regulator_dev = {","\t.name   = PROCCOMM_REGULATOR_DEV_NAME,","\t.id     = -1,","\t.dev    = {","\t\t.platform_data = &msm7x27a_proccomm_regulator_data","\t}","};","","static void __init msm7627a_rumi3_init(void)","{","\tmsm7x27a_init_ebi2();","\tplatform_add_devices(rumi_sim_devices,","\t\t\tARRAY_SIZE(rumi_sim_devices));","}","","#define LED_GPIO_PDM\t\t96","#define UART1DM_RX_GPIO\t\t45","","static int __init msm7x27a_init_ar6000pm(void)","{","\treturn platform_device_register(&msm_wlan_ar6000_pm_device);","}","","static void __init msm7x27a_init_regulators(void)","{","\tint rc = platform_device_register(&msm_proccomm_regulator_dev);","\tif (rc)","\t\tpr_err(\"%s: could not register regulator device: %d\\n\",","\t\t\t\t__func__, rc);","}","","static struct msm7x27a_regulators {","  const char *id;","  unsigned   voltage; // in mv","};","","static struct msm7x27a_regulators msm7x27a_reg[] = {","[0] = {","        .id = \"smps3\",","        .voltage = 1800,","      },","};","","/* function to Enable the regulators */","static void msm7x27a_enable_regulators(void)","{","   struct vreg *vreg = NULL;","   struct msm7x27a_regulators *regulators = msm7x27a_reg;","   static int i = 0, ret =0, VRG_SIZE =0;","","   /* Get the count of regulators */","   VRG_SIZE= ARRAY_SIZE(msm7x27a_reg);","","   for(i=0; i<VRG_SIZE; i++) {","","       /* get the regulator descriptor */","       vreg = vreg_get( NULL, regulators[i].id);","","       if(IS_ERR(vreg)) {","         pr_err(\"failed to get the regulator %s\\n\",regulators[i].id);","         return ;","       }","","       /* set the regulator voltage(optimum) */","       ret = vreg_set_level(vreg,regulators[i].voltage);","","       if(ret)","       {","         pr_err(\"failed to set the voltage level for regulator %s\\n\",regulators[i].id);","         return ;","       }","","       /* enable the regulator or ldo */","       if(vreg_enable(vreg))","       {","         pr_err(\"failed to enable the regulator %s\\n\",regulators[i].id);","         return ;","       }","    }","   pr_debug(\"Successfully enabled all regulators\\n\");","   return;","}","","static void __init msm7x2x_init(void)","{","    msm7x2x_misc_init();","","\t/* Initialize the regulators */","\tmsm7x27a_init_regulators();","","\t/* Enable the Required regulators */","    msm7x27a_enable_regulators();","","\t/* Common functions for SURF/FFA/RUMI3 */","\tmsm_device_i2c_init();","\tmsm7x27a_init_ebi2();","","#ifdef CONFIG_SERIAL_MSM_HS","\tmsm_uart_dm1_pdata.wakeup_irq = gpio_to_irq(UART1DM_RX_GPIO);","\tmsm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;","#endif","","#ifdef CONFIG_USB_MSM_OTG_72K","\tmsm_otg_pdata.swfi_latency =","\t\tmsm7x27a_pm_data","\t\t[MSM_PM_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT].latency;","\tmsm_device_otg.dev.platform_data = &msm_otg_pdata;","#endif","\tmsm_device_gadget_peripheral.dev.platform_data =","\t\t&msm_gadget_pdata;","\tmsm7x27a_cfg_smsc911x();","#ifdef CONFIG_SAMSUNG_JACK","\t\tsec_jack_gpio_init();","#endif","\tplatform_add_devices(msm_footswitch_devices,","\t\t\tmsm_num_footswitch_devices);","\tplatform_add_devices(surf_ffa_devices,","\t\t\tARRAY_SIZE(surf_ffa_devices));","\t\tif (!kernel_uart_flag)","\t\t{","\t\t\tplatform_device_register(&msm_device_uart3);","\t\t}","","\t/* Ensure ar6000pm device is registered before MMC/SDC */","\tmsm7x27a_init_ar6000pm();","\tmsm7x27a_init_mmc();","","\tlcdc_trebon_gpio_init();","\tmsm_fb_add_devices();","","","#ifdef CONFIG_USB_EHCI_MSM_72K","\tmsm7x2x_init_host();","#endif","","\tmsm_pm_set_platform_data(msm7x27a_pm_data,","\t\t\t\tARRAY_SIZE(msm7x27a_pm_data));","","\tBUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));","","\tregister_i2c_devices();","","\twlan_power_init();","","#if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)","\tbt_power_init();","#endif","","#ifdef CONFIG_TOUCHSCREEN_ZINITIX_TREBON","\ttsp_power_on();","#endif","","\tsamsung_sys_class_init();","\ti2c_register_board_info( 2, touch_i2c_devices, ARRAY_SIZE(touch_i2c_devices));","\ti2c_register_board_info( 3, fsa880_i2c_devices, ARRAY_SIZE(fsa880_i2c_devices));","#ifdef CONFIG_BQ27425_FUEL_GAUGE","\ti2c_register_board_info(6, fg_i2c_devices, ARRAY_SIZE(fg_i2c_devices));","#endif","","\ti2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,","\t\t\ti2c_camera_devices,","\t\t\tARRAY_SIZE(i2c_camera_devices));","\tkeypad_gpio_init();","\tplatform_device_register(&kp_pdev);","\tplatform_device_register(&hs_pdev);","","\t/* Configure it as a pdm function*/","\tif (gpio_tlmm_config(GPIO_CFG(LED_GPIO_PDM, 3,","\t\t\t\tGPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,","\t\t\t\tGPIO_CFG_8MA), GPIO_CFG_ENABLE))","\t\tpr_err(\"%s: gpio_tlmm_config for %d failed\\n\",","\t\t\t__func__, LED_GPIO_PDM);","\telse","\t\tplatform_device_register(&led_pdev);","","#ifdef CONFIG_MSM_RPC_VIBRATOR","\tif (machine_is_msm7x27a_ffa() || machine_is_msm7625a_ffa())","\t\tmsm_init_pmic_vibrator();","#endif","       /*7x25a kgsl initializations*/","       msm7x25a_kgsl_3d0_init();","","\t   //ar6000_prealloc_init();","}","","static void __init msm7x2x_init_early(void)","{","\tmsm_msm7x2x_allocate_memory_regions();","}","","MACHINE_START(MSM7X27A_RUMI3, \"QCT MSM7x27a RUMI3\")","\t.boot_params\t= PHYS_OFFSET + 0x100,","\t.map_io\t\t= msm_common_io_init,","\t.reserve\t= msm7x27a_reserve,","\t.init_irq\t= msm_init_irq,","\t.init_machine\t= msm7627a_rumi3_init,","\t.timer\t\t= &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7X27A_SURF, \"QCT MSM7x27a SURF\")","\t.boot_params\t= PHYS_OFFSET + 0x100,","\t.map_io\t\t= msm_common_io_init,","\t.reserve\t= msm7x27a_reserve,","\t.init_irq\t= msm_init_irq,","\t.init_machine\t= msm7x2x_init,","\t.timer\t\t= &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7X27A_FFA, \"QCT MSM7x27a FFA\")","\t.boot_params\t= PHYS_OFFSET + 0x100,","\t.map_io\t\t= msm_common_io_init,","\t.reserve\t= msm7x27a_reserve,","\t.init_irq\t= msm_init_irq,","\t.init_machine\t= msm7x2x_init,","\t.timer\t\t= &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7625A_SURF, \"QCT MSM7625a SURF\")","\t.boot_params    = PHYS_OFFSET + 0x100,","\t.map_io         = msm_common_io_init,","\t.reserve        = msm7x27a_reserve,","\t.init_irq       = msm_init_irq,","\t.init_machine   = msm7x2x_init,","\t.timer          = &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END","MACHINE_START(MSM7625A_FFA, \"QCT MSM7625a FFA\")","\t.boot_params    = PHYS_OFFSET + 0x100,","\t.map_io         = msm_common_io_init,","\t.reserve        = msm7x27a_reserve,","\t.init_irq       = msm_init_irq,","\t.init_machine   = msm7x2x_init,","\t.timer          = &msm_timer,","\t.init_early     = msm7x2x_init_early,","\t.handle_irq\t= vic_handle_irq,","MACHINE_END"]}]}],[{"group":"doc","deltas":[{"start":{"row":64,"column":6},"end":{"row":69,"column":2},"action":"remove","lines":["","/*","#ifdef CONFIG_FORCE_FAST_CHARGE","#include <linux/fastchg.h>","#endif","*/"]}]}],[{"group":"doc","deltas":[{"start":{"row":64,"column":6},"end":{"row":65,"column":0},"action":"insert","lines":["",""]}]}]]},"ace":{"folds":[],"scrolltop":576,"scrollleft":0,"selection":{"start":{"row":65,"column":0},"end":{"row":65,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":47,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1417926925184,"hash":"519548fa139b45ea15b755482b8af0cc54c8f689"}